Effective Java 第三版——11. 重写equals方法时同时也要重写hashcode方法
****************************************************************************************************

Tips
《Effective Java, Third Edition》一书英文版已经出版，这本书的第二版想必很多人都读过，号称Java四大名著之一，不过第二版2009年出版，到现在已经将近8年的时间，但随着Java 6，7，8，甚至9的发布，Java语言发生了深刻的变化。
在这里第一时间翻译成中文版。供大家学习分享之用。


11. 重写equals方法时同时也要重写hashcode方法
在每个类中，在重写 equals 方法的时侯，一定要重写 hashcode 方法。如果不这样做，你的类违反了hashCode的通用约定，这会阻止它在HashMap和HashSet这样的集合中正常工作。根据 Object 规范，以下时具体约定。

当在一个应用程序执行过程中，如果在equals方法比较中没有修改任何信息，在一个对象上重复调用hashCode方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。
如果两个对象根据equals(Object)方法比较是相等的，那么在两个对象上调用hashCode就必须产生的结果是相同的整数。
如果两个对象根据equals(Object)方法比较并不相等，则不要求在每个对象上调用hashCode都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（hash tables）的性能。

当无法重写hashCode时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ hash codes）。根据类的equals方法，两个不同的实例可能在逻辑上是相同的，但是对于Object 类的hashCode方法，它们只是两个没有什么共同之处的对象。因此， Object 类的hashCode方法返回两个看似随机的数字，而不是按约定要求的两个相等的数字。
举例说明，假设你使用条目 10中的PhoneNumber类的实例做为HashMap的键（key）：
Map<PhoneNumber, String> m = new HashMap<>();

m.put(new PhoneNumber(707, 867, 5309), "Jenny");
你可能期望m.get(new PhoneNumber(707, 867, 5309))方法返回Jenny字符串，但实际上，返回了 null。注意，这里涉及到两个PhoneNumber实例：一个实例插入到 HashMap 中，另一个作为判断相等的实例用来检索。PhoneNumber类没有重写 hashCode 方法导致两个相等的实例返回了不同的哈希码，违反了 hashCode 约定。put 方法把PhoneNumber实例保存在了一个哈希桶（ hash bucket）中，但get方法却是从不同的哈希桶中去查找，即使恰好两个实例放在同一个哈希桶中，get 方法几乎肯定也会返回 null。因为HashMap 做了优化，缓存了与每一项（entry）相关的哈希码，如果哈希码不匹配，则不会检查对象是否相等了。
解决这个问题很简单，只需要为PhoneNumber类重写一个合适的 hashCode 方法。hashCode方法是什么样的？写一个不规范的方法的是很简单的。以下示例，虽然永远是合法的，但绝对不能这样使用：
// The worst possible legal hashCode implementation - never use!

@Override public int hashCode() { return 42; }
这是合法的，因为它确保了相等的对象具有相同的哈希码。这很糟糕，因为它确保了每个对象都有相同的哈希码。因此，每个对象哈希到同一个桶中，哈希表退化为链表。应该在线性时间内运行的程序，运行时间变成了平方级别。对于数据很大的哈希表而言，会影响到能够正常工作。
一个好的 hash 方法趋向于为不相等的实例生成不相等的哈希码。这也正是 hashCode 约定中第三条的表达。理想情况下，hash 方法为集合中不相等的实例均匀地分配int 范围内的哈希码。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的配方：

声明一个 int 类型的变量result，并将其初始化为对象中第一个重要属性c的哈希码，如下面步骤2.a中所计算的那样。（回顾条目10，重要的属性是影响比较相等的领域。）
对于对象中剩余的重要属性f，请执行以下操作：
a. 比较属性f与属性c的 int 类型的哈希码：
-- i. 如果这个属性是基本类型的，使用 Type.hashCode(f)方法计算，其中Type类是对应属性 f 基本类型的包装类。
-- ii 如果该属性是一个对象引用，并且该类的equals方法通过递归调用equals来比较该属性，并递归地调用hashCode方法。 如果需要更复杂的比较，则计算此字段的“范式（“canonical representation）”，并在范式上调用hashCode。 如果该字段的值为空，则使用0（也可以使用其他常数，但通常来使用0表示）。
-- iii 如果属性f是一个数组，把它看作每个重要的元素都是一个独立的属性。 也就是说，通过递归地应用这些规则计算每个重要元素的哈希码，并且将每个步骤2.b的值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为0。如果所有元素都很重要，则使用Arrays.hashCode方法。
b. 将步骤2.a中属性c计算出的哈希码合并为如下结果：result = 31 * result + c;
返回 result 值。

当你写完hashCode方法后，问自己是否相等的实例有相同的哈希码。 编写单元测试来验证你的直觉（除非你使用AutoValue框架来生成你的equals和hashCode方法，在这种情况下，你可以放心地忽略这些测试）。 如果相同的实例有不相等的哈希码，找出原因并解决问题。
可以从哈希码计算中排除派生属性（derived fields）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。您必须排除在equals比较中没有使用的任何属性，否则可能会违反hashCode约定的第二条。
步骤2.b中的乘法计算结果取决于属性的顺序，如果类中具有多个相似属性，则产生更好的散列函数。 例如，如果乘法计算从一个String散列函数中被省略，则所有的字符将具有相同的散列码。 之所以选择31，因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以2相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 31的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：31 * i ==（i << 5） - i。 现代JVM可以自动进行这种优化。
让我们把上述办法应用到PhoneNumber类中：
// Typical hashCode method

@Override public int hashCode() {

    int result = Short.hashCode(areaCode);

    result = 31 * result + Short.hashCode(prefix);

    result = 31 * result + Short.hashCode(lineNum);

    return result;

}
因为这个方法返回一个简单的确定性计算的结果，它的唯一的输入是PhoneNumber实例中的三个重要的属性，所以显然相等的PhoneNumber实例具有相同的哈希码。 实际上，这个方法是PhoneNumber的一个非常好的hashCode实现，与Java平台类库中的实现一样。 它很简单，速度相当快，并且合理地将不相同的电话号码分散到不同的哈希桶中。
虽然在这个项目的方法产生相当好的哈希函数，但并不是最先进的。 它们的质量与Java平台类库的值类型中找到的哈希函数相当，对于大多数用途来说都是足够的。 如果真的需要哈希函数而不太可能产生碰撞，请参阅Guava框架的的com.google.common.hash.Hashing [Guava]方法。
Objects类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为hash的方法可以让你编写一行hashCode方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的PhoneNumber的哈希函数：
// One-line hashCode method - mediocre performance

@Override public int hashCode() {

   return Objects.hash(lineNum, prefix, areaCode);

}
如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。 如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 否则，可以选择在首次调用hashCode时延迟初始化（lazily initialize）哈希码。 需要注意确保类在存在延迟初始化属性的情况下保持线程安全（项目83）。 PhoneNumber类不适合这种情况，但只是为了展示它是如何完成的。 请注意，属性hashCode的初始值（在本例中为0）不应该是通常创建的实例的哈希码：
// hashCode method with lazily initialized cached hash code

private int hashCode; // Automatically initialized to 0

@Override public int hashCode() {

    int result = hashCode;

    if (result == 0) {

        result = Short.hashCode(areaCode);

        result = 31 * result + Short.hashCode(prefix);

        result = 31 * result + Short.hashCode(lineNum);

        hashCode = result;

    }

    return result;

}
不要试图从哈希码计算中排除重要的属性来提高性能。 由此产生的哈希函数可能运行得更快，但其质量较差可能会降低哈希表的性能，使其无法使用。 具体来说，哈希函数可能会遇到大量不同的实例，这些实例主要在你忽略的区域中有所不同。 如果发生这种情况，哈希函数将把所有这些实例映射到少许哈希码上，而应该以线性时间运行的程序将会运行平方级的时间。
这不仅仅是一个理论问题。 在Java 2之前，String 类哈希函数在整个字符串中最多使用16个字符，从第一个字符开始，在整个字符串中均匀地选取。 对于大量的带有层次名称的集合（如URL），此功能正好显示了前面描述的病态行为。
不要为hashCode返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性。 Java类库中的许多类（例如String和Integer）都将hashCode方法返回的确切值指定为实例值的函数。 这不是一个好主意，而是一个我们不得不忍受的错误：它妨碍了在未来版本中改进哈希函数的能力。 如果未指定细节并在散列函数中发现缺陷，或者发现了更好的哈希函数，则可以在后续版本中对其进行更改。
总之，每次重写equals方法时都必须重写hashCode方法，否则程序将无法正常运行。你的hashCode方法必须遵从Object类指定的常规约定，并且必须执行合理的工作，将不相等的哈希码分配给不相等的实例。如果使用第51页的配方，这很容易实现。如条目 10所述，AutoValue框架为手动编写equals和hashCode方法提供了一个很好的选择，IDE也提供了一些这样的功能。

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/IcanFixIt/p/8179159.html
====================================================================================================
78、excel的读写操作
****************************************************************************************************
本篇主要是用python来自动生成excel数据文件也就是简单的excel读写操作。python读写excel文件主要是第三方模块库xlrd、xlwt。
本篇导航：

写excel
读excel

 
一、写excel
1、准备工作

pip install xlwt

2、写excel

import xlwt

wb = xlwt.Workbook()
sheet = wb.add_sheet('sheet1')

for row in range(10):
    for col in range(5):
        sheet.write(row, col, '第{0}行第{1}列'.format(row, col))

wb.save('xxx.xls')

3、结果图


 
二、读excel
1、准备工作

pip install xlrd

2、读excel

import xlrd

# 打开excel文件
workbook = xlrd.open_workbook('xxx.xls')

# 抓取每页名称['sheet1']
sheet_names = workbook.sheet_names()

# sheet = workbook.sheet_by_name('sheet1')
# 通过索引顺序获取
sheet = workbook.sheet_by_index(0)

# 循环Excel文件的所有行
for row in sheet.get_rows():
    # 循环一行的所有列
    for col in row:
    #     # 获取一个单元格中的值
        print(col.value)

3、结果图

 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/liluning/p/8178062.html
====================================================================================================
一种用于人脸检测的设备上的深度神经网络
****************************************************************************************************

欢迎大家前往云加社区，获取更多腾讯海量技术实践干货哦~

译者：QiqiHe

苹果公司开始在iOS 10中使用深度学习进行人脸检测。随着Vision框架的发布，开发人员现在可以在他们的应用程序中使用这种技术和许多其他计算机视觉算法。本文讨论这些挑战并描述了人脸检测算法。
引言
苹果首先通过CIDetector类在Core Image框架的公共API中发布了人脸检测。这个API也被Apple应用程序内部使用，例如Photos。 CIDetector的最早版本使用了基于Viola-Jones检测算法的方法[1]。我们根据CIDetector对传统计算机视觉方面的进展进行了后续改进。
随着深度学习的出现，以及其在计算机视觉问题中的应用，人脸检测精度的最新进展发生了巨大的飞跃。我们必须彻底重新思考我们的方法，以便我们能够利用这种模式转变。与传统的计算机视觉相比，深度学习的学习模型需要更多的内存，更多的磁盘存储以及更多的计算资源。
像今天的手机一样，典型的高端手机并不是一个可行的深度学习视觉模型平台。大多数行业通过基于云的API提供深度学习解决方案来解决这个问题。在基于云的解决方案中，使用深度学习推理将图像发送到服务器进行分析以检测人脸。基于云的服务通常使用功能强大的桌面级GPU，并提供大量内存。非常大的网络模型以及潜在的大型模型可以在服务器端运行，从而允许客户端（可能是手机）利用大型深度学习体系结构，这在本地运行是不切实际的。
苹果的iCloud照片库是一个基于云的照片和视频存储解决方案。但是，由于苹果对用户隐私的强烈承诺，我们无法将iCloud服务器用于计算机视觉计算。发送到iCloud照片库的每张照片和视频在发送到云存储设备之前都会在设备上进行加密，并且只能通过注册到iCloud帐户的设备进行解密。因此，为了给我们的客户提供基于深度学习的计算机视觉解决方案，我们必须直接解决在iPhone上运行深度学习算法所面临的挑战。
我们面临着几个挑战。深度学习模式需要作为操作系统的一部分，占用宝贵的NAND存储空间。它们还需要加载到RAM中，并且在GPU和/或CPU上需要大量的计算时间。与基于云计算的服务不同，云计算的资源只能专注于视觉问题，设备上的计算必须与其他正在运行的应用程序共享这些系统资源。最后，计算必须足够高效，以在相当短的时间内处理一个大的照片库，但没有显着的功耗或热量增加。
苹果的iCloud照片库是一个基于云的照片和视频存储解决方案。但是，由于苹果对用户隐私的强烈承诺，我们无法将iCloud服务器用于计算机视觉计算。发送到iCloud照片库的每张照片和视频在发送到云存储设备之前都会在设备上进行加密，并且只能通过注册到iCloud帐户的设备进行解密。因此，为了给我们的客户提供基于深度学习的计算机视觉解决方案，我们必须直接解决在iPhone上运行深度学习算法所面临的挑战。
我们面临着几个挑战。深度学习模式需要作为操作系统的一部分，占用宝贵的NAND存储空间。它们还需要加载到RAM中，并且在GPU和/或CPU上需要大量的计算时间。与基于云计算的服务不同，云计算的资源只能专注于视觉问题，设备上的计算必须与其他正在运行的应用程序共享这些系统资源。最后，计算必须足够高效，以在相当短的时间内处理一个大的照片库，但没有显着的功耗或热量增加。
本文的其余部分讨论了我们的基于深度学习的人脸检测的算法，以及我们如何成功地应对挑战，以实现最新的精度。我们讨论：

我们如何充分利用我们的GPU和CPU（使用BNNS和金属）
用于网络推理、图像加载和缓存的内存优化
我们如何以不妨碍iPhone预期的其他同时执行任务的方式来实现网络。

从Viola-Jones走向深度学习
在2014年，当我们开始研究深度学习方法来检测图像中的人脸时，深度卷积网络（DCN）刚刚开始在物体检测任务上产生有希望的结果。其中最突出的是一种名为“OverFeat”的方法[2]，该方法推广了一些简单的想法，这些想法表明DCN在为对象扫描图像方面非常有效。
OverFeat在一个神经网络和卷积层之间的完全连通的层之间的等价性，与输入的同样的空间维度的过滤器的有效卷积是相等的。这项工作表明，一个固定的接受领域的二元分类网络（例如32x32，自然跨度为16像素）可以有效地应用于任意大小的图像（例如，320x320），以产生适当大小的输出映射（在这个例子中是20x20）。 OverFeat文件还提供了巧妙的配方，通过有效地减少网络步幅来产生更密集的输出映射。
我们基于OverFeat论文的一些见解构建了我们的初始架构，从而形成了一个完整的卷积网络（参见图1），其中包含以下多任务目标：

二进制分类来预测输入中面部的存在与否，以及
预测边界框参数的回归，以最佳地定位输入中的面部。

我们尝试了几种培训这种网络的方法。例如，简单的训练过程是创建一个固定大小的图像块的大数据集，该图像块对应于网络的最小有效输入，使得每个块产生来自网络的单个输出。训练数据集是理想的平衡，所以一半的图块包含一个面（正类），另一半不包含面（负类）。对于每个正图块，我们提供了真正的位置（x，y，w，h）。我们训练网络来优化前面描述的多任务目标。一旦训练完毕，网络就能够预测一个图块是否包含一个人脸，如果是的话，它还提供该图块中人脸的坐标和比例。
图1.修改后的面部检测DCN体系结构

由于网络是完全卷积的，因此可以高效地处理任意大小的图像并生成2D输出图。地图上的每个点对应于输入图像中的图块，并且包含来自网络的关于该图块中是否存在人脸以及其在输入图块内的位置/比例的预测（参见图中的DCN的输入和输出1）。
给定这样一个网络，我们可以建立一个相当标准的处理流水线来执行人脸检测，包括一个多尺度图像金字塔，人脸检测器网络和一个后期处理模块。我们需要一个多尺度的金字塔来处理各种尺寸的面孔。我们将网络应用到金字塔的每个级别，并从每一层收集候选检测。 （见图2）。后处理模块然后将这些候选检测结果跨度进行组合，以产生对应于网络对图像中的脸部的最终预测的边界框的列表。
图2.人脸检测工作流程

这一策略使我们更接近于在设备上运行深度卷积网络，以彻底扫描图像。但网络复杂性和规模仍然是性能的关键瓶颈。克服这一挑战不仅意味着将网络限制在一个简单的拓扑结构中，而且还要限制网络层数，每层信道数量和卷积滤波器的内核大小。这些限制提出了一个至关重要的问题：我们生产可接受的准确性的网络不是什么简单的东西，大多数都超过20层，由几个网络中的网络模块组成。在前面描述的图像扫描框架中使用这样的网络将是完全不可行的。他们导致了不可接受的性能和用电量。事实上，我们甚至无法将网络加载到内存中。当时的挑战是如何训练一个简单而紧凑的网络，以模拟准确但复杂的网络的行为。
我们决定采用一种非正式的“师生”培训方式[4]。这种方法为我们提供了一个机制来训练第二个薄而深的网络（“学生”），使得它非常接近我们已经培训的大型复杂网络（“老师”），即如前所述的输出。学生网络由一个简单的3x3卷积和层叠重复结构组成，其架构经过精心设计，可以最好地利用我们的神经网络推断引擎。 （见图1）
现在，最后，我们有一个用于面部检测的深度神经网络的算法，对于设备上的执行是可行的。我们迭代了几轮训练，以获得足够精确的网络模型来启用所需的应用程序。虽然这个网络是准确可行的，但仍然有大量的工作要做，以便在数百万用户设备上部署。
优化图像管道
对深度学习的实际考虑因素深深地影响了我们为开发人员设计的易于使用的框架，我们称之为Vision。很明显，伟大的算法不足以创建一个伟大的框架。我们必须有一个高度优化的成像管道。
我们不希望开发人员考虑缩放，颜色转换或图像源。无论是用于实时相机捕捉流，视频处理还是从光盘或网络处理图像，人脸检测都应该运行良好。它应该工作，不管图像的表示和格式。
我们关心的是功耗和内存使用情况，尤其是流媒体和图像捕获。我们担心内存占用，比如64兆像素全景所需的大内存。我们通过使用部分二次采样解码技术和自动平铺技术来解决这些担忧，即使在非典型的高宽比下，也可以在大图像上执行计算机视觉任务。
另一个挑战是色彩空间匹配。苹果公司拥有广泛的色彩空间API，但我们不希望让开发人员承担色彩匹配任务。视觉框架处理颜色匹配，从而降低成功采用计算机视觉到任何应用程序的门槛。
Vision还通过有效处理和重复使用中间体来优化。人脸检测，人脸标志检测以及其他一些计算机视觉任务可以从相同的缩放中间图像中工作。通过将算法的接口抽象出来，找到要处理的图像或缓冲区的所有权位置，Vision可以创建和缓存中间图像，以提高多个计算机视觉任务的性能，而无需开发人员进行任何工作。
另一面也是如此。从中心接口的角度来看，我们可以将算法开发推向方向，以便更好地重用或共享中间体。 Vision承载了几种不同的，独立的计算机视觉算法。为了使各种算法能够很好地协同工作，实现使用输入分辨率和颜色空间，尽可能多的算法共享。
优化设备上的性能
如果我们的人脸检测API无法在实时应用程序和后台系统进程中使用，那么易用性的快感将很快消失。用户希望在处理照片库进行人脸识别或在拍摄后立即分析照片时，能够流畅地运行人脸检测。他们不希望电池耗尽或系统的性能缓慢爬行。苹果的移动设备是多任务设备。因此背景计算机视觉处理不应该显着地影响系统的其余部分的特征。
我们实施了几种策略来最大限度地减少内存占用和GPU使用。为了减少内存占用，我们通过分析计算图来分配神经网络的中间层。这允许我们将多个图层别名到同一个缓冲区。虽然是完全确定性的，但这种技术可以减少内存占用，而不会影响性能或分配碎片，并且可以在CPU或GPU上使用。
对于Vision，检测器运行5个网络（每个图像金字塔比例一个，如图2所示）。这5个网络共享相同的权重和参数，但其输入，输出和中间层具有不同的形状。为了进一步减少占用空间，我们在由这5个网络组成的联合图上运行基于活性的内存优化算法，大大减少了占用空间。此外，多个网络重复使用相同的权重和参数缓冲区，从而减少内存需求。
为了获得更好的性能，我们利用了网络的完全卷积性：所有的尺度都被动态调整大小以匹配输入图像的分辨率。与将图像拟合在方形网络视网膜（由空白带填充）相比，将网络适合图像的大小允许我们大大减少总操作的数量。由于操作的拓扑结构并没有因分配器其余部分的重构和高性能而改变，所以动态整形不会引入与分配有关的性能开销。
为了确保在深层神经网络在后台运行时的UI响应性和流畅性，我们为网络的每一层分割GPU工作项，直到每个单独时间少于一毫秒。这使驱动器能够及时将情境切换到更高优先级的任务，如UI动画，从而减少并有时消除丢帧。
综合起来，所有这些策略确保我们的用户可以享受本地，低延迟，私密的深度学习推断，而不必意识到他们的手机每秒钟运行数百亿次浮点运算的神经网络。
使用视觉框架
我们是否已经完成了我们设定的目标，即开发一个高性能，易于使用的人脸检测API？你可以试试Vision框架并为自己判断。以下是如何开始：
观看WWDC演示：Vision Framework: Building on Core ML.
阅读Vision Framework Reference.
在iOS 11教程中试用Core ML和Vision：机器学习。 [5]
引用文献
[1] Viola, P. and Jones, M.J. Robust Real-time Object Detection Using a Boosted Cascade of Simple Features. In Proceedings of the Computer Vision and Pattern Recognition Conference, 2001.
[2] Sermanet, Pierre, David Eigen, Xiang Zhang, Michael Mathieu, Rob Fergus, and Yann LeCun. OverFeat: Integrated Recognition, Localization and Detection Using Convolutional Networks. arXiv:1312.6229 [Cs], December, 2013.
[3] Lin, Min, Qiang Chen, and Shuicheng Yan. Network In Network. arXiv:1312.4400 [Cs], December, 2013.
[4] Romero, Adriana, Nicolas Ballas, Samira Ebrahimi Kahou, Antoine Chassang, Carlo Gatta, and Yoshua Bengio. FitNets: Hints for Thin Deep Nets. arXiv:1412.6550 [Cs], December, 2014.
[5] Tam, A. Core ML and Vision: Machine learning in iOS Tutorial. Retrieved from https://www.raywenderlich.com, September, 2017.
 



原文链接：https://machinelearning.apple.com/2017/11/16/face-detection.html
原文作者：Computer Vision Machine Learning Team


相关阅读
CNN中各层图像大小的计算

用于神经网络机器翻译的全并行文本生成

机器学习的大局：用神经网络和TensorFlow分类文本

 



此文已由作者授权云加社区发布，转载请注明原文出处

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/qcloud1001/p/8177827.html
====================================================================================================
多线程编程学习笔记——使用并发集合（一）
****************************************************************************************************
 
接上文 多线程编程学习笔记——async和await（一）
 
接上文 多线程编程学习笔记——async和await（二）
 
接上文 多线程编程学习笔记——async和await（三）
 
        编程需要对基本的数据结构和算法有所了解。程序员为并发情况 选择最合适 的数据结构，那就需要知道算法运行时间、空间复杂度等。
        对于并行计算，我们需要使用适当的数据结构，这些数据结构需要具备可伸缩性，尽可能地避免死锁，同时还能提供线程安全的访问。.Net Framework 4.0引入了System.Collections.Concurrent命名空间，其中包含了一些适合并发计算的数据结构。

ConcurrentQueue，这个集合使用了原子的比较和交换（CAS）操作，使用SpinWait来保证线程安全。它实现了一个先进先出（FIFO）的集合，就是说元素出队列的顺序与加入队列的顺序是一样的。可以调用enqueue文献向队列中加入元素，使用TryDequeue方法试图取出队列中的第一个元素，使用TryPeek方法则试图得到第一个元素但并不从队列中删除此元素。
ConCurrentStack的实现也没有使用任何锁，只采用了CAS操作。它是一个后进先出（LIFO）的集合，这意味着最近添加的元素会先返回。可以使用Push和PushRange方法添加元素，使用TryPop和TryPopRange方法获取元素，以及使用TryPeek方法检查元素。
ConcurrentBag是一个支持重复元素的无序集合。它针对这样以下情况 进行了优化，即多个线程以这样的方式工作：每个线程产生和消费自己的任务，极少与其他线程的任务交互（如果要交互则使用锁）。添加元素使用add方法，检查元素使用TryPeek方法，获取元素使用TryTake方法。
ConcurrentDictionary是一个线程安全的字典集合的实现。对于读操作无需使用锁。但是对于写操作则需要锁。这个并发字典使用多个锁，在字典桶之上实现了一个细粒度的锁模型。使用参数 concurrencyLevel可以在构造函数 中定义锁的数量，这意味着预估的线程数量将并发地更新这个字典。

         注：由于并发字典使用锁，所以没有必要请避免使用以下操作：Count、IsEmpty、Keys、Values、CopyTo及ToArray。
       5. BlockingCollection是对IProducerConsumerCollection泛型接口的实现 的一个高级封装。它有很多先进的功能来实现管道场景，即当你有一些步骤需要使用之前步骤运行的结果时。BlockingCollectione类支持如下功能：分场 、调整内部集合容量、取消集合操作、从多个块集合中获取元素。
          并行算法有可能非常复杂，并且或多或少涵盖了这些并行集合。线程安全并不是没有代价的。比起System.Collections和System.Collections.Generic命名空间中的经典列表 、集合和数组来说，并发集合会有更大的开销，因此，应该只在需要从多个任务中并发访问集合的时候才使用并发集合。在中等代码中使用并发集合没有意义，因为它们会增加无谓的开销。下面我们使用最简单的例子来学习这些并行集合。
 
一、   使用ConcurrentDictionary
     本示例展示了一个非常简单的场景，比较在单线程环境中使用通常的字典集合与使用并发字典的性能。
 1.程序示例代码，如下。

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Collections.Concurrent;
using System.Diagnostics; 

namespace ThreadCollectionDemo
{
    class Program
    {

        const string item = "Dict Name";
        public static string CurrentItem;
        static double time1;
        static void Main(string[] args)
        {
            Console.WriteLine(string.Format("-----  ConcurrentDictionary 操作----"));
            var concurrentDict = new ConcurrentDictionary<int, string>();
            var dict = new Dictionary<int, string>();
            var sw = new Stopwatch();
            sw.Start();

            //普通字典,100万次循环
            for (int i = 0; i < 1000000; i++)
            {
                lock (dict)
                {
                    dict[i] = string.Format("{0} {1}", item, i);
                }
            }

            sw.Stop();
            Console.WriteLine(string.Format("对普通字典集合(Dictionary) 进行100万次写操作共用时间：{0}----",sw.Elapsed));
            time1 = sw.Elapsed.TotalMilliseconds;
            sw.Restart();
            for (int i = 0; i < 1000000; i++)
            {
                concurrentDict[i] = string.Format("{0} {1}", item, i);          

            }

            sw.Stop();
            Console.WriteLine(string.Format("对并行字典集合(ConcurrentDictionary) 进行100万次写操作共用时间：{0}", sw.Elapsed));

            Console.WriteLine(string.Format("写操作  普通字典/并行字典 = {0}", time1/1.0/sw.Elapsed.TotalMilliseconds)); 

            Console.WriteLine();
           sw.Restart();

            for (int i = 0; i < 1000000; i++)
            {
                lock (dict)

                {
                    CurrentItem = dict[i];

                }

            }

            sw.Stop();
            Console.WriteLine(string.Format("对普通字典集合(Dictionary) 进行100万次读操作共用时间：{0}----", sw.Elapsed));
            time1 = sw.Elapsed.TotalMilliseconds;
            sw.Restart();
 

            for (int i = 0; i < 1000000; i++)

            {           
    CurrentItem= concurrentDict[i];
            }

            sw.Stop();
            Console.WriteLine(string.Format("对并行字典集合(ConcurrentDictionary) 进行100万次读操作共用时间：{0}----", sw.Elapsed));

            Console.WriteLine(string.Format("读操作  普通字典/并行字典 = {0}", time1 / 1.0 / sw.Elapsed.TotalMilliseconds));
            //多线程并行读取数据   

            sw.Restart();
            Task[] process = new Task[4];
            for (int i = 0; i < 4; i++)
            {               
                process[i ] = Task.Run(() => Get(concurrentDict, i));

            }

            Task.WhenAll(process);
            sw.Stop();
            Console.WriteLine(string.Format("多线程对并行字典集合(ConcurrentDictionary) 进行100万次读操作共用时间：{0}", sw.Elapsed));

            Console.WriteLine(string.Format("读操作  普通字典/多线程读并行字典 = {0}", time1 / 1.0 / sw.Elapsed.TotalMilliseconds));
            Console.Read();

        }

        private static void Get(ConcurrentDictionary<int,string> dict,int index)
        {
            for (int i = 0; i < 1000000; i += 4)
            {
                if (i%4==index)
                {
                    string s = dict[i];
                }             

            }   

        }
    }

}

2.单线程情况下，程序运行结果，如下图。
 
       当程序启动时我们创建了两个集合，其中一个是标准的字典集合，另一个是新的并发字典集合。然后采用锁的机制向标准的字典中添加元素，并测量完成100万次的时间。同时采用同样的场景来测量ConcurrentDictionary的性能 ，最后 比较从两个集合中获取值 的性能。
      通过上面的比较，我们发现ConcurrentDictionary写操作比使用锁的通常字典要慢的多，而读操作则要快些。因此对字典需要大量的线程安全的读操作，ConcurrentDictionary是最好的选择。
      最后，我们使用4个线程同时读ConcurrentDictionary，则会发现这个字典的性能更好。
     在main方法中添加一个四线程的读字典的代码。如下。

 //多线程并行读取数据        

            sw.Restart();
            Task[] process = new Task[4];
            for (int i = 0; i < 4; i++)
            {             

                process[i ] = Task.Run(() => Get(concurrentDict, i));
            }
            Task.WhenAll(process); 
            sw.Stop();
            Console.WriteLine(string.Format("多线程对并行字典集合(ConcurrentDictionary) 进行100万次读操作共用时间：{0}", sw.Elapsed));
            Console.WriteLine(string.Format("读操作  普通字典/多线程读并行字典 = {0}", time1 / 1.0 / sw.Elapsed.TotalMilliseconds));



  

        private static void Get(ConcurrentDictionary<int,string> dict,int index)
        {

            for (int i = 0; i < 1000000; i += 4)
            {
                if (i%4==index)
                {
                    string s = dict[i];

                }             

            }  

        }

3.多线程情况下，程序运行结果，如下图。从图中可以看出，普通字典的操作是多线程读并行字典的30多倍。这是我机器上的情况。各人的机器配置不一，请自行测试。

 
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/chillsrc/p/8177807.html
====================================================================================================
Mysql数据库重要知识点(知了堂学习心得)
****************************************************************************************************
Mysql数据库知识点
1.管理数据库语句：
使用数据库：
use test;
添加数据库：
create database 数据库名;
create database test;
修改数据库：
alter database 数据库名;
alter database test;
删除数据库：
drop database 数据库名;
drop database test;
查看所有数据库：
show databases;
 
2.管理表语句：
添加数据表：
create table 表名(
　　列名 数据类型 数据约束,
　　列名 数据类型 数据约束
);
create table student(
　　name varchar(20) not null,
　　age int(4)
)
修改数据表：
alter table 表名;
1)在表中增加新字段
alter table student add colunm name varchar(20);
2)删除表中的字段
alter table student drop name;
3)修改表中字段的类型
alter table student modify name varchar(10);
删除数据表：
drop table 表名;
drop table student;
查看所有表：
show tables;
 
3.管理数据语句：
插入数据：
insert into 表名 (列1,列2...)  values (值1,值2...);
insert into student (name,age) values ('张三',20);
更新数据：
update 表名 set 列=修改值 where 条件;
update student set  name='李四' where name='张三';
删除数据：
delete from 表名 where 条件;
delete from student where name='李四';
查询数据：
selete *  from 表名 where 条件;
selete * from student where name='张三';
 
4.各种查询语句：
查询时指定别名：
1) SELECT id AS '编号',NAME AS '姓名' FROM student;
2) SELECT id '编号',NAME '姓名' FROM student;(AS可以省略)
 
查询时合并列：
 
需求:查询每个学生的总分
 
SELECT NAME AS '姓名',(servlet+mysql) AS '总成绩' FROM student;
 
注意:合并列的字段必须是数值类型的字段
 
查询时去除重复(distinct)
 
需求:查询有哪些地区的学生
 
SELECT DISTINCT address FROM student;
 
另一种语法
 
SELECT DISTINCT(address) FROM student;
条件查询
逻辑条件: and  or
需求:查询学生的id为1，且姓名为张三的学生
SELECT * FROM student WHERE id=1 AND NAME='张三';(交集)
需求:查询学生的id为2，或姓名为张三的学生
SELECT * FROM student WHERE id=2 OR NAME='张三';(并集)
 
比较条件: >  <  >=  <=  =  <>  (between and--在...之间 包前包后)
 
需求:查询servlet分数大于80分的学生
 
SELECT * FROM student WHERE servlet>80;
 
需求:查询mysql分数小于或等于85分的学生
 
SELECT * FROM student WHERE mysql<=85;
 
需求:查询servlet分数大于或等于80分，且小于或等于85分的学生
 
SELECT * FROM student WHERE servlet>=80 AND servlet<=85;
 
代替上面语句的语法
 
SELECT * FROM student WHERE servlet BETWEEN 80 AND 85;
 
需求:查询年龄不等于30的学生
 
SELECT * FROM student WHERE age<>30;
判空条件: is null,   is not null,   =’’,   <>’’
Null:表示没有数据
空字符:表示有数据
需求:查询没有性别数据的学生(数据‘男’或‘女’)
SELECT * FROM student WHERE gender IS NULL OR gender='';
需求:查询有性别数据的学生
SELECT * FROM student WHERE gender IS NOT NULL AND gender<>'';
模糊条件: like
模糊替代符号:
%:替代任意个字符
_:替代一个字符
需求:查询姓“李”的学生
SELECT * FROM student WHERE NAME LIKE '李%';
需求:查询姓名中包含‘四’字的学生
SELECT * FROM student WHERE NAME LIKE '%四%';
需求:查询姓‘李’，全名只有两个字的学生
SELECT * FROM student WHERE NAME LIKE '李_';
 
聚合函数查询(用于统计结果)
 
Max()取最大值  min()取最小值  avg()取平均值  count()统计标的记录数量 sum()求和
 
需求:查询servlet的最高分
 
SELECT MAX(servlet) FROM student;
 
需求:查询mysql的最低分
 
SELECT MIN(mysql) FROM student;
 
需求:查询servlet的平均分 
 
SELECT AVG(servlet) FROM student;
 
需求:查询当前有几个学生
 
SELECT COUNT(*) FROM student;
 
需求:查询servlet成绩的总和
 
SELETE SUM(servlet) from student;
分页查询(limit)
Limit起始行数，查询的行数
起始行数从0开始
需求:查询第1,2条数据
SELECT * FROM student LIMIT 0,2;
分页查询需知道:当前页码，每页显示条数
结论分页查询当前页数据:select * from student limit (当前页码-1)*每页显示条数，每页显示条数;
需求:学生共20条数据，每页显示5条，共4页
查询第3页(第11到15条)的学生数据:select * from student limit 10,5;
 
查询后排序(order by)
 
 
Desc:降序。数值从大到小，字母z-a
 
Asc:升序。数值从小到大，字母a-z 
 
默认情况下，按照插入的顺序排序
 
需求:按照id的升序排序
 
Select * from student order by id asc;
 
需求:按照servlet成绩降序排序
 
Select * from student order by servlet desc;
 
多个排序条件的情况:先按照前面的条件排序，当出现重复记录，再按照后面的条件排序
 
需求:按照age升序，再按照servlet成绩升序排序
 
Select * from student order by age asc,servlet asc;
分组查询(group by)
需求:查询每个地区有多少人
SELECT address,COUNT(*) FROM student GROUP BY address;
需求:统计男女的人数
注意:where条件必须放在group by 分组之前
SELECT gender,COUNT(*) FROM student WHERE gender IS NOT NULL AND gender<>'' GROUP BY gender;
分组后筛选(having)
需求:查询哪些地区的人数是大于2个的地区
查询哪些地区多少人 2)筛选人数大于2的地区
注意:having使用在group by分组之后，对分组后的条件进行筛选
SELECT address,COUNT(*) FROM student GROUP BY address HAVING COUNT(*)>2;
 
5.数据约束（给表添加数据约束，从而约束用户操作表数据的行为）
 
1）默认值约束(default)
create table test(
name varchar(20),
gender varchar(20) default ‘男’
)
需求:当不插入gender的时候，分配一个‘男’的默认值
注意:1)当没有插入gender字段的时候，分配一个默认值
 
2）非空约束（not null）
 
 
 
 
 
create table test(
 
name varchar(20) not null,
 
gender varchar(20)
 
)
 
需求；name字段一定要有值(不能不插入数据，不能是null)，这是给name添加非空约束
 
1)非空约束，不能不插入值
 
Insert into test(gender) values(‘男’);
 
2)非空约束，不能插入null
 
Insert into test(name,gender) values(null,’男’);
3)唯一约束(unique)
create table test(
Id int unique,
name varchar(20)
)
需求:id的值不能出现重复。这时就要给id添加一个唯一约束
1)不能插入重复的值
2)唯一约束，可以插入多个null。所以唯一约束不能约束null
Insert into test(id,name) values(1,’张三’);
4)主键约束(primary key)(唯一+非空)
 
注意；
 
1)通常情况下，我们会给每张表都设置一个主键字段，用来标记记录的唯一性
 
2)但是不建议把业务含义字段作为主键，因为随着业务的变化，业务字段可能出现重复
 
3)建议给每张表都独立添加一个叫id的字段，把这个id字段设置成主键，用来作为记录的唯一性
 
create table test(
 
Id int primary key,
 
name varchar(20)
 
)
 
1)唯一性
 
2)非空性
5)自增长约束(auto_increment)
create table test(
Id int primary key auto_increment,
name varchar(20)
)
自增长约束:初始值为0，每次递增1
使用truncate table 删除数据的时候，可以把自增长的初始值置为0
 
6)外键约束
//员工表(副表:被别的表约束的表，外键设置在副表)
Create table employee(
Id int primary key auto_increment,
name varchar(20),
deptId int,
添加外键约束(foreign key)
Constraint employee_dept_fk foreign key(deptId) references dept(id)
           外键名                 外键字段  参考
)
//部门表(主表:约束别人的表)
Create table dept(
Id int primary key auto_increment,
Name varchar(20)
)
外键约束在什么情况下会起作用？
插入数据:当往副表插入了主表中不存在的数据时，外键起作用
修改数据:当往副表中修改主表中不存在的数据时，外键起作用
删除数据:副表中有关联主表数据的情况下，当删除主表数据时，外键起作用
 
当有了外键之后，应该如何管理数据呢？
插入数据:先插入主表的数据，再插入副表数据
修改数据:先修改主表数据，再修改副表数据
删除数据:先删除副表数据，再删除主表数据
 
7)级联技术(cascade)
级联:当有了外键的时候，我们希望修改或删除数据的时候，修改或删除主表数据时，同时能够影响副表的数据，这时就可以使用级联
Create table employee(
Id int primary key auto_increment,
name varchar(20),
deptId int,
添加外键约束(foreign key)
添加级联修改:on update cascade
添加级联修改:on delete cascade
Constraint employee_dept_fk foreign key(deptId) references dept(id) on update cascade on delete cascade
           外键名                 外键字段  参考
);
//部门表(主表:约束别人的表)
Create table dept(
Id int primary key auto_increment,
Name varchar(20)
);
 
 
6.数据库设计的三大范式
第一范式；要求表的每个字段必须独立的不可分割的单元
学生表: student    name          ---违反第一范式
               张三|狗娃
王涵|张小涵
查询:现用名中包含‘张’的学生
Select * from student where name like ‘%张%’;
 
学生表: student    name     old_name       ---符合第一范式
                  张三       狗娃
王涵        张小涵
 
 
第二范式:在第一范式的基础上，要求表的除主键以外的字段都和主键有依赖关系
 
一张表只表达一个意思
 
员工表:employee
 
员工编号   员工姓名   部门名称    订单名称   ---违反第二范式
 
 
 
员工表:employee
 
员工编号   员工姓名   部门名称     ---符合第二范式
 
            订单表:
 
            订单编号   订单名称
 
 
第三范式:在第二范式的基础上，要求表的除主键以外的字段都只能和主键有直接决定的依赖关系
 
员工表:employee
 
员工编号   员工姓名  部门编号  部门名称 ---违反第三范式(出现数据冗余)
 
               1        张三       1        软件开发部
 
               2        李四       1        软件开发部
 
员工表:employee
 
员工编号   员工姓名  部门编号   ---符合第三范式
 
 1        张三       1 
 
 2        李四       1
 
部门表:dept
 
部门编号   部门名称
 
1          软件开发部
 
8)多表查询
1.交叉连接查询(笛卡尔乘积:4*3=12，产生笛卡尔积的原因是没有足够的连接条件)(一般不用)
需求:查询员工及其部门名称
SELECT employee.name,dept.name
FROM employee,dept;
2.内连接查询(使用最多)
多表查询的步骤:1)确定查询哪些表
               2)确定查询哪些字段
               3)确定连接条件(规则:条件=表数量-1)
SELECT employee.name,dept.name
FROM employee,dept
WHERE employee.deptId=dept.id;
另一种语法
SELECT e.name,d.name
FROM employee e
INNER JOIN dept d
ON e.deptId=d.id;
3.左外连接查询(左表数据全部显示，如果右边不满足，则显示null)
需求:查询部门及其部门的员工
SELECT d.name,e.name
FROM dept d
LEFT OUTER JOIN employee e
ON d.id=e.deptId;
4.右外连接查询(右表数据全部显示，如果左边不满足，则显示null)
SELECT d.name,e.name
FROM employee e
RIGHT OUTER JOIN dept d
ON e.deptId=d.id;
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/yangyangfubin/p/8179172.html
====================================================================================================
vue-router项目实战总结
****************************************************************************************************
今天来谈谈vue项目{vue,vue-router,component}三大神将之一的vue-router。作为我们前后端分离很重要的实践之一，router帮我们完成了SPA应用间的页面跳转。
并且，配合axios这样的第三方库，我们可以实现配合后台接口的拦截器功能。
 
对于一个小型项目而言,router这个文件夹里面就包含了一个router.js就足够了，
但是，当我们的页面比较多的时候，我们就需要分出两个文件出来：一个定义我们的路由和组件，另一个实例化组件，并将路由挂载到vue的实例上。
基本的用法就不多赘述，大家可以看vue-router的官网，认真过一遍的话，基本使用肯定没什么问题。
1.为什么我的路由不起作用?
这里有个非常重要的一点就是当我们去构造VueRouter的实例的时候，传入的参数的问题。

import routes from '@/router/router'

const router = new VueRouter({
  routes // （ES6语法）相当于 routes: routes
})

new Vue({
  router
}).$mount('#app')

如果你这里引入的不是routes，你就要按照下面的方式来写。

import vRoutes from '@/router/router'

const router = new VueRouter({
  routes :vRoutes 
})

new Vue({
  router
}).$mount('#app')

 
2.在路由中基于webpack实现组件的懒加载
对于我们的vue项目，我们基本都是运用webpack打包的，如果没有懒加载，打包后的文件将会异常的大，造成首页白屏，延时严重，不利于用户体验，而运用懒加载则可以将页面进行划分，webpack将不同组件打包成很多个小的js文件。需要的时候再异步加载，优化用户的体验，换而言之，有的页面可能100个用户只有一两个会进去，何必把流量花在它身上。

import App from '@/App.vue'

const index = r  => require.ensure([], () => r(require('@/pages/index/index')), 'index')

export default [{
  path: '/',
  component: App,
  children: [
    {
       path: '/index',
       name:'index',
       component: index
    }]
}]

 如果某个组件包含了嵌套路由，我们也可以将两个路由打包到一个js chunk中。

// 这两条路由被打包在相同的块中，访问任一路由都会延迟加载该路由组件
const orderUser= r => require.ensure([], () => r(require('@/pages/order/user')), 'order')
const payRecord= r => require.ensure([], () => r(require('@/pages/order/payRecord')), 'order')

3.router的模式
对于浏览器，我们的router分为两种模式。
1.hash模式（默认）
按照一个uri的基本结构来说，hash模式就是在一个基本的URI的片段进行的处理。如果抛开SPA的话，比较常见的应用场景就是我们在做pc商城的时候，会有比如说：商品详情，评论，商品参数这样的tab切换，就可以使用a标签配合id使用，加上一点运动的特效，效果甚佳。

这也是router默认使用的路由方式。不过，这种方式有一个弊端，就是在接入第三方的支付的时候，我们传入一个url给到第三方支付作为回调地址，但是在支付完成以后，有的第三方支付会把我们的#作为一个截取符号，仅保留第一个#符号前面的url内容，后面再添加相应的回调参数。导致支付完成以后无法跳转到相应的支付页面

传入的url:
http://xx.xx.com/#/pay/123
回调后的地址:
http://xx.xx.com/pay/123?data=xxxxx%xxxx

 
2.history模式
还有一种就是history的模式。它是使用h5的history.pushState来完成URL的跳转的。使用这种方式来处理跳转的好处就是，url和我们平常看到的没有什么区别。和hash模式作比较的话就是没有了#。不过使用history模式，我们在后台也要去做相应的处理，因为如果直接去访问一个地址，例如http://www.xxxx.com/user/id的时候，如果后端没有配置的时候，后端就会返回404页面。
4.router-link在循环中this.参数名=undefined
<router-link>组件是我们在view层中需要用到的跳转组件。它替代了<a>标签需要做的事情，并且帮助我们做了更多的事情。


无论是 h5 history 模式还是 hash 模式，它的表现行为一致，所以，当你要切换路由模式，或者在 IE9 降级使用 hash 模式，无须任何变动。


在 HTML5 history 模式下，router-link 会守卫点击事件，让浏览器不再重新加载页面。


当你在 HTML5 history 模式下使用 base 选项之后，所有的 to 属性都不需要写（基路径）了。


不过当我们在v-for的循环中使用了router-link的时候，一般来说，我们需要取的都是循环里的值，通过定义的item.xxx就可以取到。如果说需要取一个我们在data中定义的值的时候，我们是通过this.foo来取呢？还是通过foo来取呢？还是都可以？
这里的话，我们是不能通过this.foo来取的，因为这里的this,不再是指向vue的实例了，而是指向了[object Window]。所以用this.foo来取的话，其实是undefined.

 <router-link tag="li" :to="{path:`/user/${item.userID}`}" v-for="(item, index) in userList" :key="index">
     //含有固定的值
    <p>{{this.foo}}</p>    <p>{{foo}}</p>
 </router-link>


data(){
    return {
        foo:'bar',
    }  
}

 4.vue-router配合axios的使用
 初次接触拦截器这个概念是在java中，通过拦截器，我们可以对用户的登录状态进行更加粒度的操作。而对于一个SPA的应用来说，没有了后台路由的介入，我们就需要在前端实现一套自己的登录状态的管理机制。
最直观的一点就是，通过用户的token来判断用户是否登录？

router.beforeEach((to, from, next) => {
  const NOW = new Date().getTime();
  if (to.matched.some(r => r.meta.requireAuth)) {
    if(NOW > store.state.deadLine){
      store.commit('CLEAR_USERTOKEN')
    }
    if (store.state.message.login === true) {
      next();
    }
    else {
      next({
        path: '/login',
        query: {redirect: to.fullPath}
      })
    }
  }
  else {
    next();
  }
})

上面的代码中，我们通过vue-router中的全局守卫，在导航触发的时候大致做了如下几件事：
（1）判断导航的页面是否需要登录
（2）超过登录持久期限，清除持久化的登录用户token
（3）没有超过登录期限，判断是否登录状态
（4）没登录，重定向到登录页面
但是，仅仅这样是不够的。因为用户直接不正常注销而直接后台运行网页是很正常的事情，这就导致虽然token是存在的，但是对于后台而言，这个token是无效的，过期的了。所以，我们需要axios配合后台给出的状态码来完善我们的拦截器。

import router from '@/router/routes'

axios.interceptors.response.use(
  success => {
    switch (success .code) {
      case -100:
        router.replace({
          path: 'login',
          query: {redirect: router.currentRoute.fullPath}
        })
        console.warn('注意,登录已过期!')
        break;
    }
    return success;
  },
  error => {
      switch (error.code) {
        case 404:
          console.warn('请求地址有误或者参数错误!')
        break;
      }
    return Promise.reject(error.response.data)
  });

 通过后端给到的登录过期状态码，这里以-100为例，我们可以用axios的响应拦截器实现，当我们的token过期的时候，我们将页面重定向到登录页面去。
 5.巧用replace替换push
在项目中，我有的同事就是一直this.$router.push(...)，从开始push到结尾。
碰到有的页面，比如说，在选择地址的时候需要知道用户当前所在的城市，如果没有的话，就是重定向到城市列表页面去手动选取。选择完成以后再回到选择地址的页面，如果一直使用push的话，点击选择地址的后退时，就会回退到城市列表页。然后造成页面间的死循环。
这里如果使用replace来操作就没有什么问题了，问题就是我们不应该让城市列表页出现在我们的浏览历史里面。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/ChengWuyi/p/8127490.html
====================================================================================================
HashMap 之弱引用 - WeakHashMap
****************************************************************************************************
■ Java 引用的相关知识
　 1. 强引用

Object o = new Object(); 


强引用是Java 默认实现 的引用，JVM会尽可能长时间的保留强引用的存在（直到内存溢出）
当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题：只有当没有任何对象指向它时JVM将会回收

　2. 软引用

public class SoftReference<T> extends Reference<T> {...} 


软引用只会在虚拟机 内存不足 的时候才会被回收
软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收器回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中

   3. 弱引用

public class WeakReference<T> extends Reference<T> {...} 


弱引用是指当对象没有任何的强引用存在，在 下次GC回收 的时候它将会被回收
在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存
需要注意的是：由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象

 
■ WeakHashMap 的认识：

WeakHashMap 是存储键值对(key-value)的非同步且无序的散列表，键和值都允许为null，基本跟 HashMap一致
特殊之处在于 WeakHashMap 里的entry可能会被GC自动删除，即使没有主动调用 remove() 或者 clear() 方法
其键为弱键，除了自身有对key的引用外，此key没有其他引用那么此map会自动丢弃此值
在《Effective Java》一书中第六条，消除陈旧对象时，提到了weakHashMap，用于短时间内就过期的缓存
由于与JDK1.7版本的HashMap实现原理一致（具体请参见笔者的 HashMap一文通），这里只讨论不同
若有机会写JVM篇的垃圾回收机制时会再进一步描述 Reference

   1. 类定义

public class WeakHashMap<K,V>
    extends AbstractMap<K,V>
    implements Map<K,V>

  2. 重要的全局变量

/**
  * The default initial capacity -- MUST be a power of two.
  * 默认容量，必须是2次幂
  */
private static final int DEFAULT_INITIAL_CAPACITY = 16;
/**
  * The maximum capacity, used if a higher value is implicitly specified by either of the
  * constructors with arguments. MUST be a power of two <= 1<<30.
  * 最大容量，必须为2次幂且 <= 1<<30
  */
private static final int MAXIMUM_CAPACITY = 1 << 30;
/**
  * The load factor used when none specified in constructor.
  * 负载因子
  */
private static final float DEFAULT_LOAD_FACTOR = 0.75f;
/**
  * The table, resized as necessary. Length MUST Always be a power of two.
  * 容量必须为2次幂的数组
  */
Entry<K,V>[] table;
/**
  * The number of key-value mappings contained in this weak hash map.
  * 拥有键值对的数量
  */
private int size;
/**
  * The next size value at which to resize (capacity * load factor).
  * 阈值 -- 扩容判断依据
  */
private int threshold;
/**
  * The load factor for the hash table.
  */
private final float loadFactor;
/**
  * Reference queue for cleared WeakEntries
  * 引用队列，用于存储已被GC清除的WeakEntries
  */
private final ReferenceQueue<Object> queue = new ReferenceQueue<>();

  3. 构造器

// 默认构造函数
WeakHashMap()
// 指定"容量大小"的构造函数
WeakHashMap(int capacity)
// 指定"容量大小"和"负载因子"的构造函数
WeakHashMap(int capacity, float loadFactor)
// 包含"子Map"的构造函数
WeakHashMap(Map<? extends K, ? extends V> map)


实现跟JDK1.7版本HashMap的实现一致,具体请参见笔者的  HashMap - 基于哈希表和 Map 接口的键值对利器 （JDK 1.7）

 4. Entry

/**
  * The entries in this hash table extend WeakReference, using its main ref field as the key.
  * 该Enty继承WeakReference，从而具备弱引用的特性
  */
private static class Entry<K,V> extends WeakReference<Object> implements Map.Entry<K,V> {
    V value;
    int hash;
    Entry<K,V> next;//链表
    /**
      * Creates new entry.
      */
    Entry(Object key, V value,
            ReferenceQueue<Object> queue,
            int hash, Entry<K,V> next) {
        super(key, queue);
        this.value = value;
        this.hash  = hash;
        this.next  = next;
    }
    ....
}  

■ WeakHashMap 的重要方法

常规 put(), get(), remove() 等不详细研究，来看下比较关键的 expungeStaleEntries()


/**
  * Expunges stale entries from the table. -- 删除过时的entry
  * 该方法是实现弱键回收的最关键方法，也是区分HashMap的根本方法
  * 核心：移除table和queue的并集元素（queue中存储是已被GC的key，注意是key！！）
  * 效果：key在GC的时候被清除，value在key清除后访问WeakHashMap被清除
  */
private void expungeStaleEntries() {
    //从队列中出队遍历
    //poll 移除并返问队列头部的元素；如果队列为空，则返回null
    for (Object x; (x = queue.poll()) != null; ) {
        synchronized (queue) {
            //值得一提的是WeakHashMap是非线程安全的，这里却同步了一下
            //大神原本的用意是保证在多线程时能不破坏数据结构，但JavaDoc已经强调这类非安全，如下文
            //http://bugs.java.com/bugdatabase/view_bug.do?bug_id=6425537
            @SuppressWarnings("unchecked")
                Entry<K,V> e = (Entry<K,V>) x;
            //找到该队列中的元素在数组中的位置，并移除该元素（table和queue都需要移除）    
            int i = indexFor(e.hash, table.length);
            Entry<K,V> prev = table[i];
            Entry<K,V> p = prev;
            while (p != null) {
                Entry<K,V> next = p.next;
                if (p == e) {
                    if (prev == e)
                        table[i] = next;
                    else
                        prev.next = next;
                    // Must not null out e.next;
                    // stale entries may be in use by a HashIterator
                    e.value = null; // Help GC 移除value
                    size--;
                    break;
                }
                prev = p;
                p = next;
            }
        }
    }
}

 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/romanjoy/p/8178071.html
====================================================================================================
iOS网络模块优化（失败重发、缓存请求有网发送）
****************************************************************************************************
　　iOS开发中，一般都是通过AFN搭建一个简易的网络模块来进行与服务器的通信，这一模块要优化好没那么简单，需要花费很多时间与精力，仅仅根据这几年来的填坑经验，总结下这一块的需要注意的地方，也是给自己梳理下知识。
　　之前写的博客提到了DNS优化、请求数据大小的优化(http://www.cnblogs.com/ziyi--caolu/p/8058577.html)。这里主要想理一理合理的并发数以及网络请求可靠性的保障。
　　优化的理论之前，先建立代码样例，假设我们有这样两个类：　　

@interface ZYRequest : NSObject<NSCopying>

@end

@interface ZYRequestManager : NSObject

@end


 　　ZYRequest类用来处理公共的逻辑，Manager负责管理Request。在iOS开发中，很多时候会遇到多个Request集中发送的情况，比如说第一次进入App首页，需要请求骨架文件、首页Banner图片、展示Cell数据等等，如果这时候并发数太少，那些需要优先展示的数据请求可能会被次要的数据请求“阻塞”住。如果并发数太大，带宽有限的场景下，会增加请求的整体延迟。一般而言，在实际开发中，让请求的并发数限制在3~~5即可（也可以给每个请求设计优先级，然后在调度队列里面让优先级高的请求先出队列）。
　　请求的可靠性保障是个很容易被忽视的问题，见过的很多App的网络请求都是只进行一次请求，失败后直接给用户提示网络错误。比较好的做法，是将Request按业务分类：
　　　　第一类，关键核心业务，期望在任何条件下能百分百送达服务器。
　　　　第二类，重要的内容请求、数据展示，需要较高的成功率。
　　　　第三类，一般性内容请求，对成功率无要求。
　　理论上来说，需要我们应该尽量让每个请求的成功率都达到最高，但是客户端流量、带宽、电量、服务器压力等都是有限的资源，所以只能采取将关键性请求做高强度的可靠性保证。
　　　　
　　　　代码Github地址：https://github.com/wzpziyi1/iOSNetwork
　　　　
　　一、代码结构分析

　　　　其中Storage文件夹里面，主要是处理将NSData数据缓存到沙盒的，实际我将它们的调用封装在ZYRequestCache文件里面，关于数据存储到沙盒、数据库，从沙盒取出数据、从数据库取出数据，删除、查询等等所有操作，都是封装在ZYRequestCache里面，直接调用它的接口即可。
　　　　数据库采用的是realm数据库，并且实现了在子线程进行数据的存取，不占用主线程的资源，以免造成卡顿。由于是第一次使用realm，踩了很多坑。所有的关于数据库的操作，都封装在ZYRequestRealm文件里面，里面也有许多操作realm时踩过的坑的提示，最需要注意的一点是，在realm数据库的使用中，对同一份数据的读、写、查询后使用，都必须是在同一线程，在编码时由于将除查询操作外的其他数据库操作放在子线程中，造成了各种线程错误的崩溃。
　　　　YQDHttpClinetCore文件是基于AFN的封装，在里面设置了超时时间为5s，主要是因为我设置的重发请求次数是3次，那么真正交互的超时时间会是15s，如果有需要可以自行进行调整。
　　　　ZYRequest文件里面是所有发送一次请求所需要的数据，例如url\params\method\type等。
　　　　ZYRequestManager文件里面是进行request调度的主题逻辑，也没有进行复杂的算法，不按照优先级别，只是一个先入先出队列来进行调用的。里面有两个dispatch_queue:

//这个串行队列用来控制任务有序的执行
@property (nonatomic, strong) dispatch_queue_t taskQueue;

//添加、删除队列，维护添加与删除request在同一个线程
@property (nonatomic, strong) dispatch_queue_t addDelQueue;


　　　　taskQueue主要是用来处理调度队列的，也就是requestQueue，让它在子线程进行循环查询、处理request，然后再并发进行网络请求，这样可以防止请求很多的情况下，卡住主线程。
　　　　addDelQeueu主要是用来处理requestQueue里面的requset增加与删除的。在添加和删除的时候，采用的方案都是串行+同步，主要是避免数据竞争。（因为在AFN发送request要删除requestQueue里面的request的时候，是并发状态）
　　　　在处理最大并发数的时候，我使用的是dispatch_semaphore_t（信号量），设置最大并发数是4。
　　　　逻辑并不复杂，需要注意的是，如何避免数据竞争，如何尽可能的不消耗主线程资源。 
 
　　二、针对百分百送达服务器的请求　　
　　　　根据业务来说，这类请求应用的地方很多。类似于我们发微信发消息时，消息数据一旦从数据框中发出，从用户的角度感知这条消息是一定会到达对方的;在小说阅读App的书架收藏功能，理论上来说户收藏一本书时，在用户感知角度，这本书一定会被收藏进入书架的等业务。如果网络环境差，网络模块会在后台悄悄重试，一段时间仍然无法成功的话，就直接通知用户发送失败了，但是即使失败，请求数据也会保存在本地，以便用户重新触发此条请求数据的发送。
　　　　对于这类请求的处理，第一步并不是直接发送，而是存入本地数据库中，一旦存入了数据库，即使是杀掉进程、断电、重启等极端操作，请求数据也依旧存在，我们只需要在App重启或者进入该业务界面时，还原请求数据到内存中，重新进行发送即可。代码阐释：
　　　　

#import <Foundation/Foundation.h>
#import "ZYRequestMacro.h"
#import <Realm/Realm.h>



typedef NS_ENUM(NSInteger, ZYRequestReliability){

    //如果没有发送成功，就放入调度队列再次发送
    ZYRequestReliabilityRetry,
    
    //必须要成功的请求，如果不成功就存入DB，然后在网络好的情况下继续发送，类似微信发消息
    //需要注意的是，这类请求不需要回调的
    //类似于发微信成功与否
    //就是必定成功的请求，只需要在有网的状态下，必定成功
    ZYRequestReliabilityStoreToDB,
    
    //普通请求，成不成功不影响业务，不需要重新发送
    //类似统计、后台拉取本地已有的配置之类的请求
    ZYRequestReliabilityNormal
};


@interface ZYRequest : RLMObject<NSCopying>

//存入数据库的唯一标示
@property (nonatomic, assign) int requestId;

/**请求参数对*/
@property (nonatomic, strong) NSDictionary *params;


/**
 请求的url
 */
@property (nonatomic, copy) NSString *urlStr;

/**
 请求重复策略，默认重发
 */
@property (nonatomic, assign) ZYRequestReliability reliability;

/**
 请求方法，默认get请求
 */
@property (nonatomic, assign) YQDRequestType method;


/**
 是否需要缓存响应的数据，如果cacheKey为nil，就不会缓存响应的数据
 */
@property (nonatomic, copy) NSString *cacheKey;

/**
 请求没发送成功，重新发送的次数
 */
@property (nonatomic, assign, readonly) int retryCount;


/**
 realm不支持NSDictionary，所以params直接转化为字符串存储
 只在请求需要存入数据库中，此参数才有相应的作用
 ZYRequestReliabilityStoreToDB这种类型下
 */
@property (nonatomic, copy, readonly) NSString *paramStr;


- (void)reduceRetryCount;
@end


 　　　　第一类请求就是ZYRequestReliabilityStoreToDB，requestId是它存入数据库的唯一标示，下面是请求的发送流程：
　　　　

- (void)sendRequest:(ZYRequest *)request successBlock:(SuccessBlock)successBlock failureBlock:(FailedBlock)failedBlock
{
    //如果是ZYRequestReliabilityStoreToDB类型
    //第一时间先存储到数据库，然后再发送该请求，如果成功再从数据库中移除
    //不成功再出发某机制从数据库中取出重新发送
    if (request.reliability == ZYRequestReliabilityStoreToDB)
    {
        [[ZYRequestCache sharedInstance] saveRequestToRealm:request];
    }
    
    [self queueAddRequest:request successBlock:successBlock failureBlock:failedBlock];
    [self dealRequestQueue];
}


//在成功的时候移除realm数据库中的缓存
 if (request.reliability == ZYRequestReliabilityStoreToDB)
{
    [[ZYRequestCache sharedInstance] deleteRequestFromRealmWithRequestId:request.requestId];
}

//请求失败之后，根据约定的错误码判断是否需要再次请求
                //这里，-1001是AFN的超时error
 if (error.code == -1001 &&request.retryCount > 0)
{
    [request reduceRetryCount];
    [self queueAddRequest:request successBlock:successBlock failureBlock:failedBlock];
    [self dealRequestQueue];
}
else  //处理错误信息
{
    failedBlock(error);
}


 　　　　如果是ZYRequestReliabilityStoreToDB请求，第一步是存入数据库。
　　　　第二步，将请求添加到调度队列里面，让调度队列调用AFN去处理该请求。在AFN的成功block里面，判断状态码，如果是真的成功状态，那么将数据库里面的请求移除掉，如果是失败状态，将重新请求的次数递减，再添加到调度队列末尾重新排队请求。
　　　　我设计的是，最多重发三次请求。另外还有一个定时器，这个定时器会每隔60s，从数据库查询需要所有存储的请求，然后将它们尝试加入调度队列再次发送。这样的设计，即使App被kill，再次重启60s之后，也会把数据库中的请求拿出来进行发送。（只是一种思路，实际开发中会进入到具体业务才讲请求拿出来发送）
　　　　通过上面的几个步骤，基本上可以极大的提高请求的可靠性，但是真的100%是无法实现的，如果用户卸载App，再下载，相关数据就无法恢复了。
 
　　三、失败重发
　　　　第二类请求的可靠性为ZYRequestReliabilityRetry，这类请求的例子可以是我们App启动时用户看到的首页，首页的内容从服务器获取，如果第一次请求就失败体验较差，这种场景下我们应该允许请求有机会多试几次，增加一个retryCount即可。

/**
 请求没发送成功，重新发送的次数
 */
@property (nonatomic, assign, readonly) int retryCount;


 　　　　在Manager里面，有一个调度队列：

@property (nonatomic, strong) NSMutableArray *requestQueue;


 　　　　每次将请求加入这个队列，然后在AFN发送完成回调之后，如果失败就进行重发，实际开发时，需要自行处理失败重发的错误码判断：

//请求失败之后，根据约定的错误码判断是否需要再次请求
//这里，-1001是AFN的超时error
if (error.code == -1001 &&request.retryCount > 0)
{
    [request reduceRetryCount];
    [self queueAddRequest:request successBlock:successBlock failureBlock:failedBlock];
    [self dealRequestQueue];
}


 　　　　在这里，是设置如果超时才进行重发请求，也可以将这个判断去掉，只要retryCount大于0即进行重发。一般开发的时候会和后台确定一些错误码，根据错误码的类型判断是否需要重发会更合理些。
　　　　一般3次的重试基本可以排除网络抖动的情况。三次失败之后即可认为请求失败，通过产品交互告知用户。
　　　　第三类请求的重要性最低，比如进入Controller的UV采集打点、收集数据等。这类请求只需要做一次，即使失败也不会对App体验产生什么负面影响。
 
　　四、设计思路
　　　　这是某天在开发群里群友发出来的一道面试题，当一个复杂界面上的数据要根据n个请求返回的数据进行更新的时候，要求设计一个架构来发送这些请求。
　　　　当时简单的和群友聊了聊，趁着最近有时间就自己撸了一套这样的机制，首先是疑问：
　　　　1、为什么需要设计框架？所有请求直接利用AFN并发发送不行么？（不行，因为网络带宽是有限的，这样做会导致数据返回整体慢上很多，而且，一个网络请求的超时时间是一定的，一次性并发很可能造成本来可以发送成功的请求超时）
　　　　2、基于问题1，架构如何设计？（个人认为，面试官主要是想考察对平时写代码对于封装、设计模式、网络回调的理解，如果仅仅只是一个最大并发的限制，明显不会是理想答案，那么需要注意的点？除开最大并发，开发中网络错误时，都有错误码返回，对这一块应该做好处理。当请求失败时，需不需要进行重发？请求之间需不需要设置依赖？需要不要有优先级等等）
 
　　　　这一次的设计，并没有依赖、优先级等，只进行了重发、最大并发设计。思路是一样的，无非就是一个调度队列进行request的处理，这个队列的出队规则可以是按优先级高低来进行，当然得自己封装优先队列的算法。这里是最简单的先进先出队列，每次请求失败，要进行重发的话，就把请求丢到队列末尾。额，理论上来说，请求无限多的情况下，调度队列会是个死循环，这样会造成主线程卡顿，所以把它放到子线程来处理。在并发发送请求之下，不做处理的话，会并发的删除调度队列里面的request，那么如何避免数据竞争？在代码里面都有解答，以上。
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/ziyi--caolu/p/8176331.html
====================================================================================================
iOS学习——iOS常用的存储方式
****************************************************************************************************
　　不管是在iOS还是Android开发过程中，我们都经常性地需要存储一些状态和数据，比如用户对于App的相关设置、需要在本地缓存的数据等等。根据要存储的的数据的大小、存储性质以及存储类型，在iOS和Android中哪个都有多种存储方式。其中，iOS中的存储方式主要包括以下六类：

plist文件（属性列表）
preference（偏好设置）
NSKeyedArchiver（归档）
SQLite 3
CoreData
手动存放沙盒

一、沙盒机制
　　在研究存储方式之前，我们有必要先研究下这些文件会存储到什么地方去，这就需要我们了解iOS App特有的沙盒机制了。iOS程序默认情况下只能访问程序自己的目录，这个目录被称为“沙盒”，即沙盒其实就是一个App特有的一个文件夹，iOS下每个App都有自己特有的一个沙盒，其结构和目录特性都是一样的。
1.1 沙盒结构
　　既然沙盒就是一个文件夹，那就看看里面有什么吧。沙盒的目录结构如下图所示，每个App的沙盒都是由下图所示的四部分组成，每一部分中存放的数据和内容都是有一定的规范和性质的。该目录路径的获取方法是直接通过 NSHomeDirectory() 就得到和应用沙盒的路径。

　　此外，每一个App还有一个Bundle目录，即“应用程序包”，该目录下 存放的是应用程序的源文件，包括资源文件和可执行文件。
1.2 沙盒目录特性
　　虽然沙盒中有这么多文件夹，但是没有文件夹都不尽相同，都有各自的特性。所以在选择存放目录时，一定要认真选择适合的目录。

应用程序包：存放的是应用程序的源文件，包括资源文件和可执行文件。如果你要仿写某一个App或借用某个App的应用图标，可以在该App的应用程序包中找到其.app结尾的源文件，然后显示报内容即可直接获取到其所有的图标和应用切图。在开发中获取其bundle（应用程序包）路径的方法是：

NSString *path = [[NSBundle mainBundle] bundlePath];
NSLog(@"%@", path);


Documents: 最常用的目录，iTunes同步该应用时会同步此文件夹中的内容，适合存储重要数据。如果自己存储log数据到本地，一般是保存到该路径下。获取路径下的方法是：

NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSLog(@"%@", path);


Library/Caches: iTunes不会同步此文件夹，适合存储体积大，不需要备份的非重要数据。

NSString *path = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES).firstObject;
NSLog(@"%@", path);


Library/Preferences: iTunes同步该应用时会同步此文件夹中的内容，通常保存应用的设置信息。
tmp：iTunes不会同步此文件夹，系统可能在应用没运行时就删除该目录下的文件，所以此目录适合保存应用中的一些临时文件，用完就删除。

NSString *path = NSTemporaryDirectory();
NSLog(@"%@", path);



二、存储方式
　　在文章的开始已经讲到了，iOS中本地存储的方式一般有6种。下面我们将一个个来进行学习和研究。
2.1 plist文件(属性列表)
　　plist文件是将某些特定的类，通过XML文件的方式保存在目录中。可以被序列化的类型只有如下几种：

NSArray
NSMutableArray
NSDictionary
NSMutableDictionary
NSData
NSMutableData
NSString
NSMutableString
NSNumber
NSDate

1. 获得文件路径

　　项目中plist文件是存储在沙盒的documents中，所以要获取某个plist文件，只需要知道其文件名就可以了，如下方式就好可以获取并读取其中的内容，读取时通过对应类型的方式来获取plist的数据。一般plist中的内容都是以NSArray或NSDictionary的形式保存。


NSString *path = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
NSString *fileName = [path stringByAppendingPathComponent:@"123.plist"];NSArray *result = [NSArray arrayWithContentsOfFile:fileName];



2. 存储
往plist中写内容也非常简单，直接用相应类型的writeToFile方法即可。

NSArray *array = @[@"123", @"456", @"789"];
[array writeToFile:fileName atomically:YES]; 

3. 注意


只有以上列出的类型才能使用plist文件存储。


存储时使用writeToFile: atomically:方法。 其中atomically表示是否需要先写入一个辅助文件，再把辅助文件拷贝到目标文件地址。这是更安全的写入文件方法，一般都写YES。


读取时使用arrayWithContentsOfFile:方法


2.2 preference（偏好设置）
　　preefrence（偏好设置）顾名思义就是用户在使用过程中对App的一些状态和自定义设置状态的保存，例如App的皮肤样式、游戏时是否屏蔽电话和聊天、界面显示格式等等。一般对于一些基本的用户设置，因为数据量很小，我们可以使用OC语言中的NSUserDefaults类来进行处理。使用方法很简单，只需要调用类中的方法即可。此外，NSUserDefaults 创建的数据其实也是一个plist文件，其中数据保存格式是键值对形式，即NSDictionary形式，该文件存放在沙盒 Library/Preferences/ 目录下，一个以你包名命名的.plist文件。
1. 使用方法

//1.获得NSUserDefaults文件
NSUserDefaults *userDefaults = [NSUserDefaults standardUserDefaults];
//2.向文件中写入内容
[userDefaults setObject:@"AAA" forKey:@"a"];
[userDefaults setBool:YES forKey:@"sex"];
[userDefaults setInteger:21 forKey:@"age"];
//2.1立即同步
[userDefaults synchronize];
//3.读取文件
NSString *name = [userDefaults objectForKey:@"a"];
BOOL sex = [userDefaults boolForKey:@"sex"];
NSInteger age = [userDefaults integerForKey:@"age"];
NSLog(@"%@, %d, %ld", name, sex, age);

2. 注意


偏好设置是专门用来保存应用程序的配置信息的，一般不要在偏好设置中保存其他数据。


如果没有调用synchronize方法，系统会根据I/O情况不定时刻地保存到文件中。所以如果需要立即写入文件的就必须调用synchronize方法。


偏好设置会将所有数据保存到同一个文件中。即preference目录下的一个以此应用包名来命名的plist文件。


2.3  NSKeyedArchiver（归档）
　　之前说了，不管是NSUserDefaults 或者是 plist 都不能对自定义的对象进行存储，OC提供了解归档恰好解决这个问题。归档在iOS中是另一种形式的序列化，只要遵循了NSCoding协议的对象都可以通过它实现序列化。由于决大多数支持存储数据的Foundation和Cocoa Touch类都遵循了NSCoding协议，因此，对于大多数类来说，归档相对而言还是比较容易实现的。
1. 遵循NSCoding协议
　　NSCoding协议声明了两个方法，这两个方法都是必须实现的。一个用来说明如何将对象编码到归档中，另一个说明如何进行解档来获取一个新对象。

遵循协议和设置属性




1  //1.遵循NSCoding协议 
2   @interface Person : NSObject   //2.设置属性
3   @property (strong, nonatomic) UIImage *avatar;
4   @property (copy, nonatomic) NSString *name;
5   @property (assign, nonatomic) NSInteger age;
6   @end




实现协议方法




 1 //解档
 2   - (id)initWithCoder:(NSCoder *)aDecoder {
 3       if ([super init]) {
 4           self.avatar = [aDecoder decodeObjectForKey:@"avatar"];
 5           self.name = [aDecoder decodeObjectForKey:@"name"];
 6           self.age = [aDecoder decodeIntegerForKey:@"age"];
 7       }
 8       return self;
 9   }
10   //归档
11   - (void)encodeWithCoder:(NSCoder *)aCoder {
12       [aCoder encodeObject:self.avatar forKey:@"avatar"];
13       [aCoder encodeObject:self.name forKey:@"name"];
14       [aCoder encodeInteger:self.age forKey:@"age"];
15   }




 特别注意

　　如果需要归档的类是某个自定义类的子类时，就需要在归档和解档之前先实现父类的归档和解档方法。即 [super encodeWithCoder:aCoder] 和 [super initWithCoder:aDecoder] 方法。
2. 使用
　　需要把对象归档是调用NSKeyedArchiver的工厂方法 archiveRootObject: toFile: 方法。



1 NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
2  Person *person = [[Person alloc] init];
3  person.avatar = self.avatarView.image;
4  person.name = self.nameField.text;
5  person.age = [self.ageField.text integerValue];
6  [NSKeyedArchiver archiveRootObject:person toFile:file];



　　需要从文件中解档对象就调用NSKeyedUnarchiver的一个工厂方法 unarchiveObjectWithFile: 即可。

1 NSString *file = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByAppendingPathComponent:@"person.data"];
2 Person *person = [NSKeyedUnarchiver unarchiveObjectWithFile:file];
3 if (person) {
4      self.avatarView.image = person.avatar;
5      self.nameField.text = person.name;
6      self.ageField.text = [NSString stringWithFormat:@"%ld", person.age];
7 }

3. 注意


必须遵循并实现NSCoding协议


保存文件的扩展名可以任意指定


继承时必须先调用父类的归档解档方法

扩展：iOS开发基础-数据存储方式（归档）

2.4 手动存放沙盒
　　手动将数据存放到沙盒，其实就是自己在沙盒的某一个指定路径（第一部分介绍了沙盒各目录路径的获取方式）下新建一个保存数据的文件（.txt、.plist、.data等格式的文件），然后向其中写我们需要保存的数据即可。但是沙盒中只能保存OC中的基本数据，自定义的对象不能直接存入，但是可以通过归档存为.data文件。 

1  //假设我们需往cache 存入数据，并命名为test的txt格式文件中
2 NSString *filePath = [cachesDir stringByAppendingPathComponent:@"test.txt"];
3 NSArray *dic = [[NSArray alloc] initWithObjects:@"test",@"test1" ,nil];
4     
5 if([dic writeToFile:filePath atomically:YES]){
6     NSLog(@"存入成功");
7 }
8 //取出数据 打印
9 NSLog(@"%@",[NSArray arrayWithContentsOfFile:filePath]); 

2.5 CoreData
　　Core Date是ios3.0后引入的数据持久化解决方案，它是是苹果官方推荐使用的，不需要借助第三方框架。Core Date实际上是对SQLite的封装，提供了更高级的持久化方式。在对数据库操作时，不需要使用sql语句，也就意味着即使不懂sql语句，也可以操作数据库中的数据。
　　在各类应用开发中使用数据库操作时通常都会用到 (ORM) “对象关系映射”，Core Data就是这样的一种模式。ORM是将关系数据库中的表，转化为程序中的对象，但实际上是对数据中的数据进行操作。
　　在使用Core Data进⾏行数据库存取并不需要手动创建数据库，创建数据库的过程完全由Core Data框架自动完成，开发者需要做的就是把模型创建起来，具体数据库的创建不需要管。简单点说，Core Data实际上是将数据库的创建、表的创建、对象和表的转换等操作封装起来，极大的简化了我们的操作。
　　Core Date与SQLite相比较，SQLite比较原始，操作比较复杂，使用的是C的函数对数据库进行操作，但是SQLite可控性更强，并且能够跨平台。
　　关于Core Date的具体使用方法参见：IOS 数据存储之 Core Data详解
2.6 SQLite 3
　　iOS系统自带Core Data来进行持久化处理，而且Core Data可以使用图形化界面来创建对象，但是Core Data不是关系型数据库，对于Core Data来说比较擅长管理在设备上创建的数据持久化存储用户创建的对象，但是要处理大量的数据时就应该优先选择SQL关系型数据库来存储这些数据。 　　Core Data在后台也是使用SQLite来存储数据的，但是开发人员不能直接访问这些数据，只能通过Core Data提供的API来操作，如果一旦人为的通过SQLite修改这些数据那么使用Core Data再次访问这些数据时就会发生错误。
　　SQLite是使用C语言写的开源库，实现了一个自包含的SQL关系型数据库引擎，可以使用SQLite存储操作大量的数据，作为关系型数据库我们可以在一个数据库中建立多张相关联的表来解决大量数据重复的问题。而且SQLite库也针对移动设备上的使用进行了优化。 因为SQLite的接口使用C写的，而且Objective-C是C的超集所以可以直接在项目中使用SQLite。 
　　关于SQLite的详细使用方法详见：iOS开发数据库篇—SQLite的应用
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/mukekeheart/p/8177410.html
====================================================================================================
【Socket】苍老师有了丈夫，我也有了SAEA
****************************************************************************************************
一、前言
       时间过得真是快，转眼就2018年了。首先祝各位博友，软件开发者新年新气象，事业有成，身体健康，阖家幸福！最近看到园子里好多关于自己的2017年度总结以及对自己新一年的愿景，觉得咱园子的氛围是真的好。这三天假期我也没闲着，一边看OB海鲜团吃鸡一边写Socket SocketAsyncEventArgs 代码。我上一篇博客已经用APM的方式实现了客户端与服务器端的Socket通信，并具有了一定的并发能力。所以这三天我就决定对服务器代码进行改造，使用MS在4.0时发布的SocketAsyncEventArgs（SAEA）写法。为了方便的进行服务器端两种写法的对比，我客户端的代码没有进行变化，依然使用APM方式。代码已经上传至Github，链接会在文末贴出。
 
二、我的业务功能
       我的业务功能依然是实现从服务器多线程下载更新文件。下载之前的那些操作我基本就不讲了，上一篇博文里的都有，本文还是回到Socket下载文件上。具体流程如下：

       在我写SAEA代码之前，我仔细搜了一下网上的资源：MSDN、CNBLOG、CSDN、CodeProject。这四种来源的代码示例的主要流程是这样的：

      对比我的流程，您会发现少了一半的通信过程。客户端的代码好写，但是服务器端如何发送完数据之后再接收数据？这中间的衔接过程还是有点门道的。特别是SAEA的代码采用了Buffer池化以及SAEA池化之后，里面有些小的细节就要想清楚了。下面就是具体的代码，我会以我自己的视角去论述APM与SAEA到底有什么区别。
 
三、对比
     其实对于服务器端的APM，我觉得最重要的并不是代码中的BeginXXX或者是EndXXX，因为这就是APM写法的特征，BeginXXX或者EndXXX然后里面有一个回调函数，在回调函数里去做一些业务上的事情。最重要的是要有一个线程等待的概念，也就是代码中的ManualResetEvent这个东西，它就像地铁闸机一样，处理好一个再放一个进去。APM写法的好处是显而易见的，就是代码看起来十分的简单。缺点依照MS的说法就是如果有过多的客-服交流，可能会产生较多的IAsyncResult对象，这样会增加服务器的开销。   
     服务器端的APM写法：

  1 using System;
  2 using System.IO;
  3 using System.Linq;
  4 using System.Net;
  5 using System.Net.Sockets;
  6 using System.Threading;
  7 using UpdaterShare.GlobalSetting;
  8 using UpdaterShare.Model;
  9 using UpdaterShare.Utility;
 10 
 11 namespace UpdaterServerAPM
 12 {  
 13     public static class ServerSocket
 14     {
 15         private static int _downloadChannelsCount;
 16         private static string _serverPath;
 17         private static readonly ManualResetEvent AllDone = new ManualResetEvent(false);
 18 
 19         public static void StartServer(int port, int backlog)
 20         {         
 21             _downloadChannelsCount = DownloadSetting.DownloadChannelsCount;
 22             try
 23             {
 24                 IPAddress ipAddress = IPAddress.Any;
 25                 IPEndPoint localEndPoint = new IPEndPoint(ipAddress, port);
 26                 Socket listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
 27                 listener.Bind(localEndPoint);
 28                 listener.Listen(backlog);
 29 
 30                 while (true)
 31                 {
 32                     AllDone.Reset();
 33                     listener.BeginAccept(AcceptCallback, listener);
 34                     AllDone.WaitOne();
 35                 }
 36             }
 37             catch (Exception ex)
 38             {
 39                 var path = $"{AppDomain.CurrentDomain.BaseDirectory}\\RunLog.txt";
 40                 File.AppendAllText(path, ex.Message);
 41             }
 42         }
 43 
 44 
 45         private static void AcceptCallback(IAsyncResult ar)
 46         {
 47             AllDone.Set();
 48             Socket listener = (Socket)ar.AsyncState;
 49             Socket handler = listener.EndAccept(ar);
 50             ComObject state = new ComObject { WorkSocket = handler };
 51             handler.BeginReceive(state.Buffer, 0, ComObject.BufferSize, 0, FindUpdateFileCallback, state);
 52         }
 53 
 54 
 55         private static void FindUpdateFileCallback(IAsyncResult ar)
 56         {
 57             ComObject state = (ComObject)ar.AsyncState;
 58             Socket handler = state.WorkSocket;
 59             int bytesRead = handler.EndReceive(ar);
 60             if (bytesRead > 0)
 61             {
 62                 var receiveData = state.Buffer.Take(bytesRead).ToArray();
 63                 var dataList = PacketUtils.SplitBytes(receiveData, PacketUtils.ClientFindFileInfoTag());
 64                 if (dataList != null && dataList.Any())
 65                 {
 66                     var request = PacketUtils.GetData(PacketUtils.ClientFindFileInfoTag(), dataList.FirstOrDefault());
 67                     string str = System.Text.Encoding.UTF8.GetString(request);
 68                     var infos = str.Split('_');
 69                     var productName = infos[0];
 70                     var revitVersion = infos[1];
 71                     var currentVersion = infos[2];
 72 
 73                     var mainFolder = AppDomain.CurrentDomain.BaseDirectory.Replace("bin", "TestFile");
 74                     var serverFileFolder = Path.Combine(mainFolder, "Server");
 75                     var serverFileFiles = new DirectoryInfo(serverFileFolder).GetFiles();
 76                    
 77                     var updatefile  = serverFileFiles.FirstOrDefault(x=>x.Name.Contains(productName) && x.Name.Contains(revitVersion) && x.Name.Contains(currentVersion));
 78                     if (updatefile != null)
 79                     {
 80                         if (string.IsNullOrEmpty(updatefile.FullName) || !File.Exists(updatefile.FullName)) return;
 81                         _serverPath = updatefile.FullName;
 82                         FoundUpdateFileResponse(handler);
 83                     }
 84                 }
 85             }
 86         }
 87 
 88 
 89         private static void FoundUpdateFileResponse(Socket handler)
 90         {
 91             byte[] foundUpdateFileData = PacketUtils.PacketData(PacketUtils.ServerFoundFileInfoTag(),null);
 92             ComObject state = new ComObject { WorkSocket = handler };
 93             handler.BeginSend(foundUpdateFileData, 0, foundUpdateFileData.Length, 0, HasFoundUpdateFileCallback, state);
 94         }
 95 
 96 
 97         private static void HasFoundUpdateFileCallback(IAsyncResult ar)
 98         {
 99             ComObject state = (ComObject)ar.AsyncState;
100             Socket handler = state.WorkSocket;
101             handler.EndSend(ar);
102             handler.BeginReceive(state.Buffer, 0, ComObject.BufferSize, 0, ReadFilePositionRequestCallback, state);
103         }
104 
105 
106         private static void ReadFilePositionRequestCallback(IAsyncResult ar)
107         {
108             ComObject state = (ComObject)ar.AsyncState;
109             Socket handler = state.WorkSocket;
110             int bytesRead = handler.EndReceive(ar);
111             if (bytesRead > 0)
112             {
113                 var receiveData = state.Buffer.Take(bytesRead).ToArray();
114                 var dataList = PacketUtils.SplitBytes(receiveData, PacketUtils.ClientRequestFileTag());
115                 if (dataList != null)
116                 {
117                     foreach (var request in dataList)
118                     {
119                         if (PacketUtils.IsPacketComplete(request))
120                         {
121                             int startPosition = PacketUtils.GetRequestFileStartPosition(request); 
122                             SendFileResponse(handler, startPosition);
123                         }
124                     }
125                 }
126             }
127         }
128 
129         private static void SendFileResponse(Socket handler, int startPosition)
130         {
131             var packetSize = PacketUtils.GetPacketSize(_serverPath, _downloadChannelsCount);
132             if (packetSize != 0)
133             {
134                 byte[] filedata = FileUtils.GetFile(_serverPath, startPosition, packetSize);
135                 byte[] packetNumber = BitConverter.GetBytes(startPosition/packetSize);
136                 if (filedata != null)
137                 {
138                     byte[] segmentedFileResponseData = PacketUtils.PacketData(PacketUtils.ServerResponseFileTag(), filedata, packetNumber);
139                     ComObject state = new ComObject {WorkSocket = handler};
140                     handler.BeginSend(segmentedFileResponseData, 0, segmentedFileResponseData.Length, 0, SendFileResponseCallback, state);
141                 }
142             }
143             else
144             {               
145                 handler.Shutdown(SocketShutdown.Both);
146                 handler.Close();
147             }       
148         }
149 
150 
151         private static void SendFileResponseCallback(IAsyncResult ar)
152         {
153             try
154             {
155                 ComObject state = (ComObject)ar.AsyncState;
156                 Socket handler = state.WorkSocket;
157                 handler.EndSend(ar);
158                 handler.Shutdown(SocketShutdown.Both);
159                 handler.Close();             
160             }
161             catch (Exception e)
162             {
163 
164             }
165         }
166     }
167 }

        说到SAEA，我觉得初入的小伙伴一定要先看MSDN上的实例，特别是它的BufferManager以及SocketAsyncEventArgsPool是怎么写的，到底是干什么用的。这里我可以简单的说下：SocketAsyncEventArgsPool是用来存放SAEA对象的，其个数依赖于你服务器所能承担的队列长度，比如说我服务器能承担100个客户的等待，我就在服务器端生成100个SAEA对象放在池子里，当有客户来连接时，我从池子里取出一个来和他对接。客户走了，我再扔到池子里去。BufferManager则是对池子里的SAEA对象进行Buffer分配的，也相当于一个池子，这个池子的大小是队列长度*通信缓存长度*2，乘以2是因为读与写是分开的。通信缓存长度很好理解，客户端要传个2G的信息给服务器端不可能一下子接收2G，肯定是一口一口吃，那么这一口的大小就是通信缓存长度。那么分配给每个SAEA的缓存是多大呢？当然就是通信缓存长度的大小咯。注意！！注意！！注意！！既然是池化了，所有关于Buffer的操作都要围绕分配给SAEA的Buffer去操作！见148-149行。当服务器拿着分配到的Buffer去接收信息后，如果再要发送信息，所要做的第一件事就是先清空分配的Buffer再使用，BufferManager给你分配哪段你就用哪段，别使用错了。有几个参数需要注意：e.Offset（偏移），e.Count（大小），e.Buffer（缓存字节数组）， e.BytesTransferred（通信传输的字节长度）。如果服务器端要发送数据，一定要用Array.Copy将信息写入对应分配的Buffer中。
     说完池化，接着就是写法上的小区别，我觉得区别并不大，无非就是委托换了个写法。当然还要判断下是否为异步操作，如果是否则需要进行同步操作，见82-85行代码。 
       服务器的SAEA写法：

  1 using System;
  2 using System.IO;
  3 using System.Linq;
  4 using System.Net;
  5 using System.Net.Sockets;
  6 using System.Threading;
  7 using UpdaterShare.GlobalSetting;
  8 using UpdaterShare.Model;
  9 using UpdaterShare.Utility;
 10 
 11 namespace UpdaterServerSAEA
 12 {
 13     public class ServerSocket
 14     {
 15         private readonly int _port;
 16         private readonly int _backlog;
 17         private Socket _listenSocket;
 18         private const int _opsToPreAlloc = 2;
 19         private readonly BufferManager _bufferManager;
 20         private readonly SocketAsyncEventArgsPool _readWritePool;
 21         private readonly Semaphore _maxNumberAcceptedClients;
 22 
 23         private string _serverPath;
 24         private static readonly int _downloadChannelsCount = DownloadSetting.DownloadChannelsCount;
 25 
 26         public ServerSocket(int port, int backlog)
 27         {
 28             _port = port;
 29             _backlog = backlog;
 30 
 31             _bufferManager = new BufferManager(ComObject.BufferSize * backlog * _opsToPreAlloc, ComObject.BufferSize);
 32             _readWritePool = new SocketAsyncEventArgsPool(backlog);
 33             _maxNumberAcceptedClients = new Semaphore(backlog, backlog);
 34         }
 35 
 36 
 37         private void Init()
 38         {
 39             _bufferManager.InitBuffer();
 40 
 41             for (var i = 0; i < _backlog; i++)
 42             {
 43                 var readWriteEventArg = new SocketAsyncEventArgs();
 44                 _bufferManager.SetBuffer(readWriteEventArg);
 45                 _readWritePool.Push(readWriteEventArg);
 46             }
 47         }
 48 
 49 
 50         public void StartServer()
 51         {
 52             try
 53             {
 54                 Init();
 55                 IPAddress ipAddress = IPAddress.Any;
 56                 IPEndPoint localEndPoint = new IPEndPoint(ipAddress, _port);
 57                 _listenSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
 58                 _listenSocket.Bind(localEndPoint);
 59                 _listenSocket.Listen(_backlog);
 60                 StartAccept(null);
 61             }
 62             catch (Exception ex)
 63             {
 64                 Console.WriteLine(ex.Message);
 65             }
 66         }
 67 
 68         private void StartAccept(SocketAsyncEventArgs acceptEventArg)
 69         {
 70             if (acceptEventArg == null)
 71             {
 72                 acceptEventArg = new SocketAsyncEventArgs();
 73                 acceptEventArg.Completed += StartAccept_Completed;
 74             }
 75             else
 76             {
 77                 acceptEventArg.AcceptSocket = null;
 78             }
 79 
 80             _maxNumberAcceptedClients.WaitOne();
 81 
 82             if (!_listenSocket.AcceptAsync(acceptEventArg))
 83             {
 84                 ProcessAccept(acceptEventArg);
 85             }
 86         }
 87 
 88         private void StartAccept_Completed(object sender, SocketAsyncEventArgs e)
 89         {
 90             ProcessAccept(e);
 91         }
 92 
 93 
 94         private void ProcessAccept(SocketAsyncEventArgs e)
 95         {
 96             if (e.SocketError == SocketError.Success)
 97             {
 98                 var socket = e.AcceptSocket;
 99                 if (socket.Connected)
100                 {
101                     SocketAsyncEventArgs readEventArgs = _readWritePool.Pop();
102                     readEventArgs.AcceptSocket = socket;
103                     readEventArgs.Completed += ProcessAccept_Completed;
104                     if (!socket.ReceiveAsync(readEventArgs))
105                     {
106                         ProcessReceiveFindFileRequest(readEventArgs);
107                     }
108                     StartAccept(e);
109                 }
110             }
111         }
112 
113         private void ProcessAccept_Completed(object sender, SocketAsyncEventArgs e)
114         {
115             ProcessReceiveFindFileRequest(e);
116         }
117 
118 
119         private void ProcessReceiveFindFileRequest(SocketAsyncEventArgs e)
120         {
121             var bytesRead = e.BytesTransferred;
122             if (bytesRead > 0 && e.SocketError == SocketError.Success)
123             {
124                 var receiveData = e.Buffer.Skip(e.Offset).Take(bytesRead).ToArray();
125                 var dataList = PacketUtils.SplitBytes(receiveData, PacketUtils.ClientFindFileInfoTag());
126                 if (dataList != null && dataList.Any())
127                 {
128                     var request = PacketUtils.GetData(PacketUtils.ClientFindFileInfoTag(), dataList.FirstOrDefault());
129                     string str = System.Text.Encoding.UTF8.GetString(request);
130                     var infos = str.Split('_');
131                     var productName = infos[0];
132                     var revitVersion = infos[1];
133                     var currentVersion = infos[2];
134 
135                     var mainFolder = AppDomain.CurrentDomain.BaseDirectory.Replace("bin", "TestFile");
136                     var serverFileFolder = Path.Combine(mainFolder, "Server");
137                     var serverFileFiles = new DirectoryInfo(serverFileFolder).GetFiles();
138 
139                     var updatefile = serverFileFiles.FirstOrDefault(x => x.Name.Contains(productName) && x.Name.Contains(revitVersion) && x.Name.Contains(currentVersion));
140                     if (updatefile != null)
141                     {
142                         if (string.IsNullOrEmpty(updatefile.FullName) || !File.Exists(updatefile.FullName)) return;
143                         _serverPath = updatefile.FullName;
144 
145                         //ready to send back to Client
146                         byte[] foundUpdateFileData = PacketUtils.PacketData(PacketUtils.ServerFoundFileInfoTag(), null);
147 
148                         Array.Clear(e.Buffer, e.Offset, e.Count);
149                         Array.Copy(foundUpdateFileData, 0, e.Buffer, e.Offset, foundUpdateFileData.Length);
150 
151                         e.Completed -= ProcessAccept_Completed;
152                         e.Completed += ProcessReceiveFindFileRequest_Completed;
153 
154                         if (!e.AcceptSocket.SendAsync(e))
155                         {
156                             ProcessFilePosition(e);
157                         }
158                     }
159                 }
160             }
161         }
162 
163 
164         private void ProcessReceiveFindFileRequest_Completed(object sender, SocketAsyncEventArgs e)
165         {
166             ProcessFilePosition(e);
167         }
168 
169 
170         private void ProcessFilePosition(SocketAsyncEventArgs e)
171         {
172             if (e.SocketError == SocketError.Success)
173             {
174                 var socket = e.AcceptSocket;
175                 if (socket.Connected)
176                 {
177                     //clear buffer
178                     Array.Clear(e.Buffer, e.Offset, e.Count);
179 
180                     e.Completed -= ProcessReceiveFindFileRequest_Completed;
181                     e.Completed += ProcessFilePosition_Completed;
182 
183                     if (!socket.ReceiveAsync(e))
184                     {
185                         ProcessSendFile(e);
186                     }
187                 }
188             }
189         }
190 
191         private void ProcessFilePosition_Completed(object sender, SocketAsyncEventArgs e)
192         {
193             ProcessSendFile(e);
194         }
195 
196         private void ProcessSendFile(SocketAsyncEventArgs e)
197         {
198             var bytesRead = e.BytesTransferred;
199             if (bytesRead > 0 && e.SocketError == SocketError.Success)
200             {
201                 var receiveData = e.Buffer.Skip(e.Offset).Take(bytesRead).ToArray();
202                 var dataList = PacketUtils.SplitBytes(receiveData, PacketUtils.ClientRequestFileTag());
203                 if (dataList != null)
204                 {
205                     foreach (var request in dataList)
206                     {
207                         if (PacketUtils.IsPacketComplete(request))
208                         {
209                             int startPosition = PacketUtils.GetRequestFileStartPosition(request);
210 
211                             var packetSize = PacketUtils.GetPacketSize(_serverPath, _downloadChannelsCount);
212                             if (packetSize != 0)
213                             {
214                                 byte[] filedata = FileUtils.GetFile(_serverPath, startPosition, packetSize);
215                                 byte[] packetNumber = BitConverter.GetBytes(startPosition / packetSize);
216 
217                                 Console.WriteLine("Receive File Request PacketNumber: "+startPosition / packetSize);
218 
219                                 if (filedata != null)
220                                 {
221                                     //ready to send back to Client
222                                     byte[] segmentedFileResponseData = PacketUtils.PacketData(PacketUtils.ServerResponseFileTag(), filedata, packetNumber);
223 
224                                     Array.Clear(e.Buffer, e.Offset, e.Count);
225                                     Array.Copy(segmentedFileResponseData, 0, e.Buffer, e.Offset, segmentedFileResponseData.Length);
226 
227                                     e.Completed -= ProcessFilePosition_Completed;
228                                     e.Completed += ProcessSendFile_Completed;
229 
230                                     if (!e.AcceptSocket.SendAsync(e))
231                                     {
232                                         CloseClientSocket(e);
233                                     }
234                                 }
235                             }
236                         }
237                     }
238                 }
239             }
240             else
241             {
242                 CloseClientSocket(e);
243             }
244         }
245 
246 
247         private void ProcessSendFile_Completed(object sender, SocketAsyncEventArgs e)
248         {
249             CloseClientSocket(e);
250         }
251 
252 
253         private void CloseClientSocket(SocketAsyncEventArgs e)
254         {
255             try
256             {
257                 e.AcceptSocket.Shutdown(SocketShutdown.Both);
258                 e.AcceptSocket.Close();
259             }
260             catch (Exception ex)
261             {
262                 Console.WriteLine(ex.Message);
263             }
264             finally
265             {
266                 _maxNumberAcceptedClients.Release();
267                 _readWritePool.Push(e);
268             }
269         }
270     }
271 }

 
四、总结
      坑坑洼洼总算是写完了SAEA的代码，由于本人知识面有限，如果说的不对，还请各位及时直接提出批评与建议，我这个人比较在乎技术不在乎面子的。等过完年我该做些打算啦~
 
附：
MSDN示例：
https://msdn.microsoft.com/en-us/library/system.net.sockets.socketasynceventargs(v=vs.110).aspx
启蒙博客：
http://www.cnblogs.com/gaochundong/p/csharp_tcp_service_models.html
大神改造：
http://freshflower.iteye.com/blog/2285272
架构狂魔：
http://www.cnblogs.com/jiahuafu/archive/2013/01/05/2845631.html
 
我的GitHub
https://github.com/airforce094/Socket_APM-SAEA
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/lovecsharp094/p/8177146.html
====================================================================================================
嵌入式设计初体验：永远的hello,world
****************************************************************************************************
　目前，xilinx的zynq系列FPGA炒的火热，SOC成为FPGA发展的必然趋势。可见所有功能均用硬件描述语言设计是不科学的。硬件逻辑独有的并行性使其在实时处理和并行算法中占尽优势，但当执行串行操作时却需要使用笨重的状态机来完成。因此，要实现对实时性要求不高的串行操作，对各类IP核的总体控制调度，亦或是快速移植软件协议栈时，利用FPGA内部CPU是个比较好的选择。
 　　硬核CPU只在特定系列FPGA芯片中，性能当然没的说，占用的资源也非常少。但相比硬核，microblaze可移植性较强，性能要求不高的场合下还是非常灵活的。本文依然以经典的串口打印字符串“hello,world”为例，搭建基于microblaze的简单嵌入式系统。
　　 create block design，添加microblaze软核后点击Run Block Automation。

 　　这里暂时不使用DDR之类的缓存设备，利用片内Memory存储代码，因此将Local Memory容量增大。

　　点击OK后工具自动生成CPU系统所需要的所有必要硬件模块，包括：时钟管理单元，复位逻辑，调试模块，microblaze CPU，以及local memory。

 　　双击clk_wiz_1模块，根据开发板对其进行配置。本例中开发板上使用200MHz差分晶振作为时钟源，做如下改动。

 　　开发板上复位按键低电平有效，改为Active low。
 　　实现串口打印字符串功能，首先得有串口模块提供硬件支持，添加uartlite IP核。串口IP核同样可以根据需求重配置，这里保持默认设置：波特率9600，数据位是8bit，无校验位。

 　　IP核添加并配置完毕，同样利用工具自动连接。点击Run Connection Automation，选中所有可连接选项。重新布局后嵌入式硬件系统结构如下：

 　　点击左侧竖排工具栏中的Validate Design，保证系统没有连接错误。

　　右击Source窗口中block design名称，依次选中Generate Output Products和Generate HDL Wrapper。前者生成可综合，布局布线的.v文件，后者产生工程顶层封装。

 　　需要注意的是，生成顶层文件时，可以选择顶层文件自动更新或手动编辑。当需要手动添加硬件模块到顶层文件时选择可手动编辑方式，这里保持默认。

 　　之后添加XDC文件，给出引脚号及电平标准即可。

 　　此时与HDL设计流程相同，综合、布局布线和生成比特流。点击vivado界面上侧主选项栏File->Export->Export Hardware。这里要选中Include bitstream，否则SDK中无法识别硬件系统。最后点击File->Lanch SDK启动软件开发工具，开始软件设计流程。建立第一个软件工程时会自动生成BSP包，相当于硬件系统中物理约束了的映射，之后可重复利用，还是比较方便的。

 　　打开HelloWorld工程中.c文件，其中有三个函数，其实是对串口一些操作的封装。

 　　这了为了方便观察现象，将串口打印函数放置在while循环中，使其连续打印字符串。保存后代码自动编译。
 　　选中工具栏Xilinx Tools->Program FPGA下载代码。此处在下方选择生成的HelloWorld.elf可执行文件，将硬件比特流和软件代码同时下载到FPGA中。

　　打开串口调试助手，设置好波特率以及显示格式，可以看到不断打印“Hello World”字符串。

 　　本文搭建了基于Microblaze的最简单的嵌入式系统，对IP Integrator和SDK环境有了初步的认识。在后续的博文中，会进一步阐述自定义总线形式IP核的生成，调用以及与CPU之间的数据交互。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/moluoqishi/p/8177496.html
====================================================================================================
js文件加载优化
****************************************************************************************************
在js引擎部分，我们可以了解到，当渲染引擎解析到script标签时，会将控制权给JS引擎，如果script加载的是外部资源，则需要等待下载完后才能执行。 所以，在这里，我们可以对其进行很多优化工作。
放置在BODY底部
为了让渲染引擎能够及早的将DOM树给渲染出来，我们需要将script放在body的底部，让页面尽早脱离白屏的现象，即会提早触发DOMContentLoaded事件. 但是由于在IOS Safari, Android browser以及IOS webview里面即使你把js脚本放到body尾部，结果还是一样。 所以这里需要另外的操作来对js文件加载进行优化.
DEFER加载
这是HTML4中定义的一个script属性，它用来表示的是，当渲染引擎遇到script的时候，如果script引用的是外部资源，则会暂时挂起，并进行加载。 渲染引擎继续解析下面的HTML文档，解析完时，则会执行script里面的脚本。

<script src="outside.js" defer></script>

他的支持度是<=IE9的. 并且，他的执行顺序，是严格依赖的，即:

<script src="outside1.js" defer></script>
<script src="outside2.js" defer></script>

当页面解析完后，他便会开始按照顺序执行 outside1 和 outside2文件。如果你在IE9以下使用defer的话，可能会遇到 它们两个不是顺序执行的，这里需要一个hack进行处理，即在两个中间加上一个空的script标签

<script src="outside1.js" defer></script>
<script></script> //hack
<script src="outside2.js" defer></script>

ASYNC加载
async是H5新定义的一个script 属性。 他是另外一种js的加载模式。


渲染引擎解析文件，如果遇到script(with async)


继续解析剩下的文件，同时并行加载script的外部资源


当script加载完成之后，则浏览器暂停解析文档，将权限交给JS引擎，指定加载的脚本。


执行完后，则恢复浏览器解析脚本


可以看出async也可以解决 阻塞加载 这个问题。不过，async执行的时候是异步执行，造成的是，执行文件的顺序不一致。即:

<script src="outside1.js" async></script>
<script src="outside2.js" async></script>

这时，谁先加载完，就先执行谁。所以，一般依赖文件就不应该使用async而应该使用defer.

defer的兼容性比较差，为IE9+,不过一般是在移动端使用，也就不存在这个problem了。
脚本异步
脚本异步是一些异步加载库(比如require)使用的基本加载原理. 直接上代码:

function asyncAdd(src){
    var script = document.createElement('script');
    script.src = src;
    document.head.appendChild(script);
}
//加载js文件
asyncAdd("test.js");

这时候，可以异步加载文件，不会造成阻塞的效果.但是，这样加载的js文件是无序的，无法正常加载依赖文件。这时候，我们需要对上述函数进行优化.

var asyncAdd = (function(){
    var head = document.head,
        script;
    return function(src){
        script = document.createElement('script');
        script.src= src;
        script.async=false;
        document.head.appendChild(script);
    }
})();
//加载文件
asyncAdd("first.js");
asyncAdd("second.js");
//或者简便一点
["first.js","second.js"].forEach((src)=>{async(src);});

但是，使用脚本一步加载的话，需要等待css文件加载完后，才开始进行加载，不能充分利用浏览器的并发加载优势。而使用静态文本加载async或者defer则不会出现这个问题。使用脚本异步加载时，只能等待css加载完后才会加载
使用静态的async加载时，css和js会并发一起加载
关于这三种如何取舍，那就主要看leader给我们目标是什么，是兼容IE8,9还是手机端，还是桌面浏览器，或者两两组合。 
但是对于单独使用某一个技能的场景，使用时需要注意一些tips。js文件放置位置应该放置到body末尾如果使用async的话，最后加上defer以求向下兼容

<script src="test.js" async defer></script> //如果两者都支持，async会默认覆盖掉defer
//如果只支持一个，则执行对应的即可

通常，我们使用的加载都是defer加载(因为很强的依赖关系).
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/csd97/p/8178339.html
====================================================================================================
JavaScript对象和数组
****************************************************************************************************
在JavaScript中对象是一种数据结构，用于将数据和功能组织在一起，描述一类对象所具有的属性和方法。
对象是某个特定类型的实例。新对象是new操作符后跟一个关键字来实现的。构造函数本身就是一个函数，用于创建新对象。 var person = new Object();这行代码创建了一个Object的实例，并将值保存了变量person中。
创建对象的方式有两种，一种是通过Object函数来创建。

var animal = new Object();
                animal.eat=function(){
                    console.log("eat");
                };
                animal.color="blue";

上面的代码通过object创建了对象animal，并创建了对象的方法eat以及属性color。
同时可以通过字面量的方式创建对象。

var animal={
                    eat:function(){
                        console.log("eat");
                    },
                    color:"blue"
                }

上面通过字面量的方式创建了新对象animal，并创建了方法eat和属性color。通过字面量创建的对象，并不会调用Object函数。对象可以作为参数传递至函数中使用。

function test(args){
                    console.log("Name:"+args.name+"\n");
                    console.log("age:"+args.age+"\n");
                }
                test({"name":"haha","age":18});

函数test接收了args参数，args是一个对象。在函数中可以直接访问对象的属性。这种情况适合向函数传递大量的可选参数情况。

function Person(options){
					//Jquery 的extend方法，用于合并参数
					this.options=$.extend(true, {"name":"zhang"},options);
					console.log(this.options);
				}
				var perosn = new Person({
					"name":"ge",
					"age":18,
					"sex":"man"
				});


　　上面的代码定义了Person函数，并且为person传递了大量的对象。同时在函数内部有默认的对象，用jquery的extend方法进行参数的合并。
一般情况下，访问对象的属性通过操作符.来访问，不如person.name。访问对象的方法也通过.来调用,比如person.eat()。访问对象的属性还有另外一种访问方式，通过下标的方式访问，比如person["age"]。
有些对象的属性包含一些特殊字符，不能通过操作符（.）来访问，必须通过中括号的方式来访问，比如“first name”，这个属性有空格，必须通过中括号访问。person["first name"]。
JavaScript中的数组与其他高级语言有很大的区别，数组中存放不同类型的值，可以在数组的第一个位置存放Number，第二个位置存放布尔值。创建数组也有两种基本的方式，比如 var array = new Array();
如果预先知道数组的长度，可以 var array = new Array(20);也可以向数组中传递参数， var array = new Array("red",20,true);当我们只传递一个参数时候就比较复杂了，如果传递的是数值，则创建该长度的数组，如果传递的是字符串，则创建包含这个值的数组。
创建数组的另一种方式是通过字面量的方式创建数组。
var array=[];var array1=["blue",1,true];
访问数组的方式通过[]下标的方式访问的，比如 array1[0]，输出第一项的值;rray1[1]，输出第二项的值;array[2]="hehe"，修改了第三项的值;array[3]="en"，添加新的数组元素。方括号中的索引表示要访问的值。数组的长度保存在length中。
通过 instanceof，以及isArray可以判断一个对象是否是数组，比如 array instanceof Array,array.isArray()

var array=["blue","red","yellow"];
console.log(array.toString());//输出blue,red,yellow
console.log(array.join(";"));//输出blue;red;yellow

toString()方法将数组转换为String,通过操作符逗号分隔数组元素。同时数组提供了join方法可以指定字符来分隔数组元素。

var array=["blue","red","yellow"];
console.log(array.toString());//输出blue,red,yellow
console.log(array.join(";"));//输出blue;red;yellow
var str = array.toString();//
var narray= str.split(",");//["blue","red","yellow"];
console.log(narray[0]);//输出blue

上述代码展示split的用法，split可以字符串转换为数组。通过指定的分隔符，将字符串转换为数组。
数组提供了一组方法，使数组使用和其他的数据结构一样。数组可以表现的像栈一样，可以限制插入和删除。栈是一种后进先出的数据结构，最新添加的项最早被移除。插入和删除都发生在栈的顶部。数组提供了push和pop方法。
push方法接收任意数量的参数，将他们逐个添加到数组的末尾，并返回数组的长度。pop方法可以从数组的末尾删除一项，并返回移除的项

var array=[];
console.log(array.length);//0
array.push("red");
console.log(array.length);//1
array.pop();
console.log(array.length);//0

上面的代码，定义了一个数组array，并通过push方法添加了一项，数组的长度为1，通过pop方法删除了一项，数组的长度为0.
队列的数据结构是先进先出，数组同样可以表现的像队列一样，实现元素的先进先出。队列在末尾添加元素，在列表的前端移除数据项。push方法可以向数组的末端添加数据元素，shift方法可以移除数组的第一项，并返回，同时数组长度减1.

var array=[];
array.push("red");
array.push("blue");
array.push("green");
array.shift();
console.log(array.toString());//blue,green

上面的代码定义了一个数组array，并通过push方法添加了三项元素，最好通过shift方法删除数组的第一项，最后数组只有两项，toString()方法输出。
数组的重新排序有两个方法reverse和sort。reverse就是数组元素反转，sort方法将数组进行升序排列，首先要将数组的元素调用toString方法，然后再进行排序。

var array=[1,7,5,3,2];
array.reverse();
console.log(array.toString());//2，3，5，7，1
array.sort();
console.log(array.toString());//1，2，3，5，7


var array =[1,3,5,7,9,11];
array.sort();
console.log(array.toString());//输出1，11，3，5，7，9

 
通过上面的代码，我们发现sort方法的排序有时候并不是我们想要的结果，所以sort方法提供了传递函数作为参数的方法。通过传递函数我们能够实现数值的升序以及降序排列。

function compareMax(v1,v2){
                    if(v1<v2){
                        return -1;
                    }
                    else if(v1>v2){
                        return 1
                    }
                    else{
                        return 0;
                    }
                }
                //降序
                function compareMin(v1,v2){
                    if(v1<v2){
                        return 1;
                    }
                    else if(v1>v2){
                        return -1;
                    }
                    else {
                        return 0;
                    }
                }
                var array= [1,3,11,7,2,10];
                array.sort(compareMax);
                console.log(array.toString());//1,2,3,7,10,11
                array.sort(compareMin);
                console.log(array.toString());//11,10,7,3,2,1

比较函数接收两个参数，如果第一个参数应该在第二个参数之前则返回负数，如果第一个参数应该位于第二个参数之后则返回整数，两个数相等返回0.


//升序排列
                function compareMax(v1,v2){
                    /*if(v1<v2){
                        return -1;
                    }
                    else if(v1>v2){
                        return 1
                    }
                    else{
                        return 0;
                    }*/
                    return v1-v2;
                }
                //降序
                function compareMin(v1,v2){
                /*    if(v1<v2){
                        return 1;
                    }
                    else if(v1>v2){
                        return -1;
                    }
                    else {
                        return 0;
                    }*/
                    return v2-v1;
                }

View Code
通过上面的两个函数同样可以实现升级和降序排列。
 JavaScript的数组还包含许多其他常用的方法。concat方法基于当前的数组，形成一个新的数组，并不改变原数组的值。concat的参数可以一个或者多个数组，可以不是数组。如果不是数组，则在原数组的末尾添加一个新的元素，形成新的数组。如果是数组，则会将数组的每一项添加到新的数组中，形成新的数组。

var array=["1",2];
var array1=array.concat(["3",4]);
console.log(array.toString());//输出1，2
console.log(array1.toString());//输出1,2,3,4

上面的代码可以看出通过concat生成了新的数组，原数组的值并没有发生改变。
slice方法能够基于当前数组的一项或者多项创建一个新的数组，不会改变原始数组。slice方法有一个或者两个参数，表示数组下标的起始和结束的位置，不包括结束位置。如果只有一个参数，则从开始位置一直到数组结束。

var array=["blue","red","green","black","white"];
var array1=array.slice(1,3);
var array2=array.slice(1);
console.log(array1.toString());//red,green
console.log(array2.toString());//red,green,black,white

如果slice参数有负数，则用数组长度加上该负数，如array.slice(-2,-1)，则array.slice(3,4)相当。如果起始位置大于结束位置，则返回空数组。
splice方法可以向数组的中部插入元素，splice可以实现数组的插入、删除和替换。删除需要指定两个参数，要删除第一项的位置，要删除的项数。如splice(1,3)，从数组第二项开始，删除三个数组元素。splice插入方法至少传递三个参数，第一要插入元素的位置，第二个要删除的项数（0），第三个参数要插入的元素，如果要插入多项，可以有第四个参数。。。。
splice的替换方法也至少需要三个参数，第一个参数元素要删除的位置，第二个参数删除的项数，第三个参数插入的元素。

var array=["red","green","blue","white","black"];
var array1=array.splice(1,1);//array被删除一项["red","blue","white","black"]
var array2=array.splice(1,0,"green");//["red","green","blue","white","black"]
var arrays=array.splice(1,1,"yellow");//["red","yellow","blue","white","black"]

上面的代码讲述了splice方法的删除、插入、替换方法的使用。
数组的indexOf方法可以查找某个元素在数组的位置，如果数组中部存在该元素，则返回-1.

var array=["red","green","blue","white","black"];
console.log(array.indexOf("green"));//1
console.log(array.indexOf("orange"));//-1

JavaScript为数组提供了5个遍历的方法，分别是every、fillter、forEach、map和some方法。every方法对数组的每一项运行给定的函数，如果该数组的每一项对函数都返回true，则返回true。
some方法与every方法类似，但是some方法只要有一项满足函数，就返回true。

var array=[1,2,3,4,5];
                var result=array.every(function(value,index,array){
                    return value>2;
                });
                console.log(result);//false,因为1<2
                var result1=array.some(function(value,index,array){
                    return value>2;
                });
                console.log(result1);//true

filter函数利用指定的函数确定是否在返回的数组中包含一项，并形成新的数组。

var array=[1,2,3,4,5];
var array1=array.filter(function(value,index,array){
return value>2;
});
console.log(array1.toString());//3,4,5

上面的代码对array进行了filter过滤，返回所有大于2的项，形成新的数组。
map方法也返回一个新的数组，但是这个新的数组的每一项都是对原来的每一项元素执行了指定的函数。

var array=[1,2,3,4,5];
var array1=array.map(function(value,index,array){
                    return value*2;
                });
console.log(array1.toString());//2,4,6,8,10

上面的代码对array进行了map方法，返回了新的数组，在原来的数组每一项乘2.
forEach方法，对数组的每一项执行传入的函数。没有返回值，与for循环类似。

var array=[1,2,3,4,5];
array.forEach(function(value,index,array){
console.log(value);
});

 可以自己上述5个重写。因为有的浏览器不支持上述5个方法


              Array.prototype.every=function(func){
                    var result=false;
                    for(var i=0,len=this.length;i<len;i++){
                     result=func(this[i],i,this);
                     if(result==false){
                         return false;
                     }
                    }
                    return true;
                }
        Array.prototype.some=function(func){
                    var result=false;
                    for(var i=0,len=this.length;i<len;i++){
                     result=func(this[i],i,this);
                     if(result==true){
                         return true;
                     }
                    }
                    return false;
                }
        Array.prototype.filter=function(func){
                    var result=[];
                    for(var i=0,len=this.length;i<len;i++){
                     var flag=func(this[i],i,this);
                     if(flag){
                         result.push(this[i]);
                     }
                    }
                    return result;
                }
        Array.prototype.map=function(func){
                    var result=[];
                    for(var i=0,len=this.length;i<len;i++){
                     var flag=func(this[i],i,this);
                         result.push(flag);
                    }
                    return result;
                }
        Array.prototype.forEach=function(func){
                    
                    for(var i=0,len=this.length;i<len;i++){
                    func(this[i],i,this);
                    }

                }

View Code
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/ggz19/p/8176502.html
====================================================================================================
Python 项目实践三（Web应用程序）第一篇
****************************************************************************************************
一 Djangao入门
当今的网站实际上都是富应用程序（rich application），就像成熟的桌面应用程序一样。Python提供了一组开发Web应用程序的卓越工具。在本章中，你将学习如何使用Django（http://djangoproject.com/）来开发一个名为“学习笔记”（Learning Log）的项目，这是一个在线日志系统，让你能够记录所学习的有关特定主题的知识。我们将为这个项目制定规范，然后为应用程序使用的数据定义模型。我们将使用Django的管理系统来输入一些初始数据，再学习编写视图和模板，让Django能够为我们的网站创建网页。Django是一个Web框架——一套用于帮助开发交互式网站的工具。Django能够响应网页请求，还能让你更轻松地读写数据库、管理用户等。
1 准备工作
1.1 建立虚拟环境
要使用Django，首先需要建立一个虚拟工作环境。虚拟环境是系统的一个位置，你可以在其中安装包，并将其与其他Python包隔离。将项目的库与其他项目分离是有益的，且为了以后将“学习笔记”部署到服务器，这也是必须的。
为项目新建一个目录，将其命名为learning_log，再在终端中切换到这个目录，并创建一个虚拟环境。如果你使用的是Python 3，可使用如下命令来创建虚拟环境：
learning_log$ python -m venv ll_env
1.2 激活虚拟环境
建立虚拟环境后，需要使用下面的命令激活它：
命令ll_env\Scripts\activate
1.3 安装Django
(ll_env)learning_log$ pip install Django
以上三个步骤在我电脑操作为下图：

1.4 在Django中创建项目
在依然处于活动的虚拟环境的情况下（ll_env包含在括号内），执行如下命令来新建一个项目：
(ll_env)learning_log$ django-admin.py startproject learning_log .
(ll_env)learning_log$ lslearning_log ll_env manage.py (ll_env)learning_log$ ls learning_log__init__.py settings.py urls.py wsgi.py
django-admin.py startproject learning_log .让Django新建一个名为learning_log的项目。这个命令末尾的句点让新项目使用合适的目录结构，这样开发完成后可轻松地将应用程序部署到服务器。
运行了命令ls（在Windows系统上应为dir），结果表明Django新建了一个名为learning_log的目录。它还创建了一个名为manage.py的文件，这是一个简单的程序，它接受命令并将其交给Django的相关部分去运行。我们将使用这些命令来管理诸如使用数据库和运行服务器等任务。
目录learning_log包含4个文件，其中最重要的是settings.py、urls.py和wsgi.py。文件settings.py指定Django如何与你的系统交互以及如何管理项目。在开发项目的过程中，我们将修改其中一些设置，并添加一些设置。文件urls.py告诉Django应创建哪些网页来响应浏览器请求。文件wsgi.py帮助Django提供它创建的文件，这个文件名是web server gateway interface（Web服务器网关接口）的首字母缩写。如下图：

1.5 创建数据库
Django将大部分与项目相关的信息都存储在数据库中，因此我们需要创建一个供Django使用的数据库。为给项目“学习笔记”创建数据库，请在处于活动虚拟环境中的情况下执行下面的命令：(11_env) D:\study\python\code\learning_log> python manage.py migrate
如下图：
 
我们将修改数据库称为迁移数据库。首次执行命令migrate时，将让Django确保数据库与项目的当前状态匹配。在使用SQLite（后面将更详细地介绍）的新项目中首次执行这个命令时，Django将新建一个数据库。Django指出它将创建必要的数据库表，用于存储我们将在这个项目（Synchronize unmigrated apps，同步未迁移的应用程序）中使用的信息，再确保数据库结构与当前代码（Apply all migrations，应用所有的迁移）匹配。Django又创建了一个文件——db.sqlite3。SQLite是一种使用单个文件的数据库，是编写简单应用程序的理想选择，因为它让你不用太关注数据库管理的问题。
1.6 检查项目
下面来核实Django是否正确地创建了项目。为此，可执行命令runserver，如下所示：

Django启动一个服务器，让你能够查看系统中的项目，了解它们的工作情况。当你在浏览器中输入URL以请求网页时，该Django服务器将进行响应：生成合适的网页，并将其发送给浏览器。
 现在打开一款Web浏览器，并输入URL：http://localhost:8000/；如果这不管用，请输入http://127.0.0.1:8000/。如下图：

2 创建应用程序
Django项目由一系列应用程序组成，它们协同工作，让项目成为一个整体。我们暂时只创建一个应用程序，它将完成项目的大部分工作。在后面，我们将再添加一个管理用户账户的应用程序。当前，在前面打开的终端窗口中应该还运行着runserver。请再打开一个终端窗口（或标签页），并切换到manage.py所在的目录。激活该虚拟环境，再执行命令startapp：

D:\study\python\code\learning_log>D:\study\python\code\learning_log\11_env\Scripts\activate
(11_env) D:\study\python\code\learning_log>dir
 Volume in drive D is New Volume
 Volume Serial Number is 98C0-1AEA

 Directory of D:\study\python\code\learning_log

01/02/2018  04:11 PM    <DIR>          .
01/02/2018  04:11 PM    <DIR>          ..
01/02/2018  03:56 PM    <DIR>          11_env
01/02/2018  04:11 PM           131,072 db.sqlite3
01/02/2018  04:11 PM    <DIR>          learning_log
01/02/2018  04:02 PM               559 manage.py
               2 File(s)        131,631 bytes
               4 Dir(s)  955,714,387,968 bytes free

(11_env) D:\study\python\code\learning_log>python manage.py startapp learning_logs

(11_env) D:\study\python\code\learning_log>dir
 Volume in drive D is New Volume
 Volume Serial Number is 98C0-1AEA

 Directory of D:\study\python\code\learning_log

01/02/2018  04:31 PM    <DIR>          .
01/02/2018  04:31 PM    <DIR>          ..
01/02/2018  03:56 PM    <DIR>          11_env
01/02/2018  04:11 PM           131,072 db.sqlite3
01/02/2018  04:11 PM    <DIR>          learning_log
01/02/2018  04:31 PM    <DIR>          learning_logs
01/02/2018  04:02 PM               559 manage.py
               2 File(s)        131,631 bytes
               5 Dir(s)  955,714,383,872 bytes free

(11_env) D:\study\python\code\learning_log>dir learning_logs
 Volume in drive D is New Volume
 Volume Serial Number is 98C0-1AEA

 Directory of D:\study\python\code\learning_log\learning_logs

01/02/2018  04:31 PM    <DIR>          .
01/02/2018  04:31 PM    <DIR>          ..
01/02/2018  04:31 PM                66 admin.py
01/02/2018  04:31 PM               105 apps.py
01/02/2018  04:31 PM    <DIR>          migrations
01/02/2018  04:31 PM                60 models.py
01/02/2018  04:31 PM                63 tests.py
01/02/2018  04:31 PM                66 views.py
01/02/2018  04:31 PM                 0 __init__.py
               6 File(s)            360 bytes
               3 Dir(s)  955,714,383,872 bytes free

(11_env) D:\study\python\code\learning_log>


命令startapp appname让Django建立创建应用程序所需的基础设施。如果现在查看项目目录，将看到其中新增了一个文件夹learning_logs。打开这个文件夹，看看Django都创建了什么。其中最重要的文件是models.py、admin.py和views.py。我们将使用models.py来定义我们要在应用程序中管理的数据。admin.py和views.py将在稍后介绍。
2.1 定义模型
我们来想想涉及的数据。每位用户都需要在学习笔记中创建很多主题。用户输入的每个条目都与特定主题相关联，这些条目将以文本的方式显示。我们还需要存储每个条目的时间戳，以便能够告诉用户各个条目都是什么时候创建的。

from django.db import models

# Create your models here.

class Topic(models.Model):
    '''用户学习的主题'''
    text = models.CharField(max_length=200)
    date_added = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        '''返回模型的字符串表示'''
        return self.text


（1）导入了模块models，还让我们创建自己的模型。模型告诉Django如何处理应用程序中存储的数据。在代码层面，模型就是一个类，就像前面讨论的每个类一样，包含属性和方法。（2）Topic类，它继承了Model——Django中一个定义了模型基本功能的类。Topic类只有两个属性：text和date_added。
2.2 激活模型
要使用模型，必须让Django将应用程序包含到项目中。为此，打开settings.py（它位于目录learning_log/learning_log中），你将看到一个这样的片段，即告诉Django哪些应用程序安装在项目中：

# Application definition
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    #我的应用程序
    'learning_logs'
]


这是一个元组，告诉Django项目是由哪些应用程序组成的。请在INSTALLED_APPS中添加：

#我的应用程序
'learning_logs'


接下来，需要让Django修改数据库，使其能够存储与模型Topic相关的信息。为此，在终端窗口中执行下面的命令：

(11_env) D:\study\python\code\learning_log>python manage.py makemigrations learning_logs
Migrations for 'learning_logs':
  learning_logs\migrations\0001_initial.py
    - Create model Topic

(11_env) D:\study\python\code\learning_log>


命令makemigrations让Django确定该如何修改数据库，使其能够存储与我们定义的新模型相关联的数据。输出表明Django创建了一个名为0001_initial.py的迁移文件，这个文件将在数据库中为模型Topic创建一个表。下面来应用这种迁移，让Django替我们修改数据库：

这个命令的大部分输出都与我们首次执行命令migrate的输出相同。我们需要检查的是最后的输出行，在这里，Django确认为learning_logs应用迁移时一切正常（OK），每当需要修改“学习笔记”管理的数据时，都采取如下三个步骤：修改models.py；对learning_logs调用makemigrations；让Django迁移项目。
2.3 Django管理网站
为应用程序定义模型时，Django提供的管理网站（admin site）让你能够轻松地处理模型。网站的管理员可使用管理网站，但普通用户不能使用。在本节中，我们将建立管理网站，并通过它使用模型Topic来添加一些主题。
2.3.1 创建超级用户
Django允许你创建具备所有权限的用户——超级用户。权限决定了用户可执行的操作。为在Django中创建超级用户，请执行下面的命令并按提示做：

密码为：admin123456
2.3.2 向网站注册模型
Django自动在管理网站中添加了一些模型，如User和Group，但对于我们创建的模型，必须手工进行注册。我们创建应用程序learning_logs时，Django在models.py所在的目录中创建了一个名为admin.py的文件,为向管理网站注册Topic，请输入下面的代码：

from django.contrib import admin

# Register your models here.

from learning_logs.models import Topic

admin.site.register(Topic)


这些代码导入我们要注册的模型Topic，再使用admin.site.register()让Django通过管理网站管理我们的模型。现在，使用超级用户账户访问管理网站：访问http://localhost:8000/admin/，并输入你刚创建的超级用户的用户名和密码，这个网页让你能够添加和修改用户和用户组，还可以管理与刚才定义的模型Topic相关的数据.如下2.3.3 添加主题
单击Topics进入主题网页，它几乎是空的，这是因为我们还没有添加任何主题。单击Add，你将看到一个用于添加新主题的表单。在第一个方框中输入Chess，再单击Save，这将返回到主题管理页面，其中包含刚创建的主题。下面再创建一个主题，以便有更多的数据可供使用。再次单击Add，并创建另一个主题RockClimbing。当你单击Save时，将重新回到主题管理页面，其中包含主题Chess和Rock Climbing。如下图：

 2.4 定义模型Entry
要记录学到的国际象棋和攀岩知识，需要为用户可在学习笔记中添加的条目定义模型。每个条目都与特定主题相关联，这种关系被称为多对一关系，即多个条目可关联到同一个主题。下面是模型Entry的代码：

from django.db import models

# Create your models here.

class Topic(models.Model):
    '''用户学习的主题'''
    text = models.CharField(max_length=200)
    date_added = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        '''返回模型的字符串表示'''
        return self.text

class Entry(models.Model):
    '''学到的有关某个主题的具体知识'''
    topic = models.ForeignKey(Topic,on_delete=models.CASCADE)
    text = models.TextField()
    date_added = models.DateTimeField(auto_now_add=True)

    class Meta:
        verbose_name_plural ='entries'

    def __str__(self):
        """返回模型的字符串表示"""
        return self.text[:50] + "..."


书中这句date_added = models.DateTimeField(auto_now_add=True)会报错，改成上面的即可。
2.5迁移模型
由于我们添加了一个新模型，因此需要再次迁移数据库。你将慢慢地对这个过程了如指掌：修改models.py ， 执行命令python manage.py makemigrations app_name ， 再执行命令pythonmanage.py migrate。

2.6 向管理网站注册Entry
我们还需要注册模型Entry。为此，需要将admin.py修改成类似于下面这样：

from django.contrib import admin
from learning_logs.models import Topic, Entry
admin.site.register(Topic)
admin.site.register(Entry)


返回到http://localhost/admin/，你将看到learning_logs下列出了Entries。单击Entries的Add链接，或者单击Entries再选择Add entry。你将看到一个下拉列表，让你能够选择要为哪个主题创建条目，还有一个用于输入条目的文本框。从下拉列表中选择Chess，并添加一个条目。下面是我添加的第一个条目。

再来创建一个国际象棋条目，并创建一个攀岩条目，以提供一些初始数据。下面是第二个国际象棋条目。继续往下开发“学习笔记”时，这三个条目可为我们提供使用的数据。

2.7 Django shell
输入一些数据后，就可通过交互式终端会话以编程方式查看这些数据了。这种交互式环境称为Django shell，是测试项目和排除其故障的理想之地。下面是一个交互式shell会话示例：

在活动的虚拟环境中执行时，命令python manage.py shell启动一个Python解释器，可使用它来探索存储在项目数据库中的数据。
今天就先写到这里吧，有空继续学习！
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/majianchao/p/8178545.html
====================================================================================================
前端学数据结构之链表
****************************************************************************************************
前面的话
　　本文将介绍如何实现和使用链表这种动态的数据结构
 
数据结构
　　要存储多个元素，数组（或列表）可能是最常用的数据结构。每种语言都实现了数组。这种数据结构非常方便，提供了一个便利的[]语法来访问它的元素。然而，这种数据结构有一个缺点：（在大多数语言中）数组的大小是固定的，从数组的起点或中间插入或移除项的成本很高，因为需要移动元素
　　链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个元素由一个存储元素本身的节点和一个指向下一个元素的引用（也称指针或链接）组成。下图展示了一个链表的结构：

　　相对于传统的数组，链表的一个好处在于，添加或移除元素的时候不需要移动其他元素。然而，链表需要使用指针，因此实现链表时需要额外注意。数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点（表头）开始迭代列表直到找到所需的元素
　　现实中也有一些链表的例子。第一个例子就是康加舞队。每个人是一个元素，手就是链向下一个人的指针。可以向队列中增加人——只需要找到想加入的点，断开连接，插入一个人，再重新连接起来
　　另一个例子是寻宝游戏。你有一条线索，这条线索是指向寻找下一条线索的地点的指针。你顺着这条链接去下一个地点，得到另一条指向再下一处的线索。得到列表中间的线索的唯一办法，就是从起点（第一条线索）顺着列表寻找
　　还有一个可能是用来说明链表的最流行的例子，那就是火车。一列火车是由一系列车厢（也称车皮）组成的。每节车厢或车皮都相互连接。你很容易分离一节车皮，改变它的位置，添加或移除它。下图演示了一列火车。每节车皮都是列表的元素，车皮间的连接就是指针：

 
创建链表
　　理解了链表是什么之后，现在就要开始实现我们的数据结构了。以下是我们的LinkedList 类的骨架：

function LinkedList() {
  var Node = function(element){ // {1} 
    this.element = element; 
    this.next = null;
  };
  var length = 0; // {2} 
  var head = null; // {3}
  this.append = function(element){}; 
  this.insert = function(position, element){}; 
  this.removeAt = function(position){}; 
  this.remove = function(element){}; 
  this.indexOf = function(element){}; 
  this.isEmpty = function() {};
  this.size = function() {}; 
  this.toString = function(){}; 
  this.print = function(){};
}

　　LinkedList数据结构还需要一个Node辅助类（行{1}）。Node类表示要加入列表的项。它包含一个element属性，即要添加到列表的值，以及一个next属性，即指向列表中下一个节点项的指针
　　LinkedList类也有存储列表项的数量的length属性（内部/私有变量）（行{2}）。另一个重要的点是，我们还需要存储第一个节点的引用。为此，可以把这个引用存储在一个称为head的变量中（行{3}）
　　然后就是LinkedList类的方法。在实现这些方法之前，先来看看它们的职责

append(element)：向列表尾部添加一个新的项。
insert(position, element)：向列表的特定位置插入一个新的项。
remove(element)：从列表中移除一项。
indexOf(element)：返回元素在列表中的索引。如果列表中没有该元素则返回-1。
removeAt(position)：从列表的特定位置移除一项。
isEmpty()：如果链表中不包含任何元素，返回true，如果链表长度大于0则返回false。
size()：返回链表包含的元素个数。与数组的length属性类似。
toString() ：由 于列表项使 用了 Node 类 ，就 需要重写 继承自 JavaScript对 象默认 的
toString方法，让其只输出元素的值。

【append】
　　向LinkedList对象尾部添加一个元素时，可能有两种场景：列表为空，添加的是第一个元素，或者列表不为空，向其追加元素
　　下面是我们实现的append方法：

this.append = function(element){

  var node = new Node(element), //{1} 
      current; //{2}

  if (head === null){ //列表中第一个节点  //{3} 
    head = node;
  } else {
    current = head; //{4}
    //循环列表，直到找到最后一项 
    while(current.next){
      current = current.next;
    }
    //找到最后一项，将其next赋为node，建立链接
    current.next = node; //{5}
  }
  length++; //更新列表的长度  //{6}
};

　　首先需要做的是把element作为值传入，创建Node项（行{1}）
　　先来实现第一个场景：向为空的列表添加一个元素。当我们创建一个LinkedList对象时，head会指向null：

　　如果head元素为null（列表为空——行{3}），就意味着在向列表添加第一个元素。因此要做的就是让head元素指向node元素。下一个node元素将会自动成为null
　　第二个场景是向一个不为空的列表尾部添加元素
　　要向列表的尾部添加一个元素，首先需要找到最后一个元素。记住，我们只有第一个元素的引用（行{4}），因此需要循环访问列表，直到找到最后一项。为此，我们需要一个指向列表中current项的变量（行{2}）。循环访问列表时，当current.next元素为null时，我们就知道已经到达列表尾部了。然后要做的就是让当前（也就是最后一个）元素的next指针指向想要添加到列表的节点（行{5}）。下图展示了这个行为：

　　当一个Node元素被创建时，它的next指针总是null。这没问题，因为我们知道它会是列表的最后一项。当然，别忘了递增列表的长度，这样就能控制它，轻松地得到列表的长度（行{6}）。 我们可以通过以下代码来使用和测试目前创建的数据结构

var list = new LinkedList(); 
list.append(15); 
list.append(10);

【remove】
　　现在，让我们看看如何从LinkedList对象中移除元素。移除元素也有两种场景：第一种是移除第一个元素，第二种是移除第一个以外的任一元素。我们要实现两种remove方法：第一种是从特定位置移除一个元素，第二种是根据元素的值移除元素（稍后会展示第二种remove方法）
　　下面是根据给定位置移除一个元素的方法的实现：

this.removeAt = function(position){
  //检查越界值
  if (position > -1 && position < length){ // {1} 
    var current = head, // {2}
    previous, // {3}
    index = 0; // {4}
    //移除第一项
    if (position === 0){ // {5} 
      head = current.next;
    } else {
      while (index++ < position){ // {6}
        previous = current;    // {7} 
        current = current.next; // {8}
      }
      //将previous与current的下一项链接起来：跳过current，从而移除它 
      previous.next = current.next; // {9}
    }
    length--; // {10} 
    return current.element;
  } else {
    return null; // {11}
  }
};

　　该方法要得到需要移除的元素的位置，就需要验证这个位置是有效的（行{1}）。从0（包括0）到列表的长度（size – 1，因为索引是从零开始的）都是有效的位置。如果不是有效的位置，就返回null（意即没有从列表中移除元素）
　　下面来为第一种场景编写代码：我们要从列表中移除第一个元素（position === 0——行{5}）。下图展示了这个过程：

　　因此，如果想移除第一个元素，要做的就是让head指向列表的第二个元素。我们将用current变量创建一个对列表中第一个元素的引用（行{2}）。这样 current 变量就是对列表中第一个元素的引用。如果把 head 赋为current.next，就会移除第一个元素。
　　现在，假设我们要移除列表的最后一项或者中间某一项。为此，需要依靠一个细节来迭代列表，直到到达目标位置（行{6}——我们会使用一个用于内部控制和递增的index变量）：current 变量总是为对所循环列表的当前元素的引用（行{8}）。我们还需要一个对当前元素的前一个元 素的引用（行{7}）；它被命名为previous（行{3}）。
　　因此，要从列表中移除当前元素，要做的就是将previous.next和current.next链接起 来（行{9}）。这样，当前元素就会被丢弃在计算机内存中，等着被垃圾回收器清除
　　下面试着通过一些图表来更好地理解。首先考虑移除最后一个元素：

　　对于最后一个元素，当我们在行{6}跳出循环时，current变量将是对列表中最后一个元素的引用（要移除的元素）。current.next的值将是null（因为它是最后一个元素）。由于还保留了对previous元素的引用（当前元素的前一个元素），previous.next就指向了current。那么要移除current，要做的就是把previous.next的值改变为current.next
　　现在来看看，对于列表中间的元素是否可以应用相同的逻辑：

　　current变量是对要移除元素的引用。previous变量是对要移除元素的前一个元素的引用。 那么要移除current元素，需要做的就是将previous.next与current.next链接起来。因此，我们的逻辑对这两种情况都管用
【insert】
　　接下来，我们要实现insert方法。使用这个方法可以在任意位置插入一个元素。下面来看一看它的实现

this.insert = function(position, element){
  //检查越界值
  if (position >= 0 && position <= length){ //{1}
    var node = new Node(element), 
        current = head,
        previous, 
        index = 0;
    if (position === 0){ //在第一个位置添加 
      node.next = current; //{2}
      head = node;
    } else {
      while (index++ < position){ //{3} 
        previous = current;
        current = current.next;
      }
      node.next = current; //{4} 
      previous.next = node; //{5}
    }
    length++; //更新列表的长度
    return true;
  } else {
    return false; //{6}
  }
};

　　由于处理的是位置，就需要检查越界值（行{1}，跟remove方法类似）。如果越界了， 就返回false值，表示没有添加项到列表中（行{6}）
　　现在要处理不同的场景。第一种场景，需要在列表的起点添加一个元素，也就是第一个位置。下图展示了这种场景

　　current变量是对列表中第一个元素的引用。我们需要做的是把node.next的值设为current（列表中第一个元素）。现在head和node.next都指向了current。接下来要做的就是把head的引用改为node（行{2}），这样列表中就有了一个新元素
　　现在来处理第二种场景：在列表中间或尾部添加一个元素。首先，我们需要循环访问列表， 找到目标位置（行{3}）。当跳出循环时，current变量将是对想要插入新元素的位置之后一个元素的引用，而previous将是对想要插入新元素的位置之前一个元素的引用。在这种情况下，我们要在previous和current之间添加新项。因此，首先需要把新项（node）和当前项链接起来（行{4}），然后需要改变previous和current之间的链接。我们还需要让previous.next指向node（行{5}）
　　我们通过一张图表来看看代码所做的事：

　　如果我们试图向最后一个位置添加一个新元素，previous将是对列表最后一项的引用，而current将是null。在这种情况下，node.next将指向current，而previous.next将指向 node，这样列表中就有了一个新的项
　　现在来看看如何向列表中间添加一个新元素

　　在这种情况下，我们试图将新的项（node）插入到previous和current元素之间。首先， 我们需要把node.next的值指向current。然后把previous.next的值设为node。这样列表中就有了一个新的项
【toString】
　　toString方法会把LinkedList对象转换成一个字符串。下面是toString方法的实现：

this.toString = function(){
 let current = head, //{1}
 string = ''; //{2}
 while (current) { //{3}
  string +=current.element +(current.next ? 'n' : '');//{4}
  current = current.next; //{5}
 }
 return string; //{6}
}; 

　　首先，要循环访问列表中的所有元素，就需要有一个起点，也就是head。我们会把current 变量当作索引（行{1}），控制循环访问列表。我们还需要初始化用于拼接元素值的变量（行{2}）。
　　接下来就是循环访问列表中的每个元素（行{3}）。我们要用current来检查元素是否存在（如果列表为空，或是到达列表中最后一个元素的下一位（null），while循环中的代码就不会执行）。然后我们就得到了元素的内容，将其拼接到字符串中（行{4}）。最后，继续迭代下一个元 素（行{5}）。最后，返回列表内容的字符串（行{6}）
【indexOf】
　　indexOf是我们下一个要实现的方法。indexOf方法接收一个元素的值，如果在列表中找到它，就返回元素的位置，否则返回-1。下面来看看它的实现：

this.indexOf = function(element){
 let current = head, //{1}
 index = -1;
 while (current) { //{2}
  if (element === current.element) {
    return index; //{3}
  }
  index++; //{4}
  current = current.next; //{5}
 }
 return -1;
};

　　我们需要一个变量来帮助循环访问列表，这个变量是current，它的初始值是head（列表的第一个元素——我们还需要一个index变量来计算位置数（行{1}））。然后循环访问元素（行{2}），检查当前元素是否是我们要找的。如果是，就返回它的位置（行{3}）；如果不是，就继续计数（行{4}），检查列表中下一个节点（行{5}）
　　如果列表为空，或是到达列表的尾部（current = current.next将是null），循环就不会执行。如果没有找到值，就返回-1
【remove】
　　实现了indexOf方法，我们就可以实现remove等其他的方法：

this.remove = function(element){
  var index = this.indexOf(element); 
  return this.removeAt(index);
};

　　我们已经有一个移除给定位置的一个元素的removeAt方法了。现在有了indexOf方法，如果传入元素的值，就能找到它的位置，然后调用removeAt方法并传入找到的位置。这样非常简单，如果需要更改removeAt方法的代码，这样也更容易——两个方法都会被更改（这就是重用代码的妙处）。这样，我们就不需要维护两个从列表中移除一项的方法，只需要一个！同时， removeAt方法将会检查边界约束
【isEmpty】

this.isEmpty = function() { 
  return length === 0;
};

【size】

this.size = function() { 
  return length;
};

【getHead】
　　head变量是LinkedList类的私有变量（这意味着它不能在LinkedList实例外部被访问和更改，只有通过LinkedList实例才可以）。但是，如果我们需要在类的实现外部循环访问列表，就需要提供一种获取类的第一个元素的方法

this.getHead = function(){ 
  return head;
};

【完整代码】
　　链表的完整代码如下

function LinkedList() {

    let Node = function(element){

        this.element = element;
        this.next = null;
    };

    let length = 0;
    let head = null;

    this.append = function(element){

        let node = new Node(element),
            current;

        if (head === null){ //first node on list
            head = node;
        } else {

            current = head;

            //loop the list until find last item
            while(current.next){
                current = current.next;
            }

            //get last item and assign next to added item to make the link
            current.next = node;
        }

        length++; //update size of list
    };

    this.insert = function(position, element){

        //check for out-of-bounds values
        if (position >= 0 && position <= length){

            let node = new Node(element),
                current = head,
                previous,
                index = 0;

            if (position === 0){ //add on first position

                node.next = current;
                head = node;

            } else {
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
            }

            length++; //update size of list

            return true;

        } else {
            return false;
        }
    };

    this.removeAt = function(position){

        //check for out-of-bounds values
        if (position > -1 && position < length){

            let current = head,
                previous,
                index = 0;

            //removing first item
            if (position === 0){
                head = current.next;
            } else {

                while (index++ < position){

                    previous = current;
                    current = current.next;
                }

                //link previous with current's next - skip it to remove
                previous.next = current.next;
            }

            length--;

            return current.element;

        } else {
            return null;
        }
    };

    this.remove = function(element){

        let index = this.indexOf(element);
        return this.removeAt(index);
    };

    this.indexOf = function(element){

        let current = head,
            index = 0;

        while (current) {
            if (element === current.element) {
                return index;
            }
            index++;
            current = current.next;
        }

        return -1;
    };

    this.isEmpty = function() {
        return length === 0;
    };

    this.size = function() {
        return length;
    };

    this.getHead = function(){
        return head;
    };

    this.toString = function(){

        let current = head,
            string = '';

        while (current) {
            string += current.element + (current.next ? ', ' : '');
            current = current.next;
        }
        return string;

    };

    this.print = function(){
        console.log(this.toString());
    };
}

【ES6】
　　ES6版本的代码如下

let LinkedList2 = (function () {

    class Node {
        constructor(element){
            this.element = element;
            this.next = null;
        }
    }

    const length = new WeakMap();
    const head = new WeakMap();

    class LinkedList2 {

        constructor () {
            length.set(this, 0);
            head.set(this, null);
        }

        append(element) {

            let node = new Node(element),
                current;

            if (this.getHead() === null) { //first node on list
                head.set(this, node);
            } else {

                current = this.getHead();

                //loop the list until find last item
                while (current.next) {
                    current = current.next;
                }

                //get last item and assign next to added item to make the link
                current.next = node;
            }

            //update size of list
            let l = this.size();
            l++;
            length.set(this, l);
        }

        insert(position, element) {

            //check for out-of-bounds values
            if (position >= 0 && position <= this.size()) {

                let node = new Node(element),
                    current = this.getHead(),
                    previous,
                    index = 0;

                if (position === 0) { //add on first position

                    node.next = current;
                    head.set(this, node);

                } else {
                    while (index++ < position) {
                        previous = current;
                        current = current.next;
                    }
                    node.next = current;
                    previous.next = node;
                }

                //update size of list
                let l = this.size();
                l++;
                length.set(this, l);

                return true;

            } else {
                return false;
            }
        }

        removeAt(position) {

            //check for out-of-bounds values
            if (position > -1 && position < this.size()) {

                let current = this.getHead(),
                    previous,
                    index = 0;

                //removing first item
                if (position === 0) {
                    head.set(this, current.next);
                } else {

                    while (index++ < position) {

                        previous = current;
                        current = current.next;
                    }

                    //link previous with current's next - skip it to remove
                    previous.next = current.next;
                }

                let l = this.size();
                l--;
                length.set(this, l);

                return current.element;

            } else {
                return null;
            }
        }

        remove(element) {

            let index = this.indexOf(element);
            return this.removeAt(index);
        }

        indexOf(element) {

            let current = this.getHead(),
                index = 0;

            while (current) {
                if (element === current.element) {
                    return index;
                }
                index++;
                current = current.next;
            }

            return -1;
        }

        isEmpty() {
            return this.size() === 0;
        }

        size() {
            return length.get(this);
        }

        getHead() {
            return head.get(this);
        }

        toString() {

            let current = this.getHead(),
                string = '';

            while (current) {
                string += current.element + (current.next ? ', ' : '');
                current = current.next;
            }
            return string;

        }

        print() {
            console.log(this.toString());
        }
    }

    return LinkedList2;
})();

 
双向链表
　　链表有多种不同的类型，下面将介绍双向链表。双向链表和普通链表的区别在于，在链表中，一个节点只有链向下一个节点的链接，而在双向链表中，链接是双向的：一个链向下一个元素， 另一个链向前一个元素，如下图所示：

　　先从实现DoublyLinkedList类所需的变动开始：

function DoublyLinkedList() {
 let Node = function(element){
  this.element = element;
  this.next = null;
  this.prev = null; //新增的
 };
 let length = 0;
 let head = null;
 let tail = null; //新增的
 //这里是方法
} 

　　在代码中可以看到，LinkedList类和DoublyLinkedList类之间的区别标为新增的。在Node类里有prev属性（一个新指针），在DoublyLinkedList类里也有用来保存对列表最后一项的引用的tail属性
　　双向链表提供了两种迭代列表的方法：从头到尾，或者反过来。我们也可以访问一个特定节点的下一个或前一个元素。在单向链表中，如果迭代列表时错过了要找的元素，就需要回到列表起点，重新开始迭代。这是双向链表的一个优点
【insert】
　　向双向链表中插入一个新项跟（单向）链表非常类似。区别在于，链表只要控制一个next指针，而双向链表则要同时控制next和prev（previous，前一个）这两个指针
　　这是向任意位置插入一个新元素的算法

this.insert = function(position, element){
 //检查越界值
 if (position >= 0 && position <= length){
  let node = new Node(element),
      current = head,
      previous,
      index = 0;
  if (position === 0){ //在第一个位置添加
    if (!head){ //新增的 {1}
      head = node;
      tail = node;
    } else {
      node.next = current;
      current.prev = node; //新增的 {2}
      head = node;
    }
  } else if (position === length) { //最后一项 //新增的
    current = tail; // {3}
    current.next = node;
    node.prev = current;
    tail = node;
  } else {
    while (index++ < position){ //{4}
      previous = current;
      current = current.next;
    }
    node.next = current; //{5}
    previous.next = node;
    current.prev = node; //新增的
    node.prev = previous; //新增的
  }
  length++; //更新列表的长度
  return true;
 } else {
  return false;
 }
}; 

　　我们来分析第一种场景：在列表的第一个位置（列表的起点）插入一个新元素。如果列表为空（行{1}），只需要把head和tail都指向这个新节点。如果不为空，current变量将是对列表中第一个元素的引用。就像我们在链表中所做的，把node.next设为current，而head将指向node（它将成为列表中的第一个元素）。不同之处在于，我们还需要为指向上一个元素的指针设一个值。current.prev指针将由指向null变为指向新元素（node——行{2}）。node.prev指针已经是null，因此不需要再更新任何东西
　　下图演示了这个过程：

　　现在来分析一下，假如我们要在列表最后添加一个新元素。这是一个特殊情况，因为我们还控制着指向最后一个元素的指针（tail）。current变量将引用最后一个元素（行{3}）。然后开始建立第一个链接：node.prev将引用current。current.next指针（指向null）将指向node（由于构造函数，node.next已经指向了null）。然后只剩一件事了，就是更新tail，它将由指向current变为指向node。下图展示了这些行为

　　然后还有第三种场景：在列表中间插入一个新元素。就像我们在之前的方法中所做的迭代列表，直到到达要找的位置（行{4}）。我们将在current和previous元素之间插入新元素。首先，node.next将指向current（行{5}），而previous.next将指向node，这样就不会丢失节点之间的链接。然后需要处理所有的链接：current.prev将指向node，而node.prev将指向 previous。下图展示了这一过程：

【removeAt】
　　从双向链表中移除元素跟链表非常类似。唯一的区别就是还需要设置前一个位置的指针。下面来看一下它的实现：

this.removeAt = function(position){
 //检查越界值
 if (position > -1 && position < length){
  let current = head,
      previous,
      index = 0;
  //移除第一项
  if (position === 0){
    head = current.next; // {1}
    //如果只有一项，更新tail //新增的
    if (length === 1){ // {2}
     tail = null;
    } else {
     head.prev = null; // {3}
    }
  } else if (position === length-1){ //最后一项 //新增的
    current = tail; // {4}
    tail = current.prev;
    tail.next = null;
  } else {
    while (index++ < position){ // {5}
      previous = current;
      current = current.next;
    }
    //将previous与current的下一项链接起来——跳过current
    previous.next = current.next; // {6}
    current.next.prev = previous; //新增的
  }
  length--;
  return current.element;
 } else {
  return null;
 }
}; 

　　我们需要处理三种场景：从头部、从中间和从尾部移除一个元素。 下面来看看如何移除第一个元素。current变量是对列表中第一个元素的引用，也就是我们想移除的元素。需要做的就是改变 head 的引用，将其从current 改为下一个元素（current.next——行{1}）。但我们还需要更新current.next指向上一个元素的指针（因为第一个元素的prev指针是null）。因此，把head.prev的引用改为null（行{3}——因为head也指向列表中新的第一个元素，或者也可以用current.next.prev）。由于还需要控制tail的引用，我们可以检查要移除的元素是否是第一个元素，如果是，只需要把tail也设为null
　　下图勾画了从双向链表移除第一个元素的过程：

　　下一种场景是从最后一个位置移除元素。既然已经有了对最后一个元素的引用（tail），我们就不需要为找到它而迭代列表。这样我们也就可以把tail的引用赋给current变量（行{4}）。接下来，需要把tail的引用更新为列表中倒数第二个元素（current.prev，或者tail.prev 也可以）。既然tail指向了倒数第二个元素，我们就只需要把next指针更新为null（tail.next=null）。下图演示了这一行为：

　　第三种也是最后一种场景：从列表中间移除一个元素。首先需要迭代列表，直到到达要找的位置（行{5}）。current变量所引用的就是要移除的元素。那么要移除它，我们可以通过更新previous.next和current.next.prev的引用，在列表中跳过它。因此，previous.next将指向current.next，而current.next.prev将指向previous，如下图所示：

【完整代码】
　　双向链表的完整代码如下所示

function DoublyLinkedList() {

    let Node = function(element){

        this.element = element;
        this.next = null;
        this.prev = null; //NEW
    };

    let length = 0;
    let head = null;
    let tail = null; //NEW

    this.append = function(element){

        let node = new Node(element),
            current;

        if (head === null){ //first node on list
            head = node;
            tail = node; //NEW
        } else {

            //attach to the tail node //NEW
            tail.next = node;
            node.prev = tail;
            tail = node;
        }

        length++; //update size of list
    };

    this.insert = function(position, element){

        //check for out-of-bounds values
        if (position >= 0 && position <= length){

            let node = new Node(element),
                current = head,
                previous,
                index = 0;

            if (position === 0){ //add on first position

                if (!head){       //NEW
                    head = node;
                    tail = node;
                } else {
                    node.next = current;
                    current.prev = node; //NEW {1}
                    head = node;
                }

            } else  if (position === length) { //last item //NEW

                current = tail;     // {2}
                current.next = node;
                node.prev = current;
                tail = node;

            } else {
                while (index++ < position){ //{3}
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;

                current.prev = node; //NEW
                node.prev = previous; //NEW
            }

            length++; //update size of list

            return true;

        } else {
            return false;
        }
    };

    this.removeAt = function(position){

        //check for out-of-bounds values
        if (position > -1 && position < length){

            let current = head,
                previous,
                index = 0;

            //removing first item
            if (position === 0){

                head = current.next; // {1}

                //if there is only one item, then we update tail as well //NEW
                if (length === 1){ // {2}
                    tail = null;
                } else {
                    head.prev = null; // {3}
                }

            } else if (position === length-1){ //last item //NEW

                current = tail; // {4}
                tail = current.prev;
                tail.next = null;

            } else {

                while (index++ < position){ // {5}

                    previous = current;
                    current = current.next;
                }

                //link previous with current's next - skip it to remove
                previous.next = current.next; // {6}
                current.next.prev = previous; //NEW
            }

            length--;

            return current.element;

        } else {
            return null;
        }
    };

    this.remove = function(element){

        let index = this.indexOf(element);
        return this.removeAt(index);
    };

    this.indexOf = function(element){

        let current = head,
            index = -1;

        //check first item
        if (element == current.element){
            return 0;
        }

        index++;

        //check in the middle of the list
        while(current.next){

            if (element == current.element){
                return index;
            }

            current = current.next;
            index++;
        }

        //check last item
        if (element == current.element){
            return index;
        }

        return -1;
    };

    this.isEmpty = function() {
        return length === 0;
    };

    this. size = function() {
        return length;
    };

    this.toString = function(){

        let current = head,
            s = current ? current.element : '';

        while(current && current.next){
            current = current.next;
            s += ', ' + current.element;
        }

        return s;
    };

    this.inverseToString = function() {

        let current = tail,
            s = current ? current.element : '';

        while(current && current.prev){
            current = current.prev;
            s += ', ' + current.element;
        }

        return s;
    };

    this.print = function(){
        console.log(this.toString());
    };

    this.printInverse = function(){
        console.log(this.inverseToString());
    };

    this.getHead = function(){
        return head;
    };

    this.getTail = function(){
        return tail;
    }
}

【ES6】
　　ES6版本的代码如下所示

let DoublyLinkedList2 = (function () {

    class Node {
        constructor(element) {
            this.element = element;
            this.next = null;
            this.prev = null; //NEW
        }
    }

    const length = new WeakMap();
    const head = new WeakMap();
    const tail = new WeakMap(); //NEW

    class DoublyLinkedList2 {

        constructor () {
            length.set(this, 0);
            head.set(this, null);
            tail.set(this, null);
        }

        append(element) {

            let node = new Node(element),
                current, _tail;

            if (this.getHead() === null) { //first node on list
                head.set(this, node);
                tail.set(this, node); //NEW
            } else {
                //attach to the tail node //NEW
                _tail = this.getTail();
                _tail.next = node;
                node.prev = _tail;
                tail.set(this, node);
            }

            //update size of list
            let l = this.size();
            l++;
            length.set(this, l);
        }

        insert(position, element) {

            //check for out-of-bounds values
            if (position >= 0 && position <= this.size()) {

                let node = new Node(element),
                    current = this.getHead(),
                    previous,
                    index = 0;

                if (position === 0) { //add on first position

                    if (!this.getHead()) {       //NEW
                        head.set(this, node);
                        tail.set(this, node);
                    } else {
                        node.next = current;
                        current.prev = node; //NEW {1}
                        head.set(this, node);
                    }

                } else if (position === this.size()) { //last item //NEW

                    current = tail;     // {2}
                    current.next = node;
                    node.prev = current;
                    tail.set(this, node);

                } else {
                    while (index++ < position) { //{3}
                        previous = current;
                        current = current.next;
                    }
                    node.next = current;
                    previous.next = node;

                    current.prev = node; //NEW
                    node.prev = previous; //NEW
                }

                //update size of list
                let l = this.size();
                l++;
                length.set(this, l);

                return true;

            } else {
                return false;
            }
        }

        removeAt(position) {

            //check for out-of-bounds values
            if (position > -1 && position < this.size()) {

                let _head = this.getHead(),
                    _tail = this.getTail(),
                    current = _head,
                    previous,
                    index = 0;

                //removing first item
                if (position === 0) {

                    _head = current.next; // {1}

                    //if there is only one item, then we update tail as well //NEW
                    if (this.size() === 1) { // {2}
                        _tail = null;
                    } else {
                        _head.prev = null; // {3}
                    }

                } else if (position === this.size() - 1) { //last item //NEW

                    current = _tail; // {4}
                    _tail = current.prev;
                    _tail.next = null;

                } else {

                    while (index++ < position) { // {5}

                        previous = current;
                        current = current.next;
                    }

                    //link previous with current's next - skip it to remove
                    previous.next = current.next; // {6}
                    current.next.prev = previous; //NEW
                }

                head.set(this,_head);
                tail.set(this,_tail);

                //update size of list
                let l = this.size();
                l--;
                length.set(this, l);

                return current.element;

            } else {
                return null;
            }
        }

        remove(element) {

            let index = this.indexOf(element);
            return this.removeAt(index);
        }

        indexOf(element) {

            let current = this.getHead(),
                index = -1;

            //check first item
            if (element == current.element) {
                return 0;
            }

            index++;

            //check in the middle of the list
            while (current.next) {

                if (element == current.element) {
                    return index;
                }

                current = current.next;
                index++;
            }

            //check last item
            if (element == current.element) {
                return index;
            }

            return -1;
        }

        isEmpty() {
            return this.size() === 0;
        }

        size() {
            return length.get(this);
        }

        toString() {

            let current = this.getHead(),
                s = current ? current.element : '';

            while (current && current.next) {
                current = current.next;
                s += ', ' + current.element;
            }

            return s;
        }

        inverseToString() {

            let current = this.getTail(),
                s = current ? current.element : '';

            while (current && current.prev) {
                current = current.prev;
                s += ', ' + current.element;
            }

            return s;
        }

        print() {
            console.log(this.toString());
        }

        printInverse() {
            console.log(this.inverseToString());
        }

        getHead() {
            return head.get(this);
        }

        getTail() {
            return tail.get(this);
        }
    }
    return DoublyLinkedList2;
})();

 
循环链表
　　循环链表可以像链表一样只有单向引用，也可以像双向链表一样有双向引用。循环链表和链表之间唯一的区别在于，最后一个元素指向下一个元素的指针（tail.next）不是引用null，而是指向第一个元素（head），如下图所示

　　双向循环链表有指向head元素的tail.next，和指向tail元素的head.prev

【完整代码】
　　循环链表的代码如下所示

function CircularLinkedList() {

    let Node = function(element){

        this.element = element;
        this.next = null;
    };

    let length = 0;
    let head = null;

    this.append = function(element){

        let node = new Node(element),
            current;

        if (head === null){ //first node on list
            head = node;
        } else {

            current = head;

            //loop the list until find last item
            while(current.next !== head){ //last element will be head instead of NULL
                current = current.next;
            }

            //get last item and assign next to added item to make the link
            current.next = node;
        }

        //set node.next to head - to have circular list
        node.next = head;

        length++; //update size of list
    };

    this.insert = function(position, element){

        //check for out-of-bounds values
        if (position >= 0 && position <= length){

            let node = new Node(element),
                current = head,
                previous,
                index = 0;

            if (position === 0){ //add on first position
                
                if(!head){ // if no node  in list
                    head = node;
                    node.next = head;
                }else{
                    node.next = current;

                    //update last element
                    while(current.next !== head){ //last element will be head instead of NULL
                        current = current.next;
                    }

                    head = node;
                    current.next = head;
                }
                

            } else {
                while (index++ < position){
                    previous = current;
                    current = current.next;
                }
                node.next = current;
                previous.next = node;
            }

            length++; //update size of list

            return true;

        } else {
            return false;
        }
    };

    this.removeAt = function(position){

        //check for out-of-bounds values
        if (position > -1 && position < length){

            let current = head,
                previous,
                index = 0;

            //removing first item
            if (position === 0){

                while(current.next !== head){ //needs to update last element first
                    current = current.next;
                }

                head = head.next;
                current.next = head;

            } else { //no need to update last element for circular list

                while (index++ < position){

                    previous = current;
                    current = current.next;
                }

                //link previous with current's next - skip it to remove
                previous.next = current.next;
            }

            length--;

            return current.element;

        } else {
            return null;
        }
    };

    this.remove = function(element){

        let index = this.indexOf(element);
        return this.removeAt(index);
    };

    this.indexOf = function(element){

        let current = head,
            index = -1;

        //check first item
        if (element == current.element){
            return 0;
        }

        index++;

        //check in the middle of the list
        while(current.next !== head){

            if (element == current.element){
                return index;
            }

            current = current.next;
            index++;
        }

        //check last item
        if (element == current.element){
            return index;
        }

        return -1;
    };

    this.isEmpty = function() {
        return length === 0;
    };

    this.size = function() {
        return length;
    };

    this.getHead = function(){
        return head;
    };

    this.toString = function(){

        let current = head,
            s = current.element;

        while(current.next !== head){
            current = current.next;
            s += ', ' + current.element;
        }

        return s.toString();
    };

    this.print = function(){
        console.log(this.toString());
    };
}

【ES6】
　　ES6版本的代码如下所示

let CircularLinkedList2 = (function () {

    class Node {
        constructor(element) {
            this.element = element;
            this.next = null;
        }
    }

    const length = new WeakMap();
    const head = new WeakMap();

    class CircularLinkedList2 {

        constructor () {
            length.set(this, 0);
            head.set(this, null);
        }

        append(element) {

            let node = new Node(element),
                current;

            if (this.getHead() === null) { //first node on list
                head.set(this, node);
            } else {

                current = this.getHead();

                //loop the list until find last item
                while (current.next !== this.getHead()) { //last element will be head instead of NULL
                    current = current.next;
                }

                //get last item and assign next to added item to make the link
                current.next = node;
            }

            //set node.next to head - to have circular list
            node.next = this.getHead();

            //update size of list
            let l = this.size();
            l++;
            length.set(this, l);
        }

        insert(position, element) {

            //check for out-of-bounds values
            if (position >= 0 && position <= this.size()) {

                let node = new Node(element),
                    current = this.getHead(),
                    previous,
                    index = 0;

              if (position === 0) { //add on first position

                  if(!this.getHead()) { // if no node  in list
                      head.set(this, node);
                      node.next = this.getHead();
                  } else {
                      node.next = current;
                      //update last element
                      while(current.next !== this.getHead()) { //last element will be head instead of NULL
                          current = current.next;
                      }
                      head.set(this, node);
                      current.next = this.getHead();
                  }

                } else {
                    while (index++ < position) {
                        previous = current;
                        current = current.next;
                    }
                    node.next = current;
                    previous.next = node;
                }

                //update size of list
                let l = this.size();
                l++;
                length.set(this, l);

                return true;

            } else {
                return false;
            }
        }

        removeAt(position) {

            //check for out-of-bounds values
            if (position > -1 && position < this.size()) {

                let current = this.getHead(),
                    previous,
                    index = 0;

                //removing first item
                if (position === 0) {

                    while (current.next !== this.getHead()) { //needs to update last element first
                        current = current.next;
                    }

                    head.set(this, this.getHead().next);
                    current.next = this.getHead();

                } else { //no need to update last element for circular list

                    while (index++ < position) {

                        previous = current;
                        current = current.next;
                    }

                    //link previous with current's next - skip it to remove
                    previous.next = current.next;
                }

                let l = this.size();
                l--;
                length.set(this, l);

                return current.element;

            } else {
                return null;
            }
        }

        remove(element) {

            let index = this.indexOf(element);
            return this.removeAt(index);
        }

        indexOf(element) {

            let current = this.getHead(),
                index = -1;

            //check first item
            if (element == current.element) {
                return 0;
            }

            index++;

            //check in the middle of the list
            while (current.next !== this.getHead()) {

                if (element == current.element) {
                    return index;
                }

                current = current.next;
                index++;
            }

            //check last item
            if (element == current.element) {
                return index;
            }

            return -1;
        }

        isEmpty() {
            return this.size() === 0;
        }

        size() {
            return length.get(this);
        }

        getHead() {
            return head.get(this);
        }

        toString() {

            let current = this.getHead(),
                s = current.element;

            while (current.next !== this.getHead()) {
                current = current.next;
                s += ', ' + current.element;
            }

            return s.toString();
        }

        print() {
            console.log(this.toString());
        }
    }
    return CircularLinkedList2;
})();

 
 


----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/xiaohuochai/p/8175716.html
====================================================================================================
2017年总结和明年规划
****************************************************************************************************
一、前言
       这一年的变化很大，其实也是受到园友的影响，在此谢谢Edison Chou!也是因为他开始我的博客之旅，还有很多思想方面，习惯都有很大的影响。当然答应你的龙井，今年明前茶给你搞点，哈哈。
二、2017年终总结
       这一年一共写了20篇博客，最少每篇访问量基本在200人左右，收获粉丝18枚，这是一个很大的进步。当然这20篇博客也是伴随着我的学习过程，下面我主要说一下学习了那些东西：
      1.图解TCP/IP
         这本书写的相对来说比较简单,主要就是了解下TCP/IP方面的知识，整体上没什么难度，大力推荐阅读下，当然这也是我第一篇开篇博客，有很重大的意义。
      2.图解HTTP
         这本也是一本入门书籍，如果你是学习Web那必须要读一下这本书，或许能让你对Web的理解更上一层楼，主要讲述HTTP协议常用方法，报文结构，协议格式，状态码等一系列内容总体不错。
     3.精通ASP.NET MVC5
         这本书写的很好，看完整体上对MVC框架运作会有深入理解，也是大力推荐阅读，另外有兴趣还可以自己搞一个MVC框架玩一玩，这样理解更深刻，看这本书的时候我也写了几篇博客，但是一直没整理好，这是一个遗憾。
     4.大话设计模式
         这本书以故事的形式去讲解设计模式，写的风趣幽默，大概读了60%左右，有些个设计模式还是没有很融汇贯通，还需在努力一把，当然这本书也是大力推荐之一；
     5.代码的整洁之道
         这本书看完之后就忘记了，但是你想要写出优秀的代买这本还是必须要读，当然这也是我下一年要读的，到时候会来个一系列博客。
     6.Java核心卷I
        这是转Java以后的第一本书，除去Swing部分没有读，整本书通读一遍，另外重点部分比如集合，反射，代理和多线程部分又重新温习过一篇。
     7.Java核心卷2
        这本简单看了几章，基本已经忘光，不推荐买。
     8.Spring实战
        这本看算是看了50%吧，还是可以的入门级书，Spring部分源码还是需要读一下的。
     9.大话数据结构
        这本看了80%，讲的很不错，值得入手，数据结构和算法还是很重要的，这是内功需要学习下，当然读了这本书以后，在结合JDK集合源码思考下，那你集合基本上就理解彻底了。
     10.深入理解Java虚拟机
        这本书看了2遍，主要讲述了JVM相关方面的东西，非常值得读，看完以后感觉有本质的提升，是由内到外的那种感觉。
     11.Java并发编程
        这本书本来计划在过年之前读完的，但是不幸家里有点事，只是读了前几章，但是还是很提推荐大家入手。
     以上基本是这一年看过的书籍，不敢说全部理解，反正对我个人来说提升还是很大的，算上是飞跃的一年把，其实过程还是很痛苦的，熟悉C#的我一下转成Java难免会有些不适应，还有很多坑要去踩，还有好多框架需要去学习，理解；所以注定新年里还是奔波，忙碌的一年。
     技术上的事谈完了，这里谈一下生活，当然这是我意想不到的事，一手抚养我长大的奶奶去了，遗憾的是没有见上最后一面，懊恼的是老人家一生受苦，为什么在我有能力让他享受天伦之乐的时候要让他换上这种病，当然还有就是我一直没有满足老人家心愿，早点带回去一个女朋友，让老人家带着遗憾走的，我也知道这种事不能强求，但是我还是不能原谅我自己，用一首诗来表达下我的心情：亲人已仙游,未呈儿孙福。游魂于千里,如何度思量。让我想起季老的《我和北大》的第一辑，深深体会到了他的那种遗憾与思念之情。再谈一下工作，在国企上班的这一年里，气氛太安逸，使我不适应，但是不得不说福利是很到位的，但是我又是一个不太想安逸的人，因为现在的安逸是为未来埋雷，怀揣的这样的心态，我这一年里看了上面那些书，做了转行Java的准备，在公司上了一个Java系统，就这样过完2017年。
   这里总结一下，2017年我个人的进步还是值得肯定的，看书计划基本完成80%，总体比较满意，工作上领导布置的任务都能按时完成，但是过于安逸的氛围我不太喜欢，因为这样我怕我会懈怠，生活上自己也有几W的存款，这比在山西工作的2年进步的太多了，明年也有购房计划，当然我计划在太原或者郑州买房，估计要啃一把老了，奶奶去世我挺遗憾，但是我依然会前行，我相信她更希望看到进步的我，接下来我们谈一下新年计划吧。
三、新年计划
   新年计划计划还是从工作、生活和学习三方面谈起。首先来谈一下工作：工作在2017年的时候基本有个简单计划，2018年是去落实的一年，总体上要实现这几个目标：
   1.工作的语言由C#转变为Java；
   2.选择金融行业或者电商行业的互联网公司，更偏向于大公司；
   3.薪资希望在现在的基础上增加30%；
   4.希望在并发和数据处理这块能扩展一下；
   接下来谈一下生活：
   1.如果有合适的妹子，那么就来谈一下对象吧；
   2.房子不知道郑州还是太原，郑州发展更好一点，太原同学都在太原，有点不知道该如何抉择，但是在6-7月份还是要买的；
   3.如果时间允许的话，想去趟西藏和云南；
   4.继续2017年和Edison Chou的赌约每周10公里，天气转暖开始Keep锻炼；
   最后来谈学习:
   1.Java并发编程，这本书是重点，也是想搞好并发的基础，必须搞明白；
   2.Redis实战，学习下理论知识，现在只是会用，需要对知识做一下系统整理；
   3.Java编程思想，此书也是想搞好Java必读精品，阅读的时候对重点部分做一下博客整理；
   4.Mysql技术Innodb存储引擎，深入了解下数据库方面的知识，不再是简单盲目的优化和处理；
   5.大话数据结构，把剩下的部分阅读完成，这个需要在跳槽之前完成；
   6.代码的整洁之道，结合自己代码进行实践；
   8.重构-改善既有代码的设计，阅读这本书和代码的整洁之道基本也一样；
   9.敏捷软件开发原则、模式和实践，也和上面2本的目标基本一样；
   10.Liunx私房菜基础版，扩展下Liunx知识；
    需要看的书基本就这些了，然后还需要看下JDK部分源码，还有Spring部分源码需要读一下，另外在学习Spring Cloud玩一下微服务设计，跟上时代步伐；另外学习下新概念的课程，英语好好搞一下，基本规划就这样，愿一切顺利进行。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/wtzbk/p/8169154.html
====================================================================================================
我是如何确认线上CLOSE_WAIT产生的原因及如何解决的。
****************************************************************************************************
1、阐述
　　内部架构：Tomcat应用程序---> nginx ---> 其他Tomcat应用程序，内部Tomcat应用通过nginx调用其他应用。
　　HTTP插件：HttpClient 4.2.3
　　关闭连接的代码：httpClient.getConnectionManager().closeIdleConnections(5, TimeUnit.SECONDS);
2、说明
　　要说明的是CLOSE_WAIT产生的原因和服务器、nginx、其他配置无关，是HttpClient的getConnectionManager引起的。
3、排查思路
　　这个问题已经困扰我很久了，查看过网上的很多办法，也试过很多方法。
　　比如：修改服务器内核、修改nginx配置文件、更改nginx版本，都是没有用的，还是上面那句话和服务器、nginx无关。
　　最后决定自己分析请求，查找真正的根本原因，以下为排查的最终步骤
4、问题排查
　　首先确认CLOSE_WAIT产生的链接，链接的IP和端口
　　
　　由上图看出是本机链接nginx 81端口造成的CLOSE_WAIT
　　抓包分析其中一个CLOSE_WAIT所用的本机端口：

　　抓包分析正常关闭的请求：

　　分析不正常端口41584，晚上22点01分02秒请求连接，22点01分02秒传输数据结束，22点02分07秒，nginx发送关闭连接的包，Tomcat同意关闭，问题就出现在这里，在Nginx请求关闭连接后，Tomcat并没有回复同样关闭连接的包，没有完成四次握手，故产生了CLOSE_WAIT。
　　分析所有正常连接发现没有产生CLOSE_WAIT的端口都是Tomcat主动关闭的，产生CLOSE_WAIT的都是nginx主动关闭，Tomcat被动关闭的。
　　再次分析所有的不正常端口

　　发现Tomcat周期性的向Nginx发送关闭连接的请求，但是Nginx回复Reset包，说白了就是Tomcat请求关闭连接，但是Nginx说我没有这个链接(已经在前面主动关闭)，所有CLOSE_WAIT会一直存在，直至两个小时以后系统强制关闭。至于为什么会周期性的一起并发的关闭的连接，而不是一个一个关闭，或者为什么在收到Nginx关闭连接请求，Tomcat不关闭，看上述Java代码：httpClient.getConnectionManager().closeIdleConnections(5, TimeUnit.SECONDS);
　　这段代码表示调用httpClient的getConnectionManager，然后利用closeIdleConnections进行关闭空闲连接，5代表是五秒(不知道解释的对不对)。
　　网上查找getConnectionManager，说是httpclient的链接池管理工具。就是把请求都扔里面，然后Manager帮你做相关处理。
　　但是上述代码写的是5秒之内连接空闲就会关闭，httpclient又是一个很成熟的技术，于是没有怀疑这个的问题(我不是开发，代码层我无法分析)。
　　继续分析其他正常关闭的包，发现并不是所有正常关闭的连接都是五秒关闭的，而产生CLOSE_WAIT的，一般请求关闭都是超过65秒的(65是nginx keepalive timeout的值)，为了确认问题的根源，我把nginx的keepalive timeout设置为240秒(Nginx主动关闭连接后，最长Tomcat第一次发送关闭连接的包据数据传输完毕的时间间隔为3分28秒)，实时查看CLOSE的增长变得缓慢，改为360秒，几乎不怎么增长，但是还有增长，索性改为0，过了一个多小时，只会下降，不会增多，所以断定是HTTPCLIENT出现的问题。
5、继续分析
　　查看httpclient官方文档：http://hc.apache.org/httpcomponents-client-ga/httpclient/apidocs/org/apache/http/conn/ClientConnectionManager.html

　　上面说在给定的时间内(上述代码的五秒)链接没有被使用，就会在池中关闭连接。同时也会关闭过期的连接。
　　看解释说只要连接5秒没有被使用，就会关闭连接，不会大于65秒的，至此又回到诧异懵逼中。。。
　　再次回想连接池中周期性发送FIN包，让我判断没有在五秒内关闭连接只有两种可能：一、配置没有生效，二、HTTPCLIENT空闲连接检测机制。
　　把自己的想法说给开发人员说后，无法断定空间连接检测的机制是什么，于是决定修改代码，换用另一种关闭的方式(没有时间考虑上面的两个想法)：将所有完成请求的连接通过httpclient的releaseConnection和SHUTDOWN进行关闭，修改完成并在测试环境部署(测试环境也同样有CLOSE_WAIT)，运行至今改过代码的并无产生任何CLOSE_WAIT。

 
6、总结
　　CLOSE_WAIT产生的原因是由代码引起的，目前能确认的是HTTPCLIENT的getConnectionManager的连接池引起的，但是为什么设置的5秒没有生效，空闲连接的检测机制是什么，这些还无法得知，
　　
　　
　　
　　
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/dukuan/p/8178728.html
====================================================================================================
Java设计模式总汇一
****************************************************************************************************
PS：首先我们要带着问题读文章

什么是设计模式
为什么要用设计模式
使用设计模式有什么好处

　　设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。
　　　该篇文章主要写的是（介绍没有顺序）

适配器设计模式
单例设计模式
静态代理设计模式
简单工厂设计模式

1：适配器设计模式
意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。
主要解决：主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
官方给出：
优点： 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。
缺点： 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。
示例：这里我简单写一个关于两个接口的例子，来调用里面的方法来看看效果这两个接口我们可以理解成充电器，一个是苹果lighting口，一个安卓充电器，我们都知道这两个充电器接口是不一样的，但是淘宝上有卖转换头的，可以在苹果头上套一个转换器就可以冲安卓手机里，这中间的转换头就是我们所说的适配器，我再配张图（中间一头是方形一头是圆形就是适配器）

好，废话不多说，开始
（1）首先写一个A苹果接口，一个B安卓接口然后实现该接口里的方法，开始工作
　　

//实现A
class PowerA {
	public void workA(){}
}
class PowerAiml extends PowerA{
	public void workA(){
		System.out.println("我是A，我要开始工作了");
	}
}
//实现B
class PowerB {
	public void workB(){}
}
class PowerBiml extends PowerB{
	public void workB(){
		System.out.println("我是B，我要开始工作了");
	}
}


 （2）写一个方法只有A（苹果）接口可以用。
　　

public static void work(PowerA a){
		System.out.println("开始-------");
		a.workA();
		System.out.println("结束-------");
	}


 （3）调用查看效果

PowerA pa=new PowerAiml();
		work(pa);


 
这样使用是没有任何问题的，因为参数就是PowerA a，只要是传入实现PowerA接口的class都可以调用该方法，但是，问题来了，如果我想让使用PowerB怎么办呢，有两个方法，一个是再写一个work2（PowerB b），另一个是用适配器的方法，显然第一种方法对于这个例子是最简单的，但是在一个软件编写的过程中不光是这一点代码，代码有很多，难道都要再写方法吗，那样子就太麻烦了，现在就用适配器的方法
（4）适配器
想要使用A方法，就要伪装成A，把适配器实现PowerA

//适配器：
class Adapter1 extends PowerA{
	public PowerB b;
	public Adapter1(PowerB b){
		this.b=b;
	}
	//当调用A的时候，就自动调用B里的方法。
	public void workA(){
		b.workB();
	}
}


 调用的时候是，一头与B关联，一头与A关联

PowerB b=new PowerBiml();
Adapter1 adapter=new Adapter1(b);
work(adapter);


 
解释一下：在Adapter1中传入的b，然后把adapter传入work，虽然调用的都是workA，但是关键来了，在workA方法中又调用了b.workB()；就是这么一个思路。
这是一个非常简单的例子，在开发过程中，真正要用到适配器要比这个看似复杂点，原理都是一样的，毕竟小孩子的性格是天真的，大人的性格就变化莫测了。
2：代理设计模式
意图：为其他对象提供一种代理以控制对这个对象的访问。
主要解决：在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
何时使用：想在访问一个类时做一些控制。
如何解决：增加中间层。
静态代理模式，说白了就是委托，将所有的事情都委托给别人帮你完成，你所要做的，就是给代理一些东西，接下来所有的事情都是代理帮你完成，你完全不用去关心内部是如何实现的。举个例子简单的说一下，一个人买衣服，可以去实体店也可以去网上，买火车票的时候，你就知道售票员就会给你 你想要的票，而且你只需要给他钱和身份证以及地点就可以了，他会经过处理，最后把票给你，他就处于一个代理模式。下面我简单写一个例子
比如说我只想要水，我就给你送水的公司打电话让他们送一桶水，然后我就在家等着就可以，在这期间谁送水，怎么送，需要多久，什么样的水等一切我都不需要知道，这都被送水公司代理了。OK
（1）先写一个要水的类和接口

class Action{
	public void work(){}
}
class MyAction extends Action{
	public void work(){
		//在这期间可能会有我不想做的事，但还是要有，比如说一共耗时，打水结果要的是水，但必需要拿水桶等。
		//这些东西都是可以让代理给做了，
		System.out.println("获得水");
	}
}


 （2）写代理类
如果不写代理类的话，也可以直接调用work方法，但是就相当于自己去搬水，而不是用代理。

/**
 * 代理类
 * 	控制，在方法前或后所要做的类。
 * */
class DaiLiAction extends Action{
	private Action action;
	public DaiLiAction(Action action){
		this.action=action;
	}
	public void work(){
		System.out.println("我是送水公司");
		System.out.println("代理正在处理中。。。");
		System.out.println("代理处理完了返回给你结果");
		action.work();
	}
}


 （3）调用即可

Action ac=new MyAction();
//把对象给代理类，工作是由代理完成。
DaiLiAction dai=new DaiLiAction(ac);
dai.work();


 
3：单例设计模式
http://www.cnblogs.com/cmusketeer/p/8016550.html
4:简单工厂设计模式
意图：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
主要解决：主要解决接口选择的问题。
何时使用：我们明确地计划不同条件下创建不同实例时。
如何解决：让其子类实现工厂接口，返回的也是一个抽象的产品。
哦，对了，这是简单工厂设计模式，还有抽象工厂设计模式，和这个类似，下一篇再说，这里先举例说明这个模式，使用该模式可以降低使用者和被使用者之间的依赖。比如说，我开了一个工厂，下面有部门，一个是造手机的，一个是造电脑的，OK
（1）创建手机和电脑类


/**
 * 工厂接口
 * */
interface Factory1{
	public void create();
}

/**
 * 手机
 * */
class Phone implements Factory1{
	@Override
	public void create() {
		System.out.println("我是造--手机--的");
		
	}
}
/**
 * 电脑
 * */
class Computer implements Factory1{
	@Override
	public void create() {
		System.out.println("我是造--电脑--的");
	}
}


（2）创建工厂控制类FactoryControl

/**
 * 工厂控制类
 * */

class FactoryControl{
	public static Factory1 getGood(String good){
		if(good.equalsIgnoreCase("phone")){
			return new Phone();
		}else if(good.equalsIgnoreCase("computer")){
			return new Computer();
		}
		return null;
	}
}


 (3)调用和效果

Factory1 factory=FactoryControl.getGood("phone");
		factory.create();
		
		factory=FactoryControl.getGood("computer");
		factory.create();


 
当然，也可以不经过FactoryControl（工厂类）,也是可以调用的，但是如果是大工程，使用该模式可以降低使用者和被使用者之间的依赖。这里就算你传入一个耳机，没有这个功能，它也不会报错，返回null。
好了，下一篇就会继续写剩下的19个设计模式，例子都是简单易懂的，只要理解了，慢慢的再写复杂的代码就轻松了，只要有了思想，写代码就简单了，可以告别有能力但总觉得无处施展的尴尬。




----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/cmusketeer/p/8146510.html
====================================================================================================
自己动手写把”锁”之---JMM和volatile
****************************************************************************************************
一、JAVA内存模型
关于Java内存模型的文章，网上真的数不胜数。在这里我就不打算说的很详细、很严谨了。只力求大家能更好的理解和运用，为后边的技术点做铺垫。
 
内存模型并不是Java独有的概念，而是我们的计算机硬件平台的一个概念。内存模型描述了程序中变量如何在从内存读出、以及何时写会内存的底层细节。
 
我们知道，程序运行其实就是CPU和内存的频繁交互的过程。随着CPU的快速发展，CPU的执行速度越来越快，但是内存却很难跟上CPU的执行速度，为了解决这一矛盾，CPU厂商就为每颗CPU加了高速缓存，用来缓解这个速度不匹配的问题。因此，CPU和内存的交互变成了这个样子：


以上只是在CPU和内存之间加了个高速缓存，其实也还没什么问题。那内存模型这个概念是怎么产生的呢？继续往下看。
 
CPU虽然在不停的发展，但单个CPU的主频速度不可能无限制的增长，为了进一步提高计算性能就引入了多核技术。由于每个cpu都有自己的高速缓存，当多个CPU操作同一个内存数据时，就产生了缓存不一致的问题。如下图：


为了解决这个不一致的问题，就需要处理器在运行时要遵循某些协议，这类协议包括MSI、MESI、MOSI等等。到这里就有了内存模型这个概念，它就是用来描述数据在各个高级缓存以及内存之间的交互细节。不同的硬件处理器架构，就会有不同的内存模型。所以用c/c++开发多线程程序时，就需要考虑不同操作平台下的内存模型。
 
所幸我们是学Java的，Java平台为了屏蔽不同硬件平台的不同内存模型给开发人员带来的成本，引入了Java内存模型，即JAVA Memory Model，简称JMM。
 
要想深入掌握JAVA多线程并发编程，Java内存模型是必须要了解的。Java内存模型定义了多线程之间共享变量的可见性以及如何在需要的时候对共享变量进行同步。直白点说就是：同一个变量，被多个cpu上执行的多个线程访问，每个cpu的高速缓存都缓存了这个变量，当某个线程修改了高速缓存里的变量，何时通知给其他的cpu线程让它可见，以及何时将变量同步回内存(主存)。如下图：


Java虚拟机的内存模型和计算机硬件的内存模型基本一致。在Java内存模型中，分为线程私有的本地内存和线程共享的主内存，线程在读写变量时会把主内存里的变量缓存到本地内存，换句话说，本地内存存放了主内存中变量的副本。主内存和本地内存其实是一种逻辑上的划分，并不是实际的物理内存。
 
这里需要强调一下，这里的变量指的是分配到堆上的变量，即线程之间可以共享的变量。本地变量是线程私有的，所以不会有可见性问题。
 
二、volatile
Java内存模型中说到了线程间共享变量的可见性问题。可见性问题其实就是缓存不一致的问题。如下图：


线程B读取变量X，并缓存到了自己的本地内存中，线程A也将变量X缓存到本地内存中并修改为2，这时线程B并不知道变量X修改为2。这就是线程间不可见的问题。为了解决这个问题，就引入了volatile关键字，被volatile修饰的变量将不会在本地内存缓存，线程直接通过主内存来读写变量。虽然解决了不可见的问题，但也是以牺牲性能为代价的。
 
volatile关键字相信你已经理解了，但是在Java中volatile并不仅仅是这个功能。在这里我通过与c语言中的volatile对比扩展下。
有的时候我们可能会面临这么个场景，线程1执行某些业务逻辑，线程2判断线程1是否执行完，执行完了则线程2执行另一个逻辑，如下伪代码：


我们通过一个flag变量来标识线程1是否执行完相关逻辑，为了保证flag的改变对线程2可见，这里使用了volatile关键字修饰。如果这个伪代码采用Java实现，这是没问题的，如果c实现，则就会有坑。
这个坑主要是源于指令重排。为了提高执行效率减少内存的交互，编译器会根据情况对执行的指令做一个重排序。所以线程1中执行相关业务逻辑后，再将flag设置为true的逻辑，极有可能重排为：先设置flag=true然后再执行相关业务逻辑。这也是c语言为啥不提倡使用volatile的原因。
 
但是为什么在Java中就不会有这个坑呢，难道Java没有指令重排序吗？
当然不是，Java也会有重排序，不过Java对volatile做了如下的极大增强：

所有对volatile变量的写操作之前的针对其他变量的读写操作，经过编译器、cpu优化后，都不会被重排到对voltile变量的写操作之后。
所有对volatile变量的读操作之后的针对其他变量的读写操作，经过编译器、cpu优化后，都不会被重排到对voltile变量的读操作之前。

 
面试中，有面试官比较喜欢问这么一个问题：能否用volatile修饰的整数变量n，通过n++操作实现计数的功能？这个问题就是考查应试者对volatile的理解。我这里简单地说一下。
答案肯定是不能。volatile实现的是线程间共享变量的可见性，并不是原子性操作。++操作其实可以拆分为这么几个步骤：

读取主内存里的变量
cpu完成变量的++,然后写会主内存。

所以可以想象这么一个执行顺序：

线程A读取volatile变量X=0
线程B读取volatile变量X=0
线程A完成++操作，然后将X=1写回主存。
线程B也完成++操作将X=1写回主存。

在这么一个执行顺序下，对X进行了++两次，但值却只增加了1。
 
 
关于如何实现原子性操作，我将在下一节进行讨论。
 
 
 

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/qingquanzi/p/8179042.html
====================================================================================================
2017总结：迷茫的一年
****************************************************************************************************
如果要把过去的2017总结为一个词的话，那就是：迷茫
关于工作
回首过往的一年，工作中有哪些突出的成绩，答案是Nothing。每天淹没在琐碎的工作中，做的也都是从1到n的工作，虽然加班也不少，但却找不到任何的成就感。曾无数次后悔为什么一年前没有接受那个大数据的offer,或许现在我已经成了半个大数据方面的专家，或许收入比现在还要好一点，但过去的就是过去了，再惋惜也是无济于事了。
我一直有志于专注在某一方面，能够通过自己的努力打造一款令人震惊的产品，这一直都是内心深处的个人英雄主义在作祟，想通过这种方式一鸣惊人，但结果往往不如人愿。过去一直都在孤军奋战，今年依旧如此，部门组织架构中，再也没有了 大数据组 这个名字。
要不离开，要不改变，我已别无选择。

如果你自己对接受什么不加选择，那么别人就会替你选择，而他们的动机未必很高尚。

关于生活
步入婚姻生活已经一年有余，生活虽然平淡，但也不失幸福。媳妇很贤惠懂事，对待公公婆婆也是尊敬体贴，虽然有时的小性子让我费解和抓狂，但女人的感性能让你感觉更加真实。
还了一年多的房贷，年底又贷款买了车位，马上又要装修，生活一下子变得紧张起来了，有时确实感觉到很多压力，日常的思考也由该怎么解决某个技术难题转为做什么行业能够挣更多的钱。呵呵，生活就是有如此大的力量，能够轻易就改变一个人的心态。
2017年最大的遗憾也许就是没能怀上梦寐以求的小宝宝，但好在我们还年轻，这种事也急不来......

生活是一种绵延不绝的渴望，渴望不断上升，变得更伟大而高贵。

关于生死
说起生死，总是让人感觉很沉重。之所以想起写写这个，是因为最近元旦回家，见到和听到了太多老人病危及离世的消息，不得不让人感叹岁月的残忍。
半个月前，媳妇和岳母打电话，说起她爷爷最近感冒了，身体不太好，媳妇非常担心，借着周六的时间我们回去探望了一下。爷爷今年也有87岁了，身体之前一直还不错，眼不花耳不聋，留着一缕山羊胡子，样子和古代私塾的老先生一摸一样，事实是他确实是教了好些年的书。记得刚结婚那儿，爷爷还经常自己骑着自行车去集市买东西。这才一年的时间，看着真的老了很多，说话气息也没那么足了，饭也吃不下。一直以为最近流行感冒太猖狂，过段时间吃点药就能好了，媳妇还多次微信视频劝她爸带爷爷来市里医院看看。
不成想这次元旦回家，当媳妇刚站到爷爷的床前，只开口叫了声“爷爷”，眼泪却不自觉的哗地流了下来，扭头哭着跑出了门外。此时的爷爷，已经卧床起不来了，连睁开双眼看一眼他的孙女都变得很困难。但他耳朵很好使，心里也明白的很，儿孙们在旁边说话他也能听的一清二楚，经常闭着眼睛说是不是都回来了，都回来让你们再看我最后一眼，我也就要走了。
爷爷下面有七个儿子，两个女儿，我岳父是他最小的孩子，从媳妇记事起爷爷就和她们一家生活在一起，感情自然要深一些。最近她天天郁郁寡欢，也许心里也明白，爷爷可能过不了这个春节了。看到她这个样子，我也不知道该怎么劝导她，能做的只是默默陪伴，在她哭的时候借个肩膀给她靠。
这让我想起了今年看的一部电影叫《北京遇上西雅图之不二情书》，里面的奶奶说的一句话，“以前，是父母在不远游；现在是子女在，父母不敢远游”。这其实何尝不是我们中国大多数的父母呢，前半生为了爱为孩子奔波；后半生为了孩子，被爱捆绑。带孩子，带完孩子带孙子，等到夫妻之间终于有时间陪伴彼此了，可能老伴儿就已经不在了。也曾多次为电影中爷爷对奶奶说的那段独白感动到落泪，其实我也是个很感性的人。
真心希望所有的人能好好对待自己的父母，不要等父母老了，离开我们了，再感叹岁月的蹉跎。

父母在人生尚有来处 父母去人生只剩归途

关于梦想
2012年生日那天，那时的我还在上学，在QQ空间发表过一条说说，“2012年农历10月22, 我有一个3年计划，有一个5年计划，还有一个10年计划！希望10年之后回想起来，我不会后悔自己走过的每一步！”。媳妇（那时候还是女朋友）在下面留言“我也有一个三年计划，一个五年计划，和一个十年计划，你觉得呢？？”我笑着说猜不到你的十年计划，其实她说的三年和五年的计划我也不知道是什么，我也从未跟她提起过我的计划又是什么。
那时候感觉说梦想有点大，而且那时候梦想这个词都被用烂了，说出来总感觉有种吹牛逼的意思。也许这也是我梦想的雏形，无非就是三年内买辆车，五年内买套房，十年内开家科技公司。也许你会很不屑的说一句，这可真TMD俗。是啊，确实够俗，在某些人眼中可能对这些东西根本就不值一提，但对于一个家在农村，需要靠助学贷款才能把学业修完的人来说，这些东西却非常遥远。
这又让我想起中考之后的那个暑假，在一个工地打工的情景。那是一个烈日炎炎的中午，我和一个工友（其实是一个村的，比我大几岁，按辈分还要叫他一声叔）在楼顶干活，我们所在的工地马路对面就是一个大型超市，看着那些衣着艳丽的人或推着购物车、或提着大包小包的东西从超市里出来，然后走到车前，把后备箱塞满，又开着车扬长而去，别提有多羡慕了。我就对他说，要是哪一天我们也能像他们一样该多好啊，那么有钱一次买那么多东西，最好买的时候都不用看价格，想要哪个拿哪个，说着说着两人都哈哈大笑起来，仿佛一切都已经实现了似的。“嗯，我还要买个大西瓜，对，冰镇的那种......”
现在回想起来，往事仿佛就在昨天。好在现在一切貌似都在按计划进行，车有了，房也买了，但却更加焦虑了，有时候自己都不知道为了什么而焦虑，也许整个社会都这样吧。算算日子，时间也过了一半，前路漫漫，君仍需努力。

真正美丽的东西必须一方面跟自然一致，另一方面跟理想一致。

我的2018

计划，计划，计划
我不太擅长做计划，也很不习惯做总结，这是我的缺点。我无法忍受计划被打乱，那会让我很抓狂，2018年我要改变这一点。
每月一本书，并写读后感
不能只读技术方面的书，多读能够拓宽视野和思维的书籍，让自己的格局变大。
多和朋友聊天，结交新朋友
多和他人交流，能够拓展自己的知识，还能得到一些有用的信息。
上架个人开发的App
想了好久了，但一直因为技术及资金的压力，没能开展。2018年开始实施。
深入研究大数据和人工智能
大数据一直在边学习边应用中，机器学习和深度学习也学过一段时间。2018年加深理解和应用。

THE END

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/jinhaolin/p/8177663.html
====================================================================================================
利用VSTS跟Kubernetes整合进行CI/CD
****************************************************************************************************
为什么VSTS要搭配Kubernetes？通常我们在开发管理软件项目的时候都会碰到一个很头痛的问题，就是开发、测试、生产环境不一致，导致开发人员和测试人员甚至和运维吵架。因为常见的物理环境甚至云环境中，这些部署环境都是由运维人员提前准备好的。每次更新代码版本，都要很小心的在几个环境之前修改不同的参数配置，一不小心就将生产环境的数据库连接到了测试库，或者日志文件的地址写到了一个不存在的盘符里等等各种异常情况，有了Kubernetes这样微服务编排框架，我们可以通过代码的形式描述服务的架构，描述服务之间的依赖关系，做到了 Infrastructure As Code。这样可以大大减少了开发运维之间在做环境切换时带来的额外成本。将VSTS的持续集成能力和持续发布能力整合Kubernetes，可以让项目团队更容易发现和改进代码（这时候的Infrastructure也已经是代码了）的问题，真正将精力放在改进用户体验和改进产品品质上。准备VSTS管理环境首先我们需要到www.visualstudio.com下申请好的VSTS账号，然后在账号下创建一个用Git作为代码管理的项目创建好项目后我们就可以利用git clone将代码库同步到本地开发服务器上面来，构建开发人员的workspace准备Docker Registry和Kubernetes环境2.准备一个私有的Docker Registry.因为我们需要将Build 好的代码放进一个Docker的Images上面然后推送到一个私有的Registry上。Azure Container Registry无疑是一个非常好的选择，因为等一下我们的代码需要部署到Azure的Kubernetes群集里，Image所在的地方离部署的地方越近，部署速度当然也就越快了。而且Azure Container Registry还支持全球同步，如果你的代码打算全球多站点发布的话，Azure Container Registry服务无疑是最好的选择。创建Azure Docker Registry可以参考官方文档：https://docs.microsoft.com/zh-cn/azure/container-registry/ 3.准备Kubernetes群集，Azure上支持提供了AKS服务，让我们可以快速搭建出来Kubernetes的群集环境，减少了运维人员管理群集的压力，搭建方法参考官方文档：https://docs.microsoft.com/zh-cn/azure/aks/kubernetes-walkthrough-portal   搭建的过程中注意几个地方1.准备好Service Principle服务主体APP2.准备好linux ssh登录的Key安装好群集后通过 Azure CLI 2.0命令：az aks install-cli 这样我们就可以自动在你的linux上装上Kubernetes的kubectl命令行工具了.要管理Kubernetes的话，需要运行下面的命令，在本地生成K8S的管理配置信息az aks get-credentials --resource-group=myResourceGroup --name=myK8sCluster获取到的配置内容会放在/home/<youraccount>/.kube/config文件里面，这文件里面的内容非常重要，等一下VSTS需要这个信息来跟K8S群集进行链接的。我们可以通过kubectl get nodes命令看看群集的状况开始配置VSTS的自动化构建和自动化发布我们再VSTS的项目站点里找到Build and Release的菜单项，点击New的按钮选择NodeJS with Gulp的模板创建好后，我们先裁剪掉暂时不需要的Task，然后添加上Docker build Image和push Image的Task--->配置Build an image Task:在这里我们可以将一开始准备好的Azure Container Registry环境用上了配置Push an image Task,Image Name使用BuildId作为镜像的Tag，这样后面部署到Kubernetes的时候就可以指定这个Tag对Image进行更新了。Build的定义不算太复杂，定义完之后我们就可以直接触发一次Build来检验一下配置是否成功了。下图就是Build成功之后的日志，我图中我们可以看到Docker push命令将image push到了我们之前建立的Azure注册Repository里面了自动化构建成功之后，我们可以做自动化的部署了，创建一个新的发布定义在Environment里点击一下蓝色字体部分，编辑部署任务在配置部署任务时，选择Deploy to Kubernetes的任务类型，并且在Manage这个蓝色链接这里配置Kubernetes的链接信息。在Kubernetes的命令里使用set命令，通过设置image的更新地址来通知Kubernetes更新部署版本。命令的格式是:kubectl set image deployment/<deploymentname> <imagename>=<image url>在VSTS里面，只需要argument里面把后面的部分填上就好配置Kubernetes的 Service Endpoints信息：配置好部署任务后，我们可以尝试一下手动将前面成功的Build部署到Kubernetes环境中至此我们已经可以成功将一份代码部署到了Kubernetes里面去了部署成功后，可以通过kubectl get pods -w命令监控一下Kubernetes对容器进行更新替换的过程，从下图中可以看到Kubernetes创建了一个新的pod，然后将旧版本的pod进行了Terminate.如果我们需要将Release跟Build自动链接起来，可以通过编辑Release定义，选择图上的闪电按钮，将Continuous deployment trigger的按钮设置为Enabled即可。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/wing-ms/p/8177718.html
====================================================================================================
css盒模型研究
****************************************************************************************************
css的盒模型一直是一个重点和难点，最近由后端的学习转到前端，觉得有必要深入研究一下css的盒模型。
1.万物皆盒子
我们必须要有一个理念，在html的世界里，万物皆盒子，那就是任何一个html元素都是一个盒模型。比如一个div，一个标题，一个段落。他们本质上都是一个盒模型。
2.盒模型的结构
如下所示。

注意它的宽度和高度指的是它元素的宽度和高度。元素到边框之间的区域叫做padding(内边距），边框在往外扩展的区域就叫做外边界。外边界就是整个盒模型能到达的最遥远的地方，也是保证其他的盒子不会侵袭这个盒子的边界线。
有几个点需要注意：
a.首先分析盒模型，要找准你分析的对象，比如一个div对象。上图中所有盒模型的所有术语（width,heghit，padding）都是针对该盒模型而言的。这时候你就不要去管它旁边的，或者它内部的其他元素。只需要分析这个对象就好了。
b.width和height指的是元素的宽度和高度，确切的说，应该是这个盒模型的元素可以使用的宽度和高度，事实上，它里面的元素可能并没有所规定的高度和宽度那么大，也有可能超出这个范围。
c.background-color或者背景图像所填充的区域是包含元素+内边距的内容。利用这点我们可以来做一些实验。
d.边框和外边距之间的内容默认是透明的。
以上便是一个盒模型的所有元素。下面我们先来看一个例子，对盒模型有个直观的了解。

<body>
    <div id="box1">
        <h1>a box</h1>
    </div>
</body>

其css代码如下

* {
    margin: 0;
    padding: 0;
}

#box1 {
    background-color: #C6F08C;
    padding: 5px;
    color: white;
    margin: 5px;
    width: 300px;
    height: 300px;
}

因为有些浏览器默认会提供margin和padding，为了方便我们试验观察，这里我们先强制设为0，如上面的第一个css所示。运行上述的代码以后，我们看到页面展示的内容是这样的。

 
 从这里你看不出什么东西，这时候可以利用google的f12,观察html元素。选中div id=“box1”这个元素，这时候将展示出他的盒模型，如下图所示。

 
 
 
 你可以尝试勾选上图中box1的css元素，观察右侧html页面的实际变化，比如，当我们将padding:5px这个元素不选中以后，盒模型变成如下所示。
 
如果你自己操作，仔细观察，就会很明显的发现，划掉padding以后，这个box1的背景颜色的长度和宽度变小了，因为background包含的是element+padding，现在没有了padding，总的面积就减少了。另外一个变化是内容“a box"变得紧贴着边沿。同样是因为padding变为0了。元素和边框之间没有其他东西了。
读者可以在尝试划掉margin，就会发现整个盒模型紧贴着浏览器的边沿，如下所示。

 
 我们继续做实验，把padding依然设为5，而把margin设为-10.看看这时候页面的样式。

 
我们发现浏览器的边沿侵占进了box1这个盒子的边沿（上边沿和下边沿），造成我们只看得到a box这行字的部分，事实上，box1的边框内部（包含padding和元素）是没有任何改变的，只是因为margin变为-10，则它的领地位置变得是从边框往里缩进了10个像素，也就是说放在它前后左右的其他盒子(如果没有盒子的话，就是浏览器的边沿）都可以侵占到它bordern内10个像素。
我们可以得出如下结论：
a.padding是针对box的元素而言的，它指代的是内部元素与边框之间的区域。
b.margin则是针对于其他的box而言的，它表示边框能到的最远位置，也是其他的盒子能接触该盒子的极限位置。
3.盒子中的盒子
经过上面篇幅的介绍，我们大概知道了盒模型的主要元素。现在我们在google浏览器中将目标定位在box1中的h1元素。按照任何对象都是一个盒子的理论，这也是一个盒子。我们来看一下它的布局。

 
 我们看到，h1这个盒子，它的长X宽是300X42。margin和padding都是0.因为box1的长宽为300X300.所以整个h1到外边界的部分最大也就是300X300.我们可以做个试验，设置h1的padding和margin。

可以看到这时候的h1的element+padding+margin才是300.证明了我们的猜想：子盒子的外边界能到的最大地方就是父盒子的元素所规定的长宽。
4.盒子与盒子
再新建一个盒子，box2,其css如下所示。

#box2 {
    background-color: blue;
    width: 300px;
    height: 300px;
    padding: 5px;
}

观察到上面的css，我们没有设置box2的margin，来看看效果。

 
 因为box2没有设置margin，所以它的左侧是紧挨着浏览器边缘的。但是由于box1设置了margin，所以box1和box2接壤的地方是有5px的空间隔离的。
我们设置一下box2的margin，设为5px，再看看效果。

我们发现，两个box的margin折叠了，也就是说box1的下外边距+box2的上外边距并不是5+5=10，而是只有5.事实上，假如我们将其中一方的margin设置得比另一方大，则会取大的那一方为准。如下所示。

不仅在兄弟盒子之间会发生折叠，父子盒子之间也会。比如说box4是box3的子元素，两者都设置了margin，并且box3没有设置padding和border，那么box3和box4的top margin将会重合，box3与兄弟盒子之间的top margin为box3与box4之间较大者。

#box3 {
    background-color: yellow;
    width: 300px; 
    height : 300px;
    height: 300px;
    margin:5px;
/*     padding:5px; */
}
#box4 {
    background-color: green;
    width: 200px; 
    height: 200px;
    margin:50px;
}

上述的css的效果如下。可以看到除了top margin,box4其他的方面都可以按照我们对盒子的原本理解来解释。不管的左、右，下外边距都是相对于box3的element来说的。（box3的element为300X300，box3的外边距设置为50，所以实际的box4的元素为200X200.）。但是如你所见，box4上外边距跟box3重合了，他共同跟外部盒子的上外边距为两者中的大者（50px）,而box3的左右下外边距依然是5px.

 
而一旦设置了box3的上内边距，则上述的折叠现象将不复存在。如下图所示。

 
外边距的折叠只发生在普通的块之间的垂直位置上，行内框、浮动框或绝对定位之间的外边距不会折叠的，比如说当一个盒子被标注成float的时候。如下所示。

 
 可以发现两个盒子之间的margin为5+5=10了。
外边距合并初看上去可能有点奇怪，但是实际上，它是有意义的。以由几个段落组成的典型文本页面为例。第一个段落上面的空间等于段落的上外边距。如果没有外边距合并，后续所有段落之间的外边距都将是相邻上外边距和下外边距的和。这意味着段落之间的空间是页面顶部的两倍。如果发生外边距合并，段落之间的上外边距和下外边距就合并在一起，这样各处的距离就一致了。
总得来说，关于css的盒模型，要多去实践，才能发现其中的规律。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/roy-blog/p/8145500.html
====================================================================================================
2017我都干了啥？
****************************************************************************************************
前言
过完农历新年，我也即将奔入三十而立之年。对于男人来说，三十意味着更多的责任。回头看自己从毕业到现在五年，有进步，但稍稍有些遗憾，当初制定的目标：年薪百万，架构师统统么有实现。这不免让我想到了前段时间的“中兴跳楼事件”，我离他还远么？
想到这里，我不免有些难受，那种无力感就像我深陷泥沼，越挣扎陷入的越深，而我却只能眼睁睁的看着自己下沉。我感觉有些喘不过起来，我的脚，我的腿，我的腰，我的胸，我的脖子都慢慢的陷进深潭，我想呼喊但是发不出任何声音，就好像梦魇中失去了对自己控制。正当我准备放弃挣扎的时候，一条柔软却温暖的胳膊环上了我的脖子，清香的鼻息打在我脸上，就像春天拂过脸颊的微风。顿时我眼前一亮，是啊，我并不是什么都没有--因为今年我找到了女票。
消失的2016
2016年，我没有写年终总结，因为对我来说，这是痛苦的一年。父亲去世、对某厂工作内容不感兴趣（硬着头皮挺了一年）、被心仪的姑娘委婉拒绝，到最后我发现：如果我连自己最感兴趣的事情都不尝试去做，那么我还能指望自己在不感兴趣的领域有所收获么？
2017，我干了这些
可能是2016年运气差到了极点，所以2017年我的运气莫名好了很多，难道这就是否极泰来？我对新公司的工作感兴趣，并且做出了一定的成绩；我认识了我现在的女票，到现在为止第一个正式的女票（以前都是单方面的我喜欢她，或者她喜欢我）；业余时间阅读了感兴趣的书籍，充实自己的思想。这一切的幸福都敲门敲的太突然，给我敲的有点懵逼。
好了，言归正传。是时候认真总结今年的收获了，按照以往惯例，分为工作、学习、生活三个方面。
工作收获
去年年中换了新工作，从大厂跳到了一个小的创业公司。新公司的工作氛围很好，工作内容很有趣，相比在大厂只能修螺丝钉，我觉得在这里我才能有技术的积累，才能静下心来思考系统架构、程序设计等等问题，并且才能给我大胆尝试的机会。
总结这一年的工作，最主要的就是成本优化，当然成本优化过程是很长的，攻克不少难题，都在我下面的几篇博客中。

什么？-你的服务竟然被探活搞死了？
弹性伸缩服务实战：我是如何节省80%的机器成本的
最长公共子序列与最小编辑距离-你有更快的算法么？
我是怎么用跳表优化搜索引擎的？
我为什么要设计自己的流量调度算法？
一个自己研究出来的字符串匹配算法-k子串算法

除了以上这些确实带来收益的算法，我其实还研究学习了其它得算法，虽然最终没有应用在系统中，但是我也像在沙滩上拾到贝壳的孩子，欣喜的手舞足蹈。

快速傅里叶变换与卷积 本来想用来优化ocr识别中卷积计算，但是卷积核太小，导致快速傅里叶变换并没有什么优势。
KD树 突发奇想，忘记以前在什么地方听说过这个算法，索性就学习了一下。百度了好多博客，这些博客的问题在于：理论讲的很清楚，但是代码实现的不对，在我随机生成的1万组测试用例中，多数实现代码都不能完全给出正确答案。所以，自己就根据理解实现了一个正确版本，有机会可以分享一下。

在这一年中，也学习了新技术：

docker 快速部署，是我们弹性伸缩中不可缺少的一部分。
python 写一些控制逻辑和简单的http服务，比如弹性分配策略就是python实现的。
php 在大厂里写了一年，不做任何评论，公道自在人心。
学会使用Latex和Markdown。
业余时间自己设计了一个Rpc框架，比较粗糙，只做学习之用，有兴趣的小伙伴请看下面一系列的博客：
如何用一天时间实现自己的RPC框架
SimpleRpc-系统边界以及整体架构
SimpleRpc-网络事件响应Reactor设计模式
SimpleRpc-序列化与反序列化的设计与实现
SimpleRpc-客户端与服务端工作模型探讨

现在人工智能这么火，不会点机器学习简直都不好意思啊！可是相关的书是买了好几本，简单的分类方法也能看懂，但是没有深入的研究。
学习收获
这里面的学习我定义为除了工作以外的学习，主要目的就是满足自己的爱好，探索未知。不知道什么时候，我对经济学开始感兴趣，读了好几本经济学读物，感觉收获颇丰。虽然学习经济学也没钱买得起学区房，但是它让我有了自己的思考见解，不再跟随网上吃瓜群众人云亦云。我的经济学短文发布在简书上，微信公众号有少部分连载更新。

简书号：haolujun
微信公众号：张小白随想录
两个号不定期更新，迄今为止写了20+篇经济学文章，得到打赏60+元。曾经以为可以靠脸吃饭，现在发现靠写作也同样不能发家。

看过的书单如下：

《经济学通识》 薛兆丰著
讲的是近现代中国经济问题，比如“火车票涨价”等等，很有意思。可以认为是中国版的《魔鬼经济学》。
《正义的成本》 共三本 熊秉元著
主要讲法律经济学，如何用经济学思维去进行法律上裁判-飞机延误损失应该如何赔付？
《一课经济学》（美）亨利·黑兹利特著
简单容易理解，可以一看。
《微观经济学》曼昆著（重新看一遍）
这绝对是经济学最好的入门书，今年又仔仔细细的看了一遍，很多基础概念得到了更深刻的理解。
《魔鬼经济学》共四本 （美）史蒂芬·列维特，史蒂芬·都伯纳著
非常有趣的一套书，绝对值得一看。
《巨婴国》武志红著
一本心理学范畴的书，书中批判中国传统孝道，观点独树一帜。对于家中有孩子的人来说，绝对值得一看，它会在教育孩子方面给你很大帮助。
《身体知道答案》武志红著
俗话说“身体是最诚实”的，嘴上说“不要”，但是身体说“要”。咳咳，有点污。也是心理学范畴的一本书，如何界定本我，超我，还有情感边界。比如：我要考大学：是你自己内心想要考大学，还是大人们把考大学的观念强灌到你的脑子里的？
《解读中国经济》林毅夫著
此书对近代中国经济发展的研究非常透彻，一步到位，让人钦佩不已。书中的的“比较优势”理论，让人眼前一亮。
《解忧杂货店》 东野圭吾著
绝对烧脑，结局出人意料，可以一看。
《行动的勇气》 50%
个人对自传类其实不太感兴趣。本书通篇讲如何在美联储主席这个位置做决策，更多的是考虑民众对政策的反应，而对经济问题的分析个人感觉特别分散，需要自己穿起来才行。
《知乎周刊：日常经济学系列》
《我在故宫修文物》 30% 萧寒著
《经济学思维》李子旸著
里面写了好多有趣的案例，类似《经济学通识》，个人感觉有点虎头蛇尾。前面几篇写的很棒，后面几篇写的就一般了。

生活
今年生活最大的改变就是-我找到了现在的女朋友，感谢命运让我遇到了她。她美丽、善良、可爱、体贴、温柔，又有些俏皮，把我照顾的像个孩子，虽然她比我小了5岁。我们一起旅游，一起吃，一起胖。天津去坐那天津之眼，河北雾灵山上看那日出日落云卷云舒，张家界登奇峰怪石，襄阳城去追逐小说中的郭靖黄蓉。我知道，无论我在哪，她都会陪伴在我身边。现在我们正在考虑在哪定居的问题，这些问题也是必须要面对的。
由于父亲去世，家里就剩下了年迈的母亲，幸好姐姐在老家，时长过去照看，我在外面搬砖也放心。
我两年前养了只白猫-张小白，女票也有只橘猫-王小橙，现在把它俩放到一起养，天天打闹，玩的不亦乐乎，是一对感情很好的小伙伴。
总结与展望
2017总体来说还算满意，2018年希望自己能够不断学习新技术，接触新思想，新事物，牛掰的人；希望自己能够坚持写作；希望自己能够看20本书；希望自己能够减肥20斤；
希望总是太多，但不如当下就开始动手，边做边思考！最后，希望2018能够和园子里的小伙伴共同成长！

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/haolujun/p/8012288.html
====================================================================================================
前端MVC Vue2学习总结（四）——条件渲染、列表渲染、事件处理器
****************************************************************************************************
一、条件渲染
1.1、v-if
在字符串模板中，如 Handlebars ，我们得像这样写一个条件块：

<!-- Handlebars 模板 -->
{{#if ok}}
  <h1>Yes</h1>
{{/if}}

在 Vue.js ，我们使用 v-if 指令实现同样的功能：

<h1 v-if="ok">Yes</h1>

也可以用 v-else 添加一个 “else” 块：

<h1 v-if="ok">Yes</h1>
<h1 v-else>No</h1>

1.1.1、template v-if
因为 v-if 是一个指令，需要将它添加到一个元素上。但是如果我们想切换多个元素呢？此时我们可以把一个 <template> 元素当做包装元素，并在上面使用 v-if，最终的渲染结果不会包含它。

<template v-if="ok">
  <h1>Title</h1>
  <p>Paragraph 1</p>
  <p>Paragraph 2</p>
</template>

示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>条件渲染</title>
    </head>

    <body>
        <div id="app1">
            <p>
                <button type="button" @click="isShow=!isShow">Toggle isShow</button>
            </p>
            <h1 v-if="isShow">Yes</h1>
            <h1 v-else>No</h1>
            
            
            <template v-if="!isShow">
                <p>item1</p><p>item2</p><p>item3</p>
            </template>
            <template v-else>
                <p>item4</p><p>item5</p><p>item6</p>
            </template>
            
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    isShow: true
                }
            });
        </script>
    </body>

</html>

结果：

切换

1.1.2、v-else
可以用 v-else 指令给 v-if 添加一个 “else” 块：

<div v-if="Math.random() > 0.5">
  Sorry
</div>
<div v-else>
  Not sorry
</div>

v-else 元素必须紧跟在 v-if 元素的后面——否则它不能被识别。
1.1.3、v-else-if
2.1.0 新增v-else-if，顾名思义，充当 v-if 的“else-if 块”，可以连续使用：

<div v-if="type === 'A'">
  A
</div>
<div v-else-if="type === 'B'">
  B
</div>
<div v-else-if="type === 'C'">
  C
</div>
<div v-else>
  Not A/B/C
</div>

类似于 v-else，v-else-if 也必须紧跟在带 v-if 或者 v-else-if 的元素之后。
示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>条件渲染</title>
    </head>

    <body>
        <div id="app1">
            <div v-if="Math.random() > 0.5">
                Sorry
            </div>
            <div v-else>
                Not sorry
            </div>

            <div v-if="type === 'A'">
                A
            </div>
            <div v-else-if="type === 'B'">
                B
            </div>
            <div v-else-if="type === 'C'">
                C
            </div>
            <div v-else>
                Not A/B/C
            </div>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    type:"C"
                }
            });
        </script>
    </body>

</html>

 
结果：


1.1.4、用 key 管理可复用的元素
Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。这么做除了使 Vue 变得非常快之外，还有其它一些好处。例如，如果你允许用户在不同的登录方式之间切换：

<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address">
</template>

自己动手试一试，在输入框中输入一些文本，然后按下切换按钮：那么在上面的代码中切换 loginType 将不会清除用户已经输入的内容。因为两个模板使用了相同的元素，<input> 不会被替换掉——仅仅是替换了它的 placeholder。
示例：

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>条件渲染</title>
    </head>
    <body>
        <div id="app1">
            <template v-if="type==='username'">
                <label>帐号：</label>
                <input placeholder="请输入您的帐号" />
            </template>
            <template v-else>
                <label>邮箱：</label>
                <input placeholder="请输入您的电子邮箱" />
            </template>
            <p>
                <a href="" @click.prevent="type='username'">用户名登录</a> | <a href="" @click.prevent="type='email'">邮箱登录</a> 
            </p>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    isShow: true,
                    type: "username"
                }
            });
        </script>
    </body>
</html>

 
结果：

点击邮箱登录

这样也不总是符合实际需求，所以 Vue 为你提供了一种方式来表达“这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可：

<template v-if="loginType === 'username'">
  <label>Username</label>
  <input placeholder="Enter your username" key="username-input">
</template>
<template v-else>
  <label>Email</label>
  <input placeholder="Enter your email address" key="email-input">
</template>

现在，每次切换时，输入框都将被重新渲染。

        <div id="app1">
            <template v-if="type==='username'">
                <label>帐号：</label>
                <input placeholder="请输入您的帐号" key="username"/>
            </template>
            <template v-else>
                <label>邮箱：</label>
                <input placeholder="请输入您的电子邮箱" key="email"/>
            </template>
            <p>
                <a href="" @click.prevent="type='username'">用户名登录</a> | <a href="" @click.prevent="type='email'">邮箱登录</a> 
            </p>
        </div>

注意，<label> 元素仍然会被高效地复用，因为它们没有添加 key 属性。

1.1.5、v-show
另一个根据条件展示元素的选项是 v-show 指令。用法大体上一样：

<h1 v-show="ok">Hello!</h1>

不同的是有 v-show 的元素会始终渲染并保持在 DOM 中。v-show 是简单的切换元素的 CSS 属性 display 。
注意 v-show 不支持 <template> 语法。

1.2、v-if vs. v-show
v-if 是真实的条件渲染，因为它会确保条件块在切换当中适当地销毁与重建条件块内的事件监听器和子组件。
v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。
相比之下， v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。
一般来说， v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换使用 v-show 较好，如果在运行时条件不大可能改变则使用 v-if 较好。
官方文档： http://vuejs.org/guide/conditional.html
二、列表渲染
2.1、v-for
我们用 v-for 指令根据一组数组的选项列表进行渲染。 v-for 指令需要以item in items 形式的特殊语法， items 是源数据数组并且 item 是数组元素迭代的别名。
基本用法

<ul id="example-1">
  <li v-for="item in items">
    {{ item.message }}
  </li>
</ul>


var example1 = new Vue({
  el: '#example-1',
  data: {
    items: [
      {message: 'foo' },
      {message: 'Bar' }
    ]
  }
})

结果：

Foo
Bar

在 v-for 块中，我们拥有对父作用域属性的完全访问权限。 v-for 还支持一个可选的第二个参数为当前项的索引。

<ul id="example-2">
  <li v-for="(item, index) in items">
    {{ parentMessage }} - {{ index }} - {{ item.message }}
  </li>
</ul>


var example2 = new Vue({
  el: '#example-2',
  data: {
    parentMessage: 'Parent',
    items: [
      { message: 'Foo' },
      { message: 'Bar' }
    ]
  }
})

结果：

Parent - 0 - Foo
Parent - 1 - Bar

你也可以用 of 替代 in 作为分隔符，因为它是最接近 JavaScript 迭代器的语法：

<div v-for="item of items"></div>

2.1.1、Template v-for
如同 v-if 模板，你也可以用带有 v-for 的 <template> 标签来渲染多个元素块。例如：

<ul>
  <template v-for="item in items">
    <li>{{ item.msg }}</li>
    <li class="divider"></li>
  </template>
</ul>

2.1.2、对象迭代 v-for
你也可以用 v-for 通过一个对象的属性来迭代。

<ul id="repeat-object" class="demo">
  <li v-for="value in object">
    {{ value }}
  </li>
</ul>


new Vue({
  el: '#repeat-object',
  data: {
    object: {
      FirstName: 'John',
      LastName: 'Doe',
      Age: 30
    }
  }
})

结果：

John
Doe
30

你也可以提供第二个的参数为键名：

<div v-for="(value, key) in object">
  {{ key }} : {{ value }}
</div>

第三个参数为索引：

<div v-for="(value, key, index) in object">
  {{ index }}. {{ key }} : {{ value }}
</div>

在遍历对象时，是按 Object.keys() 的结果遍历，但是不能保证它的结果在不同的 JavaScript 引擎下是一致的。
2.1.3、整数迭代 v-for
v-for 也可以取整数。在这种情况下，它将重复多次模板。

<div>
  <span v-for="n in 10">{{ n }}</span>
</div>

结果：
1 2 3 4 5 6 7 8 9 10
 
示例：


<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>

    <body>
        <div id="app1">
            <ul>
                <template v-for="(user,index) in users">
                    <li>{{index+1}} - {{user.name}}</li>
                    <li>
                        <hr/>
                    </li>
                </template>
            </ul>

            <h3>遍历对象中的所有属性value</h3>
            <p v-for="value in product">
                {{value}}
            </p>
            <h3>遍历对象中的所有属性value - key</h3>
            <p v-for="(value,key) in product">
                {{key}} - {{value}}
            </p>

            <h3>遍历对象中的所有属性value - key - index</h3>
            <p v-for="(value,key,index) in product">
                {{index}} - {{key}} - {{value}}
            </p>
            <h3>整数迭代 v-for</h3>
            <span v-for="n in 20">
                {{n}} - 
            </span>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    users: [{
                            name: "tom",
                            age: 18
                        },
                        {
                            name: "rose",
                            age: 87
                        },
                        {
                            name: "mark",
                            age: 16
                        }
                    ],
                    product: {
                        name: "苹果",
                        price: 5.8,
                        unit: '千克'
                    }
                }
            });
        </script>
    </body>

</html>


结果：

2.1.4、组件 和 v-for

了解组件相关知识，查看  组件 。Feel free to skip it and come back later.

在自定义组件里，你可以像任何普通元素一样用 v-for 。

<my-component v-for="item in items"></my-component>

然而他不能自动传递数据到组件里，因为组件有自己独立的作用域。为了传递迭代数据到组件里，我们要用 props ：

<my-component
  v-for="(item, index) in items"
  v-bind:item="item"
  v-bind:index="index">
</my-component>

不自动注入 item 到组件里的原因是，因为这使得组件会紧密耦合到 v-for 如何运作。在一些情况下，明确数据的来源可以使组件可重用。
下面是一个简单的 todo list 完整的例子：

<div id="todo-list-example">
  <input
    v-model="newTodoText"
    v-on:keyup.enter="addNewTodo"
    placeholder="Add a todo"
  >
  <ul>
    <li
      is="todo-item"
      v-for="(todo, index) in todos"
      v-bind:title="todo"
      v-on:remove="todos.splice(index, 1)"
    ></li>
  </ul>
</div>


Vue.component('todo-item', {
  template: '
    <li>
      {{ title }}
      <button v-on:click="$emit(\'remove\')">X</button>
    </li>',
  props: ['title']
})
new Vue({
  el: '#todo-list-example',
  data: {
    newTodoText: '',
    todos: [
      'Do the dishes',
      'Take out the trash',
      'Mow the lawn'
    ]
  },
  methods: {
    addNewTodo: function () {
      this.todos.push(this.newTodoText)
      this.newTodoText = ''
    }
  }
})

示例：

<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>
    <body>
        <div id="app1">
            任务：<input v-model="newTask" @keyup.enter="addNew" placeholder="请输入您要完成的任务" />
            <ul>
                <li is="todoitem" v-for="(task,index) in tasks" :title="task" @remove="removeItem(index)"></li>
            </ul>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            Vue.component("todoitem", {
                template: "<li>{{title}} <button @click='$emit(\"remove\")'>X</button></li>",
                props: ['title']
            });

            var app1 = new Vue({
                el: "#app1",
                data: {
                    newTask: '',
                    tasks: ["买一本书", "给爸妈打电话", "整理自己的硬盘"]
                },
                methods: {
                    addNew: function() {
                        this.tasks.unshift(this.newTask);
                        this.newTask = '';
                    },
                    removeItem: function(index) {
                        if(confirm('确定要移除吗？')) {
                            this.tasks.splice(index, 1);
                        }
                    }
                }
            });
        </script>
    </body>
</html>

结果：

2.2、key
当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用 “就地复用” 策略。如果数据项的顺序被改变，而不是移动 DOM 元素来匹配数据项的顺序， Vue 将简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。这个类似 Vue 1.x 的track-by="$index" 。
这个默认的模式是有效的，但是只适用于不依赖子组件状态或临时 DOM 状态（例如：表单输入值）的列表渲染输出。
为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 key 属性。理想的 key 值是每项都有唯一 id。这个特殊的属性相当于 Vue 1.x 的 track-by ，但它的工作方式类似于一个属性，所以你需要用v-bind 来绑定动态值（在这里使用简写）：

<div v-for="item in items" :key="item.id">
  <!-- 内容 -->
</div>

建议尽可能使用 v-for 来提供 key ，除非迭代 DOM 内容足够简单，或者你是故意要依赖于默认行为来获得性能提升。
因为它是 Vue 识别节点的一个通用机制， key 并不特别与 v-for 关联，key 还具有其他用途，我们将在后面的指南中看到其他用途。
2.3、数组更新检测
2.3.1、变异方法
Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：

push()
pop()
shift()
unshift()
splice()
sort()
reverse()

你打开控制台，然后用前面例子的 items 数组调用突变方法：example1.items.push({ message: 'Baz' }) 。
2.3.2、重塑数组
变异方法(mutation method)，顾名思义，会改变被这些方法调用的原始数组。相比之下，也有非变异(non-mutating method)方法，例如： filter(), concat(), slice() 。这些不会改变原始数组，但总是返回一个新数组。当使用非变异方法时，可以用新数组替换旧数组：

example1.items = example1.items.filter(function (item) {
  return item.message.match(/Foo/)
})

你可能认为这将导致 Vue 丢弃现有 DOM 并重新渲染整个列表。幸运的是，事实并非如此。 Vue 实现了一些智能启发式方法来最大化 DOM 元素重用，所以用一个含有相同元素的数组去替换原来的数组是非常高效的操作。
示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>

    <body>
        <div id="app1">
            <ul>
                <li v-for="n in items">
                    <h2>{{n}}</h2>
                </li>
            </ul>
            <button @click="items.splice(0,3)">修改数组(变异)</button>
            <button @click="items.slice(0,3)">修改数组(不变异)</button>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    items:[1,3,5,7,9,2,4,6,8,0]
                }
            });
        </script>
    </body>

</html>

结果：

如果原数组发生了变化则View也会重新渲染，如果原数组未发生变化只是读取后返回了新的数组对象则不会渲染。
2.3.3、触发数组状态更新
由于 JavaScript 的限制， Vue 不能检测以下变动的数组：

当你直接设置一个项的索引时，例如： vm.items[indexOfItem] = newValue
当你修改数组的长度时，例如： vm.items.length = newLength

为了避免第一种情况，以下两种方式将达到像 vm.items[indexOfItem] = newValue 的效果， 同时也将触发状态更新：

// Vue.set
Vue.set(example1.items, indexOfItem, newValue)


// Array.prototype.splice`
example1.items.splice(indexOfItem, 1, newValue)

避免第二种情况，使用 splice：

example1.items.splice(newLength)

示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>

    <body>
        <div id="app1">
            <ul>
                <li v-for="n in items">
                    <h2>{{n}}</h2>
                </li>
            </ul>
            <button @click="items[2]=55">修改第3个元素的值为55(无效)</button>
            <button @click="setValue">Vue.set修改第3个元素的值为55</button>
            <button @click="items.splice(2,1,55)">Vue.set修改第3个元素的值为55</button>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    items: [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
                },
                methods: {
                    setValue: function() {
                        Vue.set(this.items, 2, 55);
                    }
                }
            });
        </script>
    </body>

</html>

结果：

2.4、对象更改检测注意事项
还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：

var vm = new Vue({
  data: {
    a: 1
  }
})
// `vm.a` 现在是响应式的

vm.b = 2
// `vm.b` 不是响应式的

对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 Vue.set(object, key, value) 方法向嵌套对象添加响应式属性。例如，对于：

var vm = new Vue({
  data: {
    userProfile: {
      name: 'Anika'
    }
  }
})

你可以添加一个新的 age 属性到嵌套的 userProfile 对象：

Vue.set(vm.userProfile, 'age', 27)

你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：

vm.$set(this.userProfile, 'age', 27)

有时你可能需要为已有对象赋予多个新属性，比如使用 Object.assign() 或 _.extend()。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：

Object.assign(this.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})

你应该这样做：

this.userProfile = Object.assign({}, this.userProfile, {
  age: 27,
  favoriteColor: 'Vue Green'
})

示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>对象更改检测注意事项</title>
    </head>

    <body>
        <div id="app1">
            <h2>对象更改检测注意事项</h2>
            {{stu.name}} - {{stu.age}}
            <p>
                <button @click="setAge">在stu对象中添加age属性并设置值为100</button>
            </p>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    stu:{
                        name:"tom"
                    }
                },
                methods:{
                    setAge:function(){
                        Vue.set(this.stu,'age',100);
                    }
                },
                beforeUpdate:function(){
                    console.log("更新前"+this.name);
                },
                updated:function(){
                    console.log("更新后"+this.name);
                }
            });
        </script>
    </body>

</html>

结果：

注意：
如果data中数据没有被绑定到DOM中，则修改后DOM不会更新，updated与beforeUpdate事件也不会执行（Hook function）
data 的根元素后加入无效，可以使用Vue.set添加元素中的属性，这样会变成响应式的成员
2.5、显示过滤/排序结果
有时，我们想要显示一个数组的过滤或排序副本，而不实际改变或重置原始数据。在这种情况下，可以创建返回过滤或排序数组的计算属性。
例如：

<li v-for="n in evenNumbers">{{ n }}</li>


data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
computed: {
  evenNumbers: function () {
    return this.numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}

或者，您也可以使用在计算属性是不可行的 method 方法 (例如，在嵌套 v-for 循环中)：

<li v-for="n in even(numbers)">{{ n }}</li>


data: {
  numbers: [ 1, 2, 3, 4, 5 ]
},
methods: {
  even: function (numbers) {
    return numbers.filter(function (number) {
      return number % 2 === 0
    })
  }
}

示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>

    <body>
        <div id="app1">
            <p>
                <span v-for="n in items">
                    {{n}}
                </span>
            </p>
            <p>
                <span v-for="n in even">
                    {{n}}
                </span></p>
            <p>
                <span v-for="n in odd()">
                    {{n}}
                </span></p>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    items: [1, 3, 5, 7, 9, 2, 4, 6, 8, 0]
                },
                computed: {
                    even: function() {
                        return this.items.filter(function(n) {
                            return n % 2 === 0;
                        });
                    }
                },
                methods: {
                    odd: function() {
                        return this.items.filter(function(n) {
                            return n % 2 === 1;
                        });
                    }
                }
            });
        </script>
    </body>

</html>

 
结果：

官方原文：  http://vuejs.org/guide/list.html
三、事件处理器
3.1、监听事件
可以用 v-on 指令监听 DOM 事件来触发一些 JavaScript 代码。
示例：

<div id="example-1">
  <button v-on:click="counter += 1">增加 1</button>
  <p>这个按钮被点击了 {{ counter }} 次。</p>
</div>


var example1 = new Vue({
  el: '#example-1',
  data: {
    counter: 0
  }
})

结果：
增加 1
这个按钮被点击了 0 次。

3.2、方法事件处理器
许多事件处理的逻辑都很复杂，所以直接把 JavaScript 代码写在 v-on 指令中是不可行的。因此 v-on 可以接收一个定义的方法来调用。
示例：

<div id="example-2">
  <!-- `greet` 是在下面定义的方法名 -->
  <button v-on:click="greet">Greet</button>
</div>


var example2 = new Vue({
  el: '#example-2',
  data: {
    name: 'Vue.js'
  },
  // 在 `methods` 对象中定义方法
  methods: {
    greet: function (event) {
      // `this` 在方法里指当前 Vue 实例
      alert('Hello ' + this.name + '!')
      // `event` 是原生 DOM 事件
      alert(event.target.tagName)
    }
  }
})
// 也可以用 JavaScript 直接调用方法
example2.greet() // -> 'Hello Vue.js!'

 
示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>事件</title>
    </head>

    <body>
        <div id="app1">
            <button v-on:click="greet">问好</button>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    name:"tom"
                },
                methods: {
                    greet:function(event){
                        console.log('Hello '+ this.name);
                        console.log('事件对象： '+ event.target.tagName);  //从事件对象中获得标签名
                        console.log(event);
                        //在原生的事件中this指向的是当前事件对象，这里是实例
                        event.target.innerHTML="问好了！";
                    }
                }
            });
        </script>
    </body>

</html>

 
结果：

 
3.3、内联处理器方法
除了直接绑定到一个方法，也可以用内联 JavaScript 语句：

<div id="example-3">
  <button v-on:click="say('hi')">Say hi</button>
  <button v-on:click="say('what')">Say what</button>
</div>


new Vue({
  el: '#example-3',
  methods: {
    say: function (message) {
      alert(message)
    }
  }
})

结果：
Say hi Say what
有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法：

<button v-on:click="warn('Form cannot be submitted yet.', $event)">Submit</button>


// ...
methods: {
  warn: function (message, event) {
    // 现在我们可以访问原生事件对象
    if (event) event.preventDefault()
    alert(message)
  }
}

3.4、事件修饰符
在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。
为了解决这个问题， Vue.js 为 v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。

.stop
.prevent
.capture
.self


<!-- 阻止单击事件冒泡 -->
<a v-on:click.stop="doThis"></a>
<!-- 提交事件不再重载页面 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联  -->
<a v-on:click.stop.prevent="doThat"></a>
<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>
<!-- 添加事件侦听器时使用事件捕获模式 -->
<div v-on:click.capture="doThis">...</div>
<!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 -->
<div v-on:click.self="doThat">...</div>

3.5、按键修饰符
在监听键盘事件时，我们经常需要监测常见的键值。 Vue 允许为 v-on 在监听键盘事件时添加按键修饰符：

<!-- 只有在 keyCode 是 13 时调用 vm.submit() -->
<input v-on:keyup.13="submit">

记住所有的 keyCode 比较困难，所以 Vue 为最常用的按键提供了别名：

<!-- 同上 -->
<input v-on:keyup.enter="submit">
<!-- 缩写语法 -->
<input @keyup.enter="submit">

全部的按键别名：

enter
tab
delete (捕获 “删除” 和 “退格” 键)
esc
space
up
down
left
right

可以通过全局 config.keyCodes 对象 自定义按键修饰符别名：

// 可以使用 v-on:keyup.f1
Vue.config.keyCodes.f1 = 112

3.6、为什么在 HTML 中监听事件?
你可能注意到这种事件监听的方式违背了关注点分离（separation of concern）传统理念。不必担心，因为所有的 Vue.js 事件处理方法和表达式都严格绑定在当前视图的 ViewModel 上，它不会导致任何维护上的困难。实际上，使用 v-on 有几个好处：


扫一眼 HTML 模板便能轻松定位在 JavaScript 代码里对应的方法。


因为你无须在 JavaScript 里手动绑定事件，你的 ViewModel 代码可以是非常纯粹的逻辑，和 DOM 完全解耦，更易于测试。


当一个 ViewModel 被销毁时，所有的事件处理器都会自动被删除。你无须担心如何自己清理它们。


原文： http://vuejs.org/guide/events.html
四、ES2015新增数组方法
ECMAScript2015中新增了9个方法，分别是：

Array.prototype.indexOf
Array.prototype.lastIndexOf
Array.prototype.every
Array.prototype.some
Array.prototype.forEach
Array.prototype.map
Array.prototype.filter
Array.prototype.reduce
Array.prototype.reduceRight

4.1、indexOf()找到的元素位置
indexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。不使用indexOf时：

var arr = ['apple','orange','pear'],
found = false;
for(var i= 0, l = arr.length; i< l; i++){
if(arr[i] === 'orange'){
found = true;
}
}
console.log("found:",found);

使用后：

var arr = ['apple','orange','pear'];
console.log("found:", arr.indexOf("orange") != -1);

4.2、filter()过滤
该filter()方法创建一个新的匹配过滤条件的数组。不用 filter() 时

var arr = [
{"name":"apple", "count": 2},
{"name":"orange", "count": 5},
{"name":"pear", "count": 3},
{"name":"orange", "count": 16},
];
var newArr = [];
for(var i= 0, l = arr.length; i< l; i++){
if(arr[i].name === "orange" ){
newArr.push(arr[i]);
}
}
console.log("Filter results:",newArr);

用了 filter():

var arr = [
{"name":"apple", "count": 2},
{"name":"orange", "count": 5},
{"name":"pear", "count": 3},
{"name":"orange", "count": 16},
];

var newArr = arr.filter(function(item){
return item.name === "orange";
});
console.log("Filter results:",newArr);

4.3、forEach()迭代
forEach为每个元素执行对应的方法

var arr = [1,2,3,4,5,6,7,8];

// Uses the usual "for" loop to iterate
for(var i= 0, l = arr.length; i< l; i++){
console.log(arr[i]);
}

console.log("========================");

//Uses forEach to iterate
arr.forEach(function(item,index){
console.log(item);
});

forEach是用来替换for循环的
4.4、map()映射
map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组
不使用map：

var oldArr = [{first_name:"Colin",last_name:"Toh"},{first_name:"Addy",last_name:"Osmani"},{first_name:"Yehuda",last_name:"Katz"}];

function getNewArr(){

var newArr = [];

for(var i= 0, l = oldArr.length; i< l; i++){
var item = oldArr[i];
item.full_name = [item.first_name,item.last_name].join(" ");
newArr[i] = item;
}

return newArr;
}

console.log(getNewArr());

使用map后：

var oldArr = [{first_name:"Colin",last_name:"Toh"},{first_name:"Addy",last_name:"Osmani"},{first_name:"Yehuda",last_name:"Katz"}];

function getNewArr(){

return oldArr.map(function(item,index){
item.full_name = [item.first_name,item.last_name].join(" ");
return item;
});

}

console.log(getNewArr());

map()是处理服务器返回数据时是一个非常实用的函数。
4.5、reduce()累加器
reduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值。说实话刚开始理解这句话有点难度，它太抽象了。场景： 统计一个数组中有多少个不重复的单词不使用reduce时：

var arr = ["apple","orange","apple","orange","pear","orange"];

function getWordCnt(){
var obj = {};

for(var i= 0, l = arr.length; i< l; i++){
var item = arr[i];
obj[item] = (obj[item] +1 ) || 1;
}

return obj;
}

console.log(getWordCnt());

使用reduce()后

var arr = ["apple","orange","apple","orange","pear","orange"];

function getWordCnt(){
return arr.reduce(function(prev,next){
prev[next] = (prev[next] + 1) || 1;
return prev;
},{});
}

console.log(getWordCnt());

让我先解释一下我自己对reduce的理解。reduce(callback, initialValue)会传入两个变量。回调函数(callback)和初始值(initialValue)。假设函数它有个传入参数，prev和next,index和array。prev和next你是必须要了解的。一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素。比如：

/*
* 二者的区别，在console中运行一下即可知晓
*/

var arr = ["apple","orange"];

function noPassValue(){
return arr.reduce(function(prev,next){
console.log("prev:",prev);
console.log("next:",next);

return prev + " " +next;
});
}
function passValue(){
return arr.reduce(function(prev,next){
console.log("prev:",prev);
console.log("next:",next);

prev[next] = 1;
return prev;
},{});
}

console.log("No Additional parameter:",noPassValue());
console.log("----------------");
console.log("With {} as an additional parameter:",passValue());

示例：

<!DOCTYPE html>
<html>

    <head>
        <meta charset="UTF-8">
        <title>列表渲染</title>
    </head>

    <body>
        <div id="app1">
            <span v-for="n in items">
                    {{n}} 
                </span>
            <button @click="indexOfMethod">indexOf()找到的元素位置</button>
            <button @click="filterMethod">filter()过滤</button>
            <button @click="forEachMethod">forEach()迭代</button>
            <button @click="mapMethod">map()映射</button>
            <button @click="reduceMethod">reduce()累加器</button>
        </div>
        <script src="../js/vue.js" type="text/javascript" charset="utf-8"></script>
        <script type="text/javascript">
            var app1 = new Vue({
                el: "#app1",
                data: {
                    items: [1, 3, 7, 9, 2, 4, 6, 8, 3],
                    fruits: [{
                            "name": "apple",
                            "count": 2
                        },
                        {
                            "name": "orange",
                            "count": 5
                        },
                        {
                            "name": "pear",
                            "count": 3
                        },
                        {
                            "name": "orange",
                            "count": 16
                        }
                    ],
                    words: ["apple", "orange", "apple", "orange", "pear", "orange"]
                },
                methods: {
                    indexOfMethod: function() {
                        console.log("数字3第一次出现的位置是：" + this.items.indexOf(3));
                        console.log("数字5第一次出现的位置是：" + this.items.indexOf(5));
                    },
                    filterMethod: function() {
                        //获得数量不小于5的水果
                        var arr1 = this.fruits.filter(function(f) {
                            return f.count >= 5;
                        });
                        console.log(JSON.stringify(arr1));
                        //获得名称中含有r的水果
                        var arr2 = this.fruits.filter(function(f) {
                            return f.name.match(/r/igm);
                        });
                        console.log(JSON.stringify(arr2));
                    },
                    forEachMethod: function() {
                        this.fruits.forEach(function(obj, index) {
                            console.log(index + "-" + obj.name + "-" + obj.count);
                        });
                    },
                    mapMethod: function() {
                        var arr3 = this.fruits.map(function(obj, index) {
                            obj.showInfo = index + "->水果：" + obj.name + "，数量：" + obj.count;
                            return obj;
                        });
                        console.log(JSON.stringify(arr3));
                    },
                    reduceMethod: function() {
                        var objs = {};
                        for(var i = 0, l = this.words.length; i < l; i++) {
                            var item = this.words[i];
                            objs[item] = (objs[item] + 1) || 1;
                        }
                        console.log(JSON.stringify(objs));

                        var objs2 = this.words.reduce(function(prev, next) {
                            console.log("prev:", JSON.stringify(prev));
                            console.log("next:", JSON.stringify(next));
                            prev[next] = (prev[next] + 1) || 1;
                            return prev;
                        }, {});
                        console.log(JSON.stringify(objs2));
                    }
                }
            });
        </script>
    </body>

</html>

结果：

结果

五、示例下载
https://git.coding.net/zhangguo5/vue2.git
小红书项目要求：
http://www.cnblogs.com/xsblog/p/8144290.html
六、视频
https://www.bilibili.com/video/av17503637/
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/best/p/8176281.html
====================================================================================================
KD树小结
****************************************************************************************************
很久之前我就想过怎么快速在二维平面上查找一个区域的信息，思考许久无果，只能想到几种优秀一点的暴力。
KD树就是干上面那件事的。
别的不多说，赶紧把自己的理解写下来，免得凉了。
 
KD树的组成
以维护k维空间(x,y,……)内的KD树为例，主要由一下三部分组成：

p[k]，代表树上这个结点所储存的点(在题目中给出的/你自己加上的点集中的一个点)。
ch[2]，表示它的子结点(没错，KD树是一棵二叉树)
mi[k]与mx[k]，mi/mx[i]代表KD树这个结点统辖的所有点的第i-1范围。比如说mi[1]=2,mx[1]=4，就代表这棵树统辖的点的y坐标都在[2,4]内。

 
不看mi和mx，长得就和splay/trie树一样，一个p维护当前节点，一个ch[2]记录左右儿子。
不看p[k]，长得就和线段树一样，有左右儿子和区间信息。
没错，KD树形功能如线段树，结点维护区域信息；形态如splay/trie树，每个结点有实际的值和意义。
 
KD树的构建
一般题目都是二维平面。下面就以二维平面KD树的构建为例。
读入把点存进结构体数组a中，坐标分别为a[x].p[i]。

inline void build(int &x,int l,int r,int type){
  x=(l+r)>>1;now=type;
  nth_element(a+l,a+x,a+r+1,cmp);
  nd=a[x];newnode(x);
  if(l<x)build(ch[x][0],l,x-1,type^1);else ch[x][0]=0;
  if(x<r)build(ch[x][1],x+1,r,type^1);else ch[x][1]=0;
  pushup(x);
}

build(kd.root,1,n,0);

非常优美……对type、now作用不明的同学请继续阅读……你要现在就明白就奇怪了
系统函数nth_element(a+l,a+x,a+r+1)，头文件algorithm，需定义＜或cmp函数。
作用：把排序后第x大的放到第x位，比它小的放进左边，比它大的放进右边(两边无序)。
注意区间开闭：左闭右开，中间也是闭合的。
复杂度：平均，期望是O(n)？可以接受。
下面给出cmp、newnode、pushup代码。

struct Node{int p[2],mi[2],mx[2];}a[N];
inline bool cmp(const Node &a,const Node &b){return a.p[now]<b.p[now];}
inline void Min(int &x,int y){x=x<y?x:y;}
inline void Max(int &x,int y){x=x>y?x:y;}
inline void pushup(int x){
  int ls=ch[x][0],rs=ch[x][1];
  if(ls){
    Min(T[x].mi[0],T[ls].mi[0]);Max(T[x].mx[0],T[ls].mx[0]);
    Min(T[x].mi[1],T[ls].mi[1]);Max(T[x].mx[1],T[ls].mx[1]);
  }
  if(rs){
    Min(T[x].mi[0],T[rs].mi[0]);Max(T[x].mx[0],T[rs].mx[0]);
    Min(T[x].mi[1],T[rs].mi[1]);Max(T[x].mx[1],T[rs].mx[1]);
  }
}

inline void newnode(int x){
  T[x].p[0]=T[x].mi[0]=T[x].mx[0]=nd.p[0];
  T[x].p[1]=T[x].mi[1]=T[x].mx[1]=nd.p[1];
}

不要问我为什么辣么长，为了减常冲榜，把循环展开了……
聪明的读者已经发现KD树的构建巧妙之处。它不是纯粹按照x维，或者某一维排序，而是先按x维，再按y维，再按z维，再……最后又回到x维……
这样分割的区域更加整齐划一更加均匀紧缩，不像上面的按照某一维划分，到最后变成一条条长条，KD树划分到底的图案还是很好看的。
这样分割有什么好处呢？等你真正领悟了KD树的精髓之后你就会发现……嘿嘿嘿……
(就是为了把这个暴力数据结构剪枝剪更多跑更快)
 
KD树的操作
1.往KD树上插点
插点可以分为插新点和插老点。如果有老点，特判一句，把信息覆盖即可。

inline void insert(int &x,int type){
  if(!x){x=++cnt,newnode(cnt);return;}
  if(nd.p[0]==T[x].p[0] && nd.p[1]==T[x].p[1]){
    ……(自行维护);return;
  }
  if(nd.p[type]<T[x].p[type])insert(ch[x][0],type^1);
  else insert(ch[x][1],type^1);
  pushup(x);
}

依然非常的美妙……等等有什么不对？
我们能估计出一棵刚建好的KD树深度是O(log)的。
但你这么随便乱插……有道题叫HNOI2017 spaly 插入不旋转的单旋spaly见过？T成苟。
这都不是问题！知不知道有一种数据结构叫做替罪羊树哇？
知道替罪羊树怎么保证复杂度的吗？
重构！大力重构！自信重构！不爽就重构！
为了省事大概每插入10000次就重构一次好了……

if(kd.cnt==sz){
  for(int i=1;i<=sz;++i)a[i]=kd.T[i];
  kd.rebuild(kd.root,1,sz,0);sz+=10000;
}

 
2.在KD树上查询

如果是单点(给定点)查询：

太简单啦！


如果是查询距离一个点(x',y')最近的点(曼哈顿距离，|x-x'|+|y-y'|)：

首先我们看暴力的剪枝：按某一维排序，如果该维的差过大就不管了。
而令我们期待的KD树呢？呃不好意思，它也是这么做的……
我们维护过两个叫做mi[]和mx[]的东西吧……这个时候就是它派上用场了。
具体还请看代码吧：

//查询的点(x',y')储存在nd中。
//这里的l,r就是mi,mx的意思。
inline int dis(Node p,int x,int ans=0){
  for(int i=0;i<2;++i)
    ans+=max(0,t[x].l[i]-p.p[i])+max(0,p.p[i]-t[x].r[i]);
  return ans;
}

inline void query(int x){
  Ans=min(Ans,abs(t[x].p[0]-nd.p[0])+abs(t[x].p[1]-nd.p[1]));
  int dl=ch[x][0]?dis(nd,ch[x][0]):Inf;
  int dr=ch[x][1]?dis(nd,ch[x][1]):Inf;
  if(dl<dr){
    if(dl<Ans)query(ch[x][0]);
    if(dr<Ans)query(ch[x][1]);
  }
  else{
    if(dr<Ans)query(ch[x][1]);
    if(dl<Ans)query(ch[x][0]);
  }
}


dis():如果当前点在这个区间内就是0，否则就是最极的点到它的距离。
聪明绝顶的你已经发现了……这TM就是个暴力。
其实这个数据结构就是一个暴力……
当暴力有了时间复杂度证明……还叫暴力么？读书人的事，能叫偷么？
这么暴力有几个好处：不用枚举所有点；剪枝有效及时。
复杂度有保障，大概在O(√n)级别下，主要看数据。


如果是区间查询，以区间查询点权和为例(之前就有维护好)：



inline bool in(int l,int r,int xl,int xr){return l<=xl && xr<=r;}
inline bool out(int l,int r,int xl,int xr){return xr<l || r<xl;}

inline int query(int x,int x1,int y1,int x2,int y2){
  int ans=0;if(!x)return ans;
  if(in(x1,x2,T[x].mi[0],T[x].mx[0]))
    if(in(y1,y2,T[x].mi[1],T[x].mx[1]))
      return T[x].sum;
  if(out(x1,x2,T[x].mi[0],T[x].mx[0]))return 0;
  if(out(y1,y2,T[x].mi[1],T[x].mx[1]))return 0;
  if(in(x1,x2,T[x].p[0],T[x].p[0]))
    if(in(y1,y2,T[x].p[1],T[x].p[1]))
      ans+=T[x].val;
  return ans+query(ch[x][0],x1,y1,x2,y2)+query(ch[x][1],x1,y1,x2,y2);
}


别看代码长又看起来复杂，写起来跟线段树似的，还是一样的暴力搞。



 
KD树的基本姿势大概就是这个样子……例题有"SJY摆棋子"、"简单题"等，在此就不做赘述了。
附上"BZOJ4066简单题"代码一份，操作是单点修改+矩形求和在线。
 


#include    <iostream>
#include    <cstdio>
#include    <cstdlib>
#include    <algorithm>
#include    <vector>
#include    <cstring>
#include    <queue>
#include    <complex>
#include    <stack>
#define LL long long int
#define dob double
#define FILE "bzoj_4066"
//#define FILE "简单题"
using namespace std;

const int N = 200010;
int n,lst,now,sz=10000;

inline int gi(){
  int x=0,res=1;char ch=getchar();
  while(ch>'9'||ch<'0'){if(ch=='-')res*=-1;ch=getchar();}
  while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();
  return x*res;
}

inline void Min(int &x,int y){x=x<y?x:y;}
inline void Max(int &x,int y){x=x>y?x:y;}
struct Node{int p[2],mi[2],mx[2],val,sum;}a[N];
inline bool cmp(const Node &a,const Node &b){return a.p[now]<b.p[now];}
struct KD_Tree{
  int ch[N][2],root,cnt;
  Node T[N],nd;

  inline void pushup(int x){
    int ls=ch[x][0],rs=ch[x][1];
    if(ls){
      Min(T[x].mi[0],T[ls].mi[0]);Max(T[x].mx[0],T[ls].mx[0]);
      Min(T[x].mi[1],T[ls].mi[1]);Max(T[x].mx[1],T[ls].mx[1]);
    }
    if(rs){
      Min(T[x].mi[0],T[rs].mi[0]);Max(T[x].mx[0],T[rs].mx[0]);
      Min(T[x].mi[1],T[rs].mi[1]);Max(T[x].mx[1],T[rs].mx[1]);
    }
    T[x].sum=T[x].val;
    if(ls)T[x].sum+=T[ls].sum;
    if(rs)T[x].sum+=T[rs].sum;
  }

  inline void newnode(int x){
    T[x].p[0]=T[x].mi[0]=T[x].mx[0]=nd.p[0];
    T[x].p[1]=T[x].mi[1]=T[x].mx[1]=nd.p[1];
    T[x].sum=T[x].val=nd.val;
  }
  
  inline void insert(int &x,int type){
    if(!x){x=++cnt,newnode(cnt);return;}
    if(nd.p[0]==T[x].p[0] && nd.p[1]==T[x].p[1]){
      T[x].val+=nd.val;T[x].sum+=nd.val;
      return;
    }
    if(nd.p[type]<T[x].p[type])insert(ch[x][0],type^1);
    else insert(ch[x][1],type^1);
    pushup(x);
  }
  
  inline void rebuild(int &x,int l,int r,int type){
    x=(l+r)>>1;now=type;
    nth_element(a+l,a+x,a+r+1,cmp);
    nd=a[x];newnode(x);
    if(l<x)rebuild(ch[x][0],l,x-1,type^1);else ch[x][0]=0;
    if(x<r)rebuild(ch[x][1],x+1,r,type^1);else ch[x][1]=0;
    pushup(x);
  }
  
  inline bool in(int l,int r,int xl,int xr){return l<=xl && xr<=r;}
  inline bool out(int l,int r,int xl,int xr){return xr<l || r<xl;}

  inline int query(int x,int x1,int y1,int x2,int y2){
    int ans=0;if(!x)return ans;
    if(in(x1,x2,T[x].mi[0],T[x].mx[0]))
      if(in(y1,y2,T[x].mi[1],T[x].mx[1]))
        return T[x].sum;
    if(out(x1,x2,T[x].mi[0],T[x].mx[0]))return 0;
    if(out(y1,y2,T[x].mi[1],T[x].mx[1]))return 0;
    if(in(x1,x2,T[x].p[0],T[x].p[0]))
      if(in(y1,y2,T[x].p[1],T[x].p[1]))
        ans+=T[x].val;
    return ans+query(ch[x][0],x1,y1,x2,y2)+query(ch[x][1],x1,y1,x2,y2);
  }
  
}kd;

int main()
{
  freopen(FILE".in","r",stdin);
  freopen(FILE".out","w",stdout);
  n=gi();
  while(1){
    int type=gi();if(type==3)break;
    int x1=gi()^lst,y1=gi()^lst;
    if(type==1){
      int A=gi()^lst;
      kd.nd.p[0]=x1;kd.nd.p[1]=y1;
      kd.nd.sum=kd.nd.val=A;
      kd.insert(kd.root,0);
      if(kd.cnt==sz){
        for(int i=1;i<=sz;++i)a[i]=kd.T[i];
        kd.rebuild(kd.root,1,sz,0);sz+=10000;
      }
    }
    if(type==2){
      int x2=gi()^lst,y2=gi()^lst;
      lst=kd.query(kd.root,x1,y1,x2,y2);
      printf("%d\n",lst);
    }
  }
  fclose(stdin);fclose(stdout);
  return 0;
}

简单题
 
 
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/fenghaoran/p/8176236.html
====================================================================================================
PredictionIO+Universal Recommender快速开发部署推荐引擎的问题总结(3)
****************************************************************************************************
PredictionIO+Universal Recommender虽然可以帮助中小企业快速的搭建部署基于用户行为协同过滤的个性化推荐引擎，单纯从引擎层面来看，开发成本近乎于零，但仍然需要一些前提条件。比如说，组织内部最好已经搭建了较稳定的Hadoop，Spark集群，至少要拥有一部分熟悉Spark平台的开发和运维人员，否则会需要技术团队花费很长时间来踩坑，试错。
本文列举了一些PredictionIO+Universal Recommender的使用过程中会遇到的Spark平台相关的异常信息，以及其解决思路和最终的解决办法，供参考。
 
1，执行训练时，发生java.lang.StackOverflowError错误
这个问题比较简单，查看文档，执行训练时，通过参数指定内存大小可以避免该问题，例如：

pio train  -- --driver-memory 8g --executor-memory 8g --verbose

 
2，执行训练时，发生找不到EmptyRDD方法的错误

Exception in thread "main" java.lang.NoSuchMethodError: org.apache.spark.SparkContext.emptyRDD(Lscala/reflect/ClassTag;)Lorg/apache/spark/rdd/EmptyRDD;
        at com.actionml.URAlgorithm.getRanksRDD(URAlgorithm.scala:534)
        at com.actionml.URAlgorithm.calcAll(URAlgorithm.scala:340)
        at com.actionml.URAlgorithm.train(URAlgorithm.scala:285)
        at com.actionml.URAlgorithm.train(URAlgorithm.scala:175)

这个是编译和执行环境的Spark版本不一致导致的。
Spark2.1.1 ，查看github上的spark源码发现
https://github.com/apache/spark/blob/v2.1.1/core/src/main/scala/org/apache/spark/SparkContext.scala
这个emptyRDD方法，虽然存在


/** Get an RDD that has no partitions or elements. */def emptyRDD[T: ClassTag]: RDD[T] = new EmptyRDD[T](this)


返回值类型和老版本相比，却发生了变化，不是EmptyRDD。所以在1.4.0下编译通过，2.1.1下执行失败。该方法的不同版本产生了不兼容。
如果采用我上一篇备忘录中所记述的方式修改过build.sbt，是可以避免这个问题的。
 
 
3，yarn和spark使用的jersey版本不一致的问题


[INFO] [ServerConnector] Started ServerConnector@bd93bc3{HTTP/1.1}{0.0.0.0:4040}
[INFO] [Server] Started @6428ms
Exception in thread "main" java.lang.NoClassDefFoundError: com/sun/jersey/api/client/config/ClientConfig
        at org.apache.hadoop.yarn.client.api.TimelineClient.createTimelineClient(TimelineClient.java:55)
        at org.apache.hadoop.yarn.client.api.impl.YarnClientImpl.createTimelineClient(YarnClientImpl.java:181)
        at org.apache.hadoop.yarn.client.api.impl.YarnClientImpl.serviceInit(YarnClientImpl.java:168)
        at org.apache.hadoop.service.AbstractService.init(AbstractService.java:163)
        at org.apache.spark.deploy.yarn.Client.submitApplication(Client.scala:151)
        at org.apache.spark.scheduler.cluster.YarnClientSchedulerBackend.start(YarnClientSchedulerBackend.scala:56)
        at org.apache.spark.scheduler.TaskSchedulerImpl.start(TaskSchedulerImpl.scala:156)
        at org.apache.spark.SparkContext.<init>(SparkContext.scala:509)
        at org.apache.predictionio.workflow.WorkflowContext$.apply(WorkflowContext.scala:45)
        at org.apache.predictionio.workflow.CoreWorkflow$.runTrain(CoreWorkflow.scala:59)
        at org.apache.predictionio.workflow.CreateWorkflow$.main(CreateWorkflow.scala:250)
        at org.apache.predictionio.workflow.CreateWorkflow.main(CreateWorkflow.scala)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:497)
        at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:738)
        at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:187)
        at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:212)
        at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:126)
        at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)
Caused by: java.lang.ClassNotFoundException: com.sun.jersey.api.client.config.ClientConfig
        at java.net.URLClassLoader.findClass(URLClassLoader.java:381)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:424)
        at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:331)
        at java.lang.ClassLoader.loadClass(ClassLoader.java:357)
        ... 21 more

修改方法：engine.json中的sparkConf中设置
"spark.hadoop.yarn.timeline-service.enabled": "false",
 
更深入了解此问题，参考：https://markobigdata.com/2016/08/01/apache-spark-2-0-0-installation-and-configuration/
 
 
4，yarn的空参数处理BUG


[INFO] [ContextHandler] Stopped o.s.j.s.ServletContextHandler@7772d266{/jobs,null,UNAVAILABLE}
[WARN] [YarnSchedulerBackend$YarnSchedulerEndpoint] Attempted to request executors before the AM has registered!
[WARN] [MetricsSystem] Stopping a MetricsSystem that is not running
Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 1
        at org.apache.spark.deploy.yarn.YarnSparkHadoopUtil$$anonfun$setEnvFromInputString$1.apply(YarnSparkHadoopUtil.scala:154)
        at org.apache.spark.deploy.yarn.YarnSparkHadoopUtil$$anonfun$setEnvFromInputString$1.apply(YarnSparkHadoopUtil.scala:152)
        at scala.collection.IndexedSeqOptimized$class.foreach(IndexedSeqOptimized.scala:33)
        at scala.collection.mutable.ArrayOps$ofRef.foreach(ArrayOps.scala:186)
        at org.apache.spark.deploy.yarn.YarnSparkHadoopUtil$.setEnvFromInputString(YarnSparkHadoopUtil.scala:152)
        at org.apache.spark.deploy.yarn.Client$$anonfun$setupLaunchEnv$6.apply(Client.scala:775)
        at org.apache.spark.deploy.yarn.Client$$anonfun$setupLaunchEnv$6.apply(Client.scala:773)
        at scala.Option.foreach(Option.scala:257)
        at org.apache.spark.deploy.yarn.Client.setupLaunchEnv(Client.scala:773)
        at org.apache.spark.deploy.yarn.Client.createContainerLaunchContext(Client.scala:867)
        at org.apache.spark.deploy.yarn.Client.submitApplication(Client.scala:170)
        at org.apache.spark.scheduler.cluster.YarnClientSchedulerBackend.start(YarnClientSchedulerBackend.scala:56)
        at org.apache.spark.scheduler.TaskSchedulerImpl.start(TaskSchedulerImpl.scala:156)
        at org.apache.spark.SparkContext.<init>(SparkContext.scala:509)
        at org.apache.predictionio.workflow.WorkflowContext$.apply(WorkflowContext.scala:45)
        at org.apache.predictionio.workflow.CoreWorkflow$.runTrain(CoreWorkflow.scala:59)
        at org.apache.predictionio.workflow.CreateWorkflow$.main(CreateWorkflow.scala:250)
        at org.apache.predictionio.workflow.CreateWorkflow.main(CreateWorkflow.scala)
        at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
        at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
        at java.lang.reflect.Method.invoke(Method.java:497)
        at org.apache.spark.deploy.SparkSubmit$.org$apache$spark$deploy$SparkSubmit$$runMain(SparkSubmit.scala:738)
        at org.apache.spark.deploy.SparkSubmit$.doRunMain$1(SparkSubmit.scala:187)
        at org.apache.spark.deploy.SparkSubmit$.submit(SparkSubmit.scala:212)
        at org.apache.spark.deploy.SparkSubmit$.main(SparkSubmit.scala:126)
        at org.apache.spark.deploy.SparkSubmit.main(SparkSubmit.scala)

是yarn的一个bug，无法正常处理空参数
https://stackoverflow.com/questions/37284336/spark-job-failing-with-java-lang-arrayindexoutofboundsexception-1
https://issues.apache.org/jira/browse/YARN-3768
 
解决方式：修改spark-env.sh，强制设置一个假参数，可以绕过这个问题

修改 spark/conf/spark-env.sh，增加下面这句话 


export SPARK_YARN_USER_ENV="HADOOP_CONF_DIR=/home/hadoop/apache-hadoop/etc/hadoop"

 

5，yarn的软连接BUG


[WARN] [TaskSetManager] Lost task 3.0 in stage 173.0 (TID 250, bigdata01, executor 3): java.lang.Error: Multiple ES-Hadoop versions detected in the classpath; please use only one
jar:file:/home/hadoop/apache-hadoop/hadoop/var/yarn/local-dir/usercache/hadoop/appcache/application_1504083960020_0030/container_e235_1504083960020_0030_01_000005/universal-recommender-assembly-0.6.0-deps.jar
jar:file:/home/hadoop/apache-hadoop/hadoop-2.7.2/var/yarn/local-dir/usercache/hadoop/appcache/application_1504083960020_0030/container_e235_1504083960020_0030_01_000005/universal-recommender-assembly-0.6.0-deps.jar

        at org.elasticsearch.hadoop.util.Version.<clinit>(Version.java:73)
        at org.elasticsearch.hadoop.rest.RestService.createWriter(RestService.java:570)
        at org.elasticsearch.spark.rdd.EsRDDWriter.write(EsRDDWriter.scala:58)
        at org.elasticsearch.spark.rdd.EsSpark$$anonfun$doSaveToEs$1.apply(EsSpark.scala:107)
        at org.elasticsearch.spark.rdd.EsSpark$$anonfun$doSaveToEs$1.apply(EsSpark.scala:107)
        at org.apache.spark.scheduler.ResultTask.runTask(ResultTask.scala:87)
        at org.apache.spark.scheduler.Task.run(Task.scala:99)
        at org.apache.spark.executor.Executor$TaskRunner.run(Executor.scala:282)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1142)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:617)
        at java.lang.Thread.run(Thread.java:745)

这不知道算不算一个BUG，总之，yarn的配置中如果使用了软连接来指定hadoop文件夹的路径，将有可能发生此问题。参考 https://interset.zendesk.com/hc/en-us/articles/230751687-PhoenixToElasticSearchJob-Fails-with-Multiple-ES-Hadoop-versions-detected-in-the-classpath-
解决方式也很简单，nodemanager修改所有采用Hadoop文件夹的软连接的配置，改为真正的路径即可。
 
6，Spark的JOB执行出错

[WARN] [Utils] Service 'sparkDriver' could not bind on port 0. Attempting port 1.
[ERROR] [SparkContext] Error initializing SparkContext.
Exception in thread "main" java.net.BindException: Cannot assign requested address: Service 'sparkDriver' failed after 60 retries (starting from 0)! Consider explicitly setting the appropriate port for the service 'sparkDriver' (for example spark.ui.port for SparkUI) to an available port or increasing spark.port.maxRetries.
        at sun.nio.ch.Net.bind0(Native Method)
        at sun.nio.ch.Net.bind(Net.java:437)
        at sun.nio.ch.Net.bind(Net.java:429)
        at sun.nio.ch.ServerSocketChannelImpl.bind(ServerSocketChannelImpl.java:223)
        at io.netty.channel.socket.nio.NioServerSocketChannel.doBind(NioServerSocketChannel.java:127)
        at io.netty.channel.AbstractChannel$AbstractUnsafe.bind(AbstractChannel.java:501)
        at io.netty.channel.DefaultChannelPipeline$HeadContext.bind(DefaultChannelPipeline.java:1218)
        at io.netty.channel.AbstractChannelHandlerContext.invokeBind(AbstractChannelHandlerContext.java:506)
        at io.netty.channel.AbstractChannelHandlerContext.bind(AbstractChannelHandlerContext.java:491)
        at io.netty.channel.DefaultChannelPipeline.bind(DefaultChannelPipeline.java:965)
        at io.netty.channel.AbstractChannel.bind(AbstractChannel.java:210)
        at io.netty.bootstrap.AbstractBootstrap$2.run(AbstractBootstrap.java:353)
        at io.netty.util.concurrent.SingleThreadEventExecutor.runAllTasks(SingleThreadEventExecutor.java:408)
        at io.netty.channel.nio.NioEventLoop.run(NioEventLoop.java:455)
        at io.netty.util.concurrent.SingleThreadEventExecutor$2.run(SingleThreadEventExecutor.java:140)
        at io.netty.util.concurrent.DefaultThreadFactory$DefaultRunnableDecorator.run(DefaultThreadFactory.java:144)
        at java.lang.Thread.run(Thread.java:745)

这个错误,网上的有很多文章让修改spark-env.sh ,增加 export SPARK_LOCAL_IP="127.0.0.1"
但这些网文其实只适用于单机SPARK的情况。这个IP是SPARK回调本机的地址，所以应该设置为本机的IP地址（用ifconfig查看本机真实IP）




 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/csliwei/p/8176518.html
====================================================================================================
2017年终总结
****************************************************************************************************
欢迎访问我的个人博客 ，原文链接：http://wensibo.top/2017/12/31/2017summary/ ，未经允许不得转载！
大家好，不知不觉已经有两个月的时间没有更新文章了，时间真是过得好快啊，转眼间2017也已经来到了最后一天，这篇文章就来记录和总结一下过去的这个2017年吧！
过去的两个月时间里状态不是很好，加上学校大四了还一大堆课，一大堆作业要做。本以为拿了offer就可以轻松看书学习了，想不到这段时间过得比找工作还累。本来计划的文章都没有写，拖延症太重了，不过最主要的原因还是自己的惰性太严重了，希望在接下来的新的一年里能有所改善吧！
2017年对我来说注定是不简单的一个年份，有收获有遗憾，收获的是有了人生中第一份工作、在开源世界上有了自己更多的贡献、阅读了许多经典的书籍让自己的知识的深度和广度上了一个台阶、当然也结识了许多志同道合优秀的朋友、同时趁着自己大学时光的最后一年也出去走走看看；当然遗憾也不少，总感觉时间不够用，也总感觉自己浪费了许多宝贵的年华，每每想到这些心头总是唏嘘不已。

关于实习和工作
今年一共有两次实习的经历，一个较长一个较短，较长的是在博雅，较短的是在CVTE，两家公司的同事和导师们都十分的nice，在这两段实习的时间里真的能够体会到商业项目与个人项目巨大的区别。前一段实习经历我记录在了这篇文章中，后一段实习则因为自己的拖延症迟迟没有写成文章，不过在这短短的一个星期的考核实习中我的导师以及领导对我的帮助确实是巨大的，尤其是在对工程框架、编码规范、设计模式以及性能优化方面，很感谢他们给我提出的意见。当然我觉得在实习中也有一个比较好的建议想与大家一起分享的，其实这对正式工作也是有很大帮助的，那就是在每天早上工作前先列一个任务清单，确定自己一天需要完成的任务，这能够让你对一天的工作量有所准备，同时也让你更有计划性；接着是一天工作完之后最好能花点时间总结一下今天的任务完成的如何，同时记录自己工作过程中的收货以及遇到的困难等等，我觉得这个方法对我这个菜鸟确实帮助挺大的。
关于工作，我之前也写过一篇文章：一个三非渣本的安卓秋招之路 ，不过当初在写文章的时候还没有确定正式签约的公司，最后我选择了珍爱网，希望在这里能够遇见美好。
关于开源
这一年我开始逐步的拥抱开源，在开源世界上吸收了许多前辈们贡献的成果和经验，当然在此基础上我也向开源世界开始贡献我的绵薄之力。
Github

上面这张图是我2017年总共的贡献图，实在惭愧，上半年完成的还是可以，但是到了下半年因为要实习还有找工作再加之拖延症一片惨不忍睹的白啊。

这一年一共写了9个项目，但是真正意义上的只有4个，其中start数量比较多的是GankClient这个项目,我也把这个APP上架到了酷安酷市场了，目前的下载量是1992，下面两张图展示了干货集中营的下载量和评论情况。


当然干货集中营这个APP还是需要感谢代码家的支持，以及许多写过干货集中营客户端的前辈们，我也是在向你们借鉴学习的过程中完成的。
关于博客
2017年1月份开始搭建的独立个人博客，在这一年的时间里网站总访客数：22725，网站总访问量：59067

在这一年里时间里，真的很感谢大家的支持，同时博客文章的内容质量不断的提升，博客内容应用层逐步转向系统层面，今后要与大家分享的则会是关于底层方面的知识。

全年一共写了23篇文章，加上这篇就是24篇，但是从9月份开始更新频率就下了许多，原本是计划每个月2-3篇文章的，来年加油啦！
当然除了在自己的博客上写之外，我还同步在掘金，简书，博客园这三个第三方网站上，当然我会更喜欢掘金一些，因为在掘金上分享技术更为纯粹，并且它也只分享技术，今天偶然查看自己的主页，原来已经有188人关注我啦，获得的start数量也有761个，文章的阅读数量为17459。

看书
今年看的书不少，下面这张图是我认真看并且觉得不错的书。

还有几本书有的借人了，有的放在图书馆没有拿回来没有拍照，列在下面供大家参考。

Android进阶之光
Android开发艺术探索
高性能Android应用开发
网络是怎样连接的
算法（第4版）
程序员的算法趣题
Java编程思想（第四版）
Gradle for Android (PDF)

其中《鸟哥的私房菜》、《Java编程思想》没有全部看完，只看了其中的一部分。讲真今年买书花了还挺多钱的，但是如果对自己有所帮助还是很愿意投资的，并且也知道作者出书不容易，应该支持正版啦！
朋友
写博客确实认识了许多志同道合的朋友，这里不能一一举例实在抱歉，向大家推荐两个我比较熟悉的大神，两位都还是学生，@Carson_Ho是研究生，@Tonny则跟我一样也是大四，两位大神比我厉害多了，我也经常看他们的博客和开源项目，@Carson_Ho博客的更新频率真的很赞，一个月都有几篇，这一点真的很棒啊，希望以后我也能向他这样。
世界那么大我想去走走
大学最后一年，也想利用着最后的一点时间出去走走看看，于是就去了成都和重庆，讲真我可能是假的广东人，并不觉得四川和重庆的很辣，难道是我吃了假的辣椒？


遗憾
2017年遗憾的事情还是挺多的，究其原因还是自己有的时候太懒惰了，没有一直坚持下去，无论是写博客还是开源项目，到了下半年都有所松懈。再加之我也很容易被琐碎的事情打扰，也因为如此很多事情都中途而费了，希望来年自己能够在这方面有所改进。
2018年展望
2018年自己将迎来工作的第一个年头，希望自己能够尽快适应新的工作环境，在工作上能够有所建树。当然在技术学习的道路上也应用永无止境，自己也已经开始准备学习人工智能和深度学习方面的内容，技术人唯有不断学习才不会太快被淘汰。2018年博客将会继续更新，接下来将会写一个有关Gradle的系列文章，到后面还会与大家一起分享更多流行的技术；文章的更新频率方面会比今年做的更好，在工作学习之余会抽出更多的时间来更新文章。
最后祝大家2018年新年快乐，新的一年大家都能心想事成！

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/ghylzwsb/p/2017summary.html
====================================================================================================
工厂方法模式(Method Factory),理解多态应用的好例子.
****************************************************************************************************
工厂方法模式又称为多态性工厂,个人认为多态性工厂更能准确的表达这个模式的用处.与简单工厂(静态工厂)相比较,这里的多态性是指抽象出一个工厂基类,将因为一个产品有N种不同的是现这种变化封装起来,将具体的实例化延迟到了工厂类的子类中来实现.
谈谈耦合关系先
面向对象设计模式的学习重点应该是寻找业务变化的点,让紧耦合变的松一些,这样面对需求变化修改代码时才会付出最小的代价,同时也实现了代码的复用,维护.学习的重点不应该放在代码,结构,这些表现形式上.模块之间的紧耦合关系在面对业务变化时是非常脆弱的,会因为一处的修改导致好多地方跟着修改,在面向对象设计中,将高层模块(抽象层)与低层模块(实现层)隔离开,因为抽象层相对稳定,而实现层正是业务需求变化的部分,这也就是依赖倒置原则,可以说整个设计模式都是围绕着寻找抽象层与实现层来展开的.
意图
定义一个用于创建对象的接口,让子类决定实例化哪个类,把实例化工作延迟到子类.
结构

从上图中可以看出,AbstractFactory抽象出了一个createProduct()方法,具体的实现交给了FactoryImplA与FactoryImplB两个实现类,分别对应创建ProductImplA与ProductImplB. 客户端代码调用时直接new的方式给出FactoryImplX具体实例,返回AbstractProduct抽象产品对象.
代码演示
package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 抽象产品
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public interface AbstractProduct
{
    public String getProductInfo() ;
}


package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 工厂方法基类
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public abstract class AbstractFactory
{
    public abstract  AbstractProduct createProdct() ;
}

package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 具体的工厂
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public class FactoryImplA  extends AbstractFactory
{
    @Override
    public AbstractProduct createProdct ()
    {
        return new ProductImplA ();
    }
}

package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 工厂实现B
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public class FactoryImplB extends AbstractFactory
{
    @Override
    public AbstractProduct createProdct ()
    {
        return new ProductImplB () ;
    }
}

package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 具体实现A
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public class ProductImplA implements AbstractProduct
{
    @Override
    public String getProductInfo ()
    {
        return "ProductA_IMPL";
    }
}

package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 具体实现B
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public class ProductImplB implements AbstractProduct
{
    @Override
    public String getProductInfo ()
    {
        return "ProductB_IMPL";
    }
}


package com.j2kaka.coolka.common.pattern.factorymethod;

/**
 * 调用处
 *
 * @author aladdinty
 * @create 2018-01-02
 **/
public class Client
{
    public static void main(String[] args )
    {
        AbstractProduct producta = new FactoryImplA ().createProdct () ;
        System.out.println (producta.getProductInfo ());

        AbstractProduct productb = new FactoryImplB ().createProdct () ;
        System.out.println ( productb.getProductInfo () );
    }


}

运行结果
ProductA_IMPL
ProductB_IMPL
应对修改
如果需要增加新的Product实现,只需要增加一个ProductImplXX,再对应增加一个FactoryImplXX,然后修改一下Client的调用处new FactoryImplXX(),当然这个地方可以用反射之类的技术来替代. 应对这种Product产品实现修改的需求时,工厂方法模式完全符合开闭原则. 而之前所说的简单工厂模式则无法做到,因为要修改工厂方法内部的if else判断.当然也不是说工厂方法模式就比简单方法模式高级,只是应用场景不同,工厂方法解决的变化点是产品类型的不固定变化.而简单工厂只是解决调用处对具体产品实现的隔离,假设产品的实现是相对稳定的.

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/aladdinty/p/8176973.html
====================================================================================================
C#设计模式之二十二备忘录模式（Memento Pattern）【行为型】
****************************************************************************************************
一、引言   今天我们开始讲“行为型”设计模式的第十个模式，该模式是【备忘录模式】，英文名称是：Memento Pattern。按老规矩，先从名称上来看看这个模式，个人的最初理解就是对某个对象的状态进行保存，等到需要恢复的时候，可以从备忘录中进行恢复。生活中这样的例子也能经常看到，如备份电话通讯录，备份操作操作系统，备份数据库等。如果我们想恢复对象的状态，那么我们可能首先想到的是把对象保存下来，但是这样会破坏对象的封装性。因为对象有状态有操作，如果我们为了保存对象而留着原来的对象，做一个深拷贝，那么其他对象也能通过这个对象的接口访问这个对象状态，这并不是我们所希望的。而我们需要它的职责只是保存和恢复对象状态，而不应在上面支持对对象状态访问的接口，这就产生了Memento模式。        
     我们看上图，一个对象肯定会有很多状态，这些状态肯定会相互转变而促进对象的发展，如果要想在某一时刻把当前对象回复到以前某一时刻的状态，这个情况用“备忘录模式”就能很好解决该问题。二、备忘录模式的详细介绍2.1、动机（Motivate）   在软件构建过程中，某些对象的状态在转换的过程中，可能由于某种需要，要求程序能够回溯到对象之前处于某个点时的状态。如果使用一些公有接口来让其他对象得到对象的状态，便会暴露对象的细节实现。　 如何实现对象状态的良好保存与恢复，但同时又不会因此而破坏对象本身的封装性？2.2、意图（Intent）   在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态（如果没有这个关键点，其实深拷贝就可以解决问题）。这样以后就可以将该对象恢复到原先保存的状态。　　　　　　                                ——《设计模式》GoF2.3、结构图（Structure）       2.4、模式的组成        可以看出，在备忘录模式的结构图有以下角色：     （1）、发起人角色（Originator）：记录当前时刻的内部状态，负责创建和恢复备忘录数据。负责创建一个备忘录Memento，用以记录当前时刻自身的内部状态，并可使用备忘录恢复内部状态。Originator【发起人】可以根据需要决定Memento【备忘录】存储自己的哪些内部状态。    （2）、备忘录角色（Memento）：负责存储发起人对象的内部状态，在进行恢复时提供给发起人需要的状态，并可以防止Originator以外的其他对象访问备忘录。备忘录有两个接口：Caretaker【管理角色】只能看到备忘录的窄接口，他只能将备忘录传递给其他对象。Originator【发起人】却可看到备忘录的宽接口，允许它访问返回到先前状态所需要的所有数据。    （3）、管理者角色（Caretaker）：负责保存备忘录对象。负责备忘录Memento，不能对Memento的内容进行访问或者操作。2.5、备忘录模式的代码实现    今天我们就用备份电话本的实例来说明备忘录模式的实现。实现代码如下：  

  1 namespace MementoPattern
  2 {
  3     // 联系人--需要备份的数据，是状态数据，没有操作
  4     public sealed class ContactPerson
  5     {
  6         //姓名
  7         public string Name { get; set; }
  8 
  9         //电话号码
 10         public string MobileNumber { get; set; }
 11     }
 12  
 13     // 发起人--相当于【发起人角色】Originator
 14     public sealed class MobileBackOriginator
 15     {
 16         // 发起人需要保存的内部状态
 17         private List<ContactPerson> _personList;
 18 
 19         
 20         public List<ContactPerson> ContactPersonList
 21         {
 22            get
 23            {
 24               return this._personList;
 25             }
 26 
 27            set
 28            {
 29               this._personList=value;
 30            }
 31         }
 32         //初始化需要备份的电话名单
 33         public MobileBackOriginator(List<ContactPerson> personList)
 34         {
 35             if(personList!=null)
 36             {
 37                 this._personList = personList;
 38              }
 39             else
 40             {
 41                throw new ArgumentNullException("参数不能为空！");
 42              }
 43         }
 44  
 45         // 创建备忘录对象实例，将当期要保存的联系人列表保存到备忘录对象中
 46         public ContactPersonMemento CreateMemento()
 47         {
 48             return new ContactPersonMemento(new List<ContactPerson>(this._personList));
 49         }
 50  
 51         // 将备忘录中的数据备份还原到联系人列表中
 52         public void RestoreMemento(ContactPersonMemento memento)
 53         {
 54             this.ContactPersonList = memento.ContactPersonListBack;
 55         }
 56  
 57         public void Show()
 58         {
 59             Console.WriteLine("联系人列表中共有{0}个人，他们是:", ContactPersonList.Count);
 60             foreach (ContactPerson p in ContactPersonList)
 61             {
 62                 Console.WriteLine("姓名: {0} 号码: {1}", p.Name, p.MobileNumber);
 63             }
 64         }
 65     }
 66  
 67     // 备忘录对象，用于保存状态数据，保存的是当时对象具体状态数据--相当于【备忘录角色】Memeto
 68     public sealed class ContactPersonMemento
 69     {
 70         // 保存发起人创建的电话名单数据，就是所谓的状态
 71         public List<ContactPerson> ContactPersonListBack{get;private set;};
 72  
 73         public ContactMemento(List<ContactPerson> personList)
 74         {
 75             ContactPersonListBack = personList;
 76         }
 77     }
 78  
 79     // 管理角色，它可以管理【备忘录】对象，如果是保存多个【备忘录】对象，当然可以对保存的对象进行增、删等管理处理---相当于【管理者角色】Caretaker
 80     public sealed class MementoManager
 81     {
 82         //如果想保存多个【备忘录】对象，可以通过字典或者堆栈来保存，堆栈对象可以反映保存对象的先后顺序
 83         //比如：public Dictionary<string, ContactPersonMemento> ContactPersonMementoDictionary { get; set; }
 84         public ContactPersonMemento ContactPersonMemento{ get; set; }
 85     }
 86  
 87     class Program
 88     {
 89         static void Main(string[] args)
 90         {
 91             List<ContactPerson> persons = new List<ContactPerson>()
 92             {
 93                 new ContactPerson() { Name="黄飞鸿", MobileNum = "13533332222"},
 94                 new ContactPerson() { Name="方世玉", MobileNum = "13966554433"},
 95                 new ContactPerson() { Name="洪熙官", MobileNum = "13198765544"}
 96             };
 97 
 98             //手机名单发起人
 99             MobileBackOriginator mobileOriginator = new MobileBackOriginator(persons);
100             mobileOriginator.Show();
101  
102             // 创建备忘录并保存备忘录对象
103             MementoManager manager = new MementoManager();
104             manager.ContactPersonMemento = mobileOriginator.CreateMemento();
105  
106             // 更改发起人联系人列表
107             Console.WriteLine("----移除最后一个联系人--------");
108             mobileOriginator.ContactPersonList.RemoveAt(2);
109             mobileOriginator.Show();
110  
111             // 恢复到原始状态
112             Console.WriteLine("-------恢复联系人列表------");
113             mobileOriginator.RestoreMemento(manager.ContactPersonMemento);
114             mobileOriginator.Show();
115  
116             Console.Read();
117         }
118     }
119 }

三、备忘录模式的实现要点：        备忘录（Memento）存储原发器（Originator）对象的内部状态，在需要时恢复原发器状态。Memento模式适用于“由原发器管理，却又必须存储在原发器之外的信息”。　　在实现Memento模式中，要防止原发器以外的对象访问备忘录对象。备忘录对象有两个接口，一个为原发器使用的宽接口；一个为其他对象使用的窄接口。在实现Memento模式时，要考虑拷贝对象状态的效率问题，如果对象开销比较大，可以采用某种增量式改变（即只记住改变的状态）来改进Memento模式。　　我们也可以用序列化的方式实现备忘录。序列化之后，我们可以把它临时性保存到数据库、文件、进程内、进程外等地方。    （1）、备忘录模式的主要优点有：            1】、如果某个操作错误地破坏了数据的完整性，此时可以使用备忘录模式将数据恢复成原来正确的数据。            2】、备份的状态数据保存在发起人角色之外，这样发起人就不需要对各个备份的状态进行管理。而是由备忘录角色进行管理，而备忘录角色又是由管理者角色管理，符合单一职责原则。            3】、提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用先前存储起来的备忘录将状态复原。            4】、实现了信息的封装，一个备忘录对象是一种原发器对象的表示，不会被其他代码改动，这种模式简化了原发器对象，备忘录只保存原发器的状态，采用堆栈来存储备忘录对象可以实现多次撤销操作，可以通过在负责人中定义集合对象来存储多个备忘录。　　            5】、本模式简化了发起人类。发起人不再需要管理和保存其内部状态的一个个版本，客户端可以自行管理他们所需要的这些状态的版本。　　            6】、当发起人角色的状态改变的时候，有可能这个状态无效，这时候就可以使用暂时存储起来的备忘录将状态复原。　（2）、备忘录模式的主要缺点有：            1】、在实际的系统中，可能需要维护多个备份，需要额外的资源，这样对资源的消耗比较严重。资源消耗过大，如果类的成员变量太多，就不可避免占用大量的内存，而且每保存一次对象的状态都需要消耗内存资源，如果知道这一点大家就容易理解为什么一些提供了撤销功能的软件在运行时所需的内存和硬盘空间比较大了。            2】、如果发起人角色的状态需要完整地存储到备忘录对象中，那么在资源消耗上面备忘录对象会很昂贵。　　    3】、当负责人角色将一个备忘录 存储起来的时候，负责人可能并不知道这个状态会占用多大的存储空间，从而无法提醒用户一个操作是否很昂贵。　　    4】、当发起人角色的状态改变的时候，有可能这个协议无效。如果状态改变的成功率不高的话，不如采取“假如”协议模式。    （3）、在下面的情况下可以考虑使用备忘录模式：          1】、如果系统需要提供回滚操作时，使用备忘录模式非常合适。例如文本编辑器的Ctrl+Z撤销操作的实现，数据库中事务操作。          2】、保存一个对象在某一个时刻的状态或部分状态，这样以后需要时它能够恢复到先前的状态。          3】、如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过负责人可以间接访问其内部状态。          4】、有时一些发起人对象的内部信息必须保存在发起人对象以外的地方，但是必须要由发起人对象自己读取，这时，使用备忘录模式可以把复杂的发起人内部信息对其他的对象屏蔽起来，从而可以恰当地保持封装的边界。    （4）备忘录的封装性         1】、为了确保备忘录的封装性，除了原发器外，其他类是不能也不应该访问备忘录类的，在实际开发中，原发器与备忘录之间的关系是非常特殊的，它们要分享信息而不让其他类知道，实现的方法因编程语言的不同而不同。    （5）多备份实现         1】、在负责人中定义一个集合对象来存储多个状态，而且可以方便地返回到某一历史状态。         2】、在备份对象时可以做一些记号，这些记号称为检查点(Check Point)。在使用HashMap等实现时可以使用Key来设置检查点。四、.NET 备忘录模式的实现     在现在的Net框架里面，还没有找到备忘录模式的实现，看来还是自己的功力不够，还需努力。个人的理解，这种模式似乎在业务系统里面使用的更多，类似Word,Excel等工具可以有撤销功能，其实很多软件都有这个功能，软件执行的时候，时时刻刻在把自己的状态存储，如果发生错误，或者需要撤销的时候就可以进行相关的操作。五、总结     备忘录模式写完了，这个模式刚开始理解起来还是挺麻烦的，但是，如果我们多看几个实例代码，完全掌握也不是问题。我们是不是感觉Memento模式和Command模式有些类似，我们要仔细把握模式之间的异同，否则使用模式的时候就会出现张冠李戴的情况或者不能确定使用哪个模式好。Memento备忘录模式和Command命令模式其实还是有些细微的差别的，那就让我们来看看他们的异同吧。虽然两者都支持Undo操作，但是Command是对行为的封装，Memento是对对象状态的保留，这是目的上的不同。它们支持的也是Undo操作的不同层面，Command是对行为序列的操作，Memento是对行为状态的操作。命令模式保存的是发起人的具体命令（命令对应的是行为），而备忘录模式保存的是发起人的状态（而状态对应的数据结构，如属性）。把握细节，理解模式的应用场景，这样可以让模式更好的为我们服务。
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/PatrickLiu/p/8176974.html
====================================================================================================
[数据清洗]-混乱的邮编数据
****************************************************************************************************
 内容概要：


我们怎么知道是混乱的数据


修复 nan 值和字符串/浮点类型的混乱问题


“-”怎么处理


整合代码



# 导入需要的包
import pandas as pd
import numpy as np

# 可以展示比较多的列，60 列
pd.set_option('display.line_width', 5000) 
pd.set_option('display.max_columns', 60)

 混杂数据最重要的一个问题就是：怎么知道是否是混杂的数据。
下面准备使用 NYC 311 服务请求数据集，因为这个是一个庞杂的数据集。

requests = pd.read_csv('../data/311-service-requests.csv')

 
我们怎么知道是混乱的数据
我们开始少看几列，因为现在一直 Zip Code（邮编）有些问题，所以我们首先看看这个。
为了搞清楚 whether 列是否有问题，常常使用 .unique() 来查看一列的所有数据。如果是一个数值类型的列，最好使用一个直方图来获取数值的分布情况。

requests['Incident Zip'].unique()

array([11432.0, 11378.0, 10032.0, 10023.0, 10027.0, 11372.0, 11419.0,
       11417.0, 10011.0, 11225.0, 11218.0, 10003.0, 10029.0, 10466.0,
       11219.0, 10025.0, 10310.0, 11236.0, nan, 10033.0, 11216.0, 10016.0,
       10305.0, 10312.0, 10026.0, 10309.0, 10036.0, 11433.0, 11235.0,
       11213.0, 11379.0, 11101.0, 10014.0, 11231.0, 11234.0, 10457.0,
       10459.0, 10465.0, 11207.0, 10002.0, 10034.0, 11233.0, 10453.0,
       10456.0, 10469.0, 11374.0, 11221.0, 11421.0, 11215.0, 10007.0,
       10019.0, 11205.0, 11418.0, 11369.0, 11249.0, 10005.0, 10009.0,
       11211.0, 11412.0, 10458.0, 11229.0, 10065.0, 10030.0, 11222.0,
       10024.0, 10013.0, 11420.0, 11365.0, 10012.0, 11214.0, 11212.0,
       10022.0, 11232.0, 11040.0, 11226.0, 10281.0, 11102.0, 11208.0,
       10001.0, 10472.0, 11414.0, 11223.0, 10040.0, 11220.0, 11373.0,
       11203.0, 11691.0, 11356.0, 10017.0, 10452.0, 10280.0, 11217.0,
       10031.0, 11201.0, 11358.0, 10128.0, 11423.0, 10039.0, 10010.0,
       11209.0, 10021.0, 10037.0, 11413.0, 11375.0, 11238.0, 10473.0,
       11103.0, 11354.0, 11361.0, 11106.0, 11385.0, 10463.0, 10467.0,
       11204.0, 11237.0, 11377.0, 11364.0, 11434.0, 11435.0, 11210.0,
       11228.0, 11368.0, 11694.0, 10464.0, 11415.0, 10314.0, 10301.0,
       10018.0, 10038.0, 11105.0, 11230.0, 10468.0, 11104.0, 10471.0,
       11416.0, 10075.0, 11422.0, 11355.0, 10028.0, 10462.0, 10306.0,
       10461.0, 11224.0, 11429.0, 10035.0, 11366.0, 11362.0, 11206.0,
       10460.0, 10304.0, 11360.0, 11411.0, 10455.0, 10475.0, 10069.0,
       10303.0, 10308.0, 10302.0, 11357.0, 10470.0, 11367.0, 11370.0,
       10454.0, 10451.0, 11436.0, 11426.0, 10153.0, 11004.0, 11428.0,
       11427.0, 11001.0, 11363.0, 10004.0, 10474.0, 11430.0, 10000.0,
       10307.0, 11239.0, 10119.0, 10006.0, 10048.0, 11697.0, 11692.0,
       11693.0, 10573.0, 83.0, 11559.0, 10020.0, 77056.0, 11776.0, 70711.0,
       10282.0, 11109.0, 10044.0, '10452', '11233', '10468', '10310',
       '11105', '10462', '10029', '10301', '10457', '10467', '10469',
       '11225', '10035', '10031', '11226', '10454', '11221', '10025',
       '11229', '11235', '11422', '10472', '11208', '11102', '10032',
       '11216', '10473', '10463', '11213', '10040', '10302', '11231',
       '10470', '11204', '11104', '11212', '10466', '11416', '11214',
       '10009', '11692', '11385', '11423', '11201', '10024', '11435',
       '10312', '10030', '11106', '10033', '10303', '11215', '11222',
       '11354', '10016', '10034', '11420', '10304', '10019', '11237',
       '11249', '11230', '11372', '11207', '11378', '11419', '11361',
       '10011', '11357', '10012', '11358', '10003', '10002', '11374',
       '10007', '11234', '10065', '11369', '11434', '11205', '11206',
       '11415', '11236', '11218', '11413', '10458', '11101', '10306',
       '11355', '10023', '11368', '10314', '11421', '10010', '10018',
       '11223', '10455', '11377', '11433', '11375', '10037', '11209',
       '10459', '10128', '10014', '10282', '11373', '10451', '11238',
       '11211', '10038', '11694', '11203', '11691', '11232', '10305',
       '10021', '11228', '10036', '10001', '10017', '11217', '11219',
       '10308', '10465', '11379', '11414', '10460', '11417', '11220',
       '11366', '10027', '11370', '10309', '11412', '11356', '10456',
       '11432', '10022', '10013', '11367', '11040', '10026', '10475',
       '11210', '11364', '11426', '10471', '10119', '11224', '11418',
       '11429', '11365', '10461', '11239', '10039', '00083', '11411',
       '10075', '11004', '11360', '10453', '10028', '11430', '10307',
       '11103', '10004', '10069', '10005', '10474', '11428', '11436',
       '10020', '11001', '11362', '11693', '10464', '11427', '10044',
       '11363', '10006', '10000', '02061', '77092-2016', '10280', '11109',
       '14225', '55164-0737', '19711', '07306', '000000', 'NO CLUE',
       '90010', '10281', '11747', '23541', '11776', '11697', '11788',
       '07604', 10112.0, 11788.0, 11563.0, 11580.0, 7087.0, 11042.0,
       7093.0, 11501.0, 92123.0, 0.0, 11575.0, 7109.0, 11797.0, '10803',
       '11716', '11722', '11549-3650', '10162', '92123', '23502', '11518',
       '07020', '08807', '11577', '07114', '11003', '07201', '11563',
       '61702', '10103', '29616-0759', '35209-3114', '11520', '11735',
       '10129', '11005', '41042', '11590', 6901.0, 7208.0, 11530.0,
       13221.0, 10954.0, 11735.0, 10103.0, 7114.0, 11111.0, 10107.0], dtype=object)

 
当我们在 “Incident Zip” 列使用 .unique()，很轻易的发现这些数据很混乱。
下面是问题列表：

类型问题，有些值是字符串的数值，有些是浮点型的数值
空值问题，有些值是 nan
格式问题，有些 Zip Code 中间有“-”，有些是有两位数值
正规化问题，有些值是 Pandas 不能识别的值，如 ‘N/A’或 ‘NO CLUE’

如何处理：

正规化 ‘N/A’或 ‘NO CLUE’为常规的 nan 值
仔细分析 ‘83’，再决定如何处理
全部转换为 string 类型

修复 nan 值和字符串/浮点类型的混乱问题
我们在使用 pd.read_csv() 时候，通过传递可选参数 “na_values”来清洗一部分数据。我们还会通过参数指定 “Incident Zip”的数据类型，将类型确定为字符串，而不是浮点型

na_values = ['NO CLUE', 'N/A', '0']
requests = pd.read_csv('../data/311-service-requests.csv', na_values=na_values, dtype={'Incident Zip': str})

requests['Incident Zip'].unique()

array(['11432', '11378', '10032', '10023', '10027', '11372', '11419',
       '11417', '10011', '11225', '11218', '10003', '10029', '10466',
       '11219', '10025', '10310', '11236', nan, '10033', '11216', '10016',
       '10305', '10312', '10026', '10309', '10036', '11433', '11235',
       '11213', '11379', '11101', '10014', '11231', '11234', '10457',
       '10459', '10465', '11207', '10002', '10034', '11233', '10453',
       '10456', '10469', '11374', '11221', '11421', '11215', '10007',
       '10019', '11205', '11418', '11369', '11249', '10005', '10009',
       '11211', '11412', '10458', '11229', '10065', '10030', '11222',
       '10024', '10013', '11420', '11365', '10012', '11214', '11212',
       '10022', '11232', '11040', '11226', '10281', '11102', '11208',
       '10001', '10472', '11414', '11223', '10040', '11220', '11373',
       '11203', '11691', '11356', '10017', '10452', '10280', '11217',
       '10031', '11201', '11358', '10128', '11423', '10039', '10010',
       '11209', '10021', '10037', '11413', '11375', '11238', '10473',
       '11103', '11354', '11361', '11106', '11385', '10463', '10467',
       '11204', '11237', '11377', '11364', '11434', '11435', '11210',
       '11228', '11368', '11694', '10464', '11415', '10314', '10301',
       '10018', '10038', '11105', '11230', '10468', '11104', '10471',
       '11416', '10075', '11422', '11355', '10028', '10462', '10306',
       '10461', '11224', '11429', '10035', '11366', '11362', '11206',
       '10460', '10304', '11360', '11411', '10455', '10475', '10069',
       '10303', '10308', '10302', '11357', '10470', '11367', '11370',
       '10454', '10451', '11436', '11426', '10153', '11004', '11428',
       '11427', '11001', '11363', '10004', '10474', '11430', '10000',
       '10307', '11239', '10119', '10006', '10048', '11697', '11692',
       '11693', '10573', '00083', '11559', '10020', '77056', '11776',
       '70711', '10282', '11109', '10044', '02061', '77092-2016', '14225',
       '55164-0737', '19711', '07306', '000000', '90010', '11747', '23541',
       '11788', '07604', '10112', '11563', '11580', '07087', '11042',
       '07093', '11501', '92123', '00000', '11575', '07109', '11797',
       '10803', '11716', '11722', '11549-3650', '10162', '23502', '11518',
       '07020', '08807', '11577', '07114', '11003', '07201', '61702',
       '10103', '29616-0759', '35209-3114', '11520', '11735', '10129',
       '11005', '41042', '11590', '06901', '07208', '11530', '13221',
       '10954', '11111', '10107'], dtype=object)

 
“-”怎么处理

rows_with_dashes = requests['Incident Zip'].str.contains('-').fillna(False)
len(requests[rows_with_dashes])

5

requests[rows_with_dashes]

29136    77092-2016
30939    55164-0737
70539    11549-3650
85821    29616-0759
89304    35209-3114
Name: Incident Zip, dtype: object

我们可以简单粗暴的认为这些数据是缺失值，将其删除

requests['Incident Zip'][rows_with_dashes] = np.nan

但是，仔细分析下来9位数字长度的邮编也是正常的，接下来，我们查找下所有大于 5 位数字长度的邮编，确保这些是正常的，然后截断他们

long_zip_codes = requests['Incident Zip'].str.len() > 5
requests['Incident Zip'][long_zip_codes].unique()

array(['77092-2016', '55164-0737', '000000', '11549-3650', '29616-0759',
       '35209-3114'], dtype=object)

这些都是可以被我们截断的

requests['Incident Zip'] = requests['Incident Zip'].str.slice(0, 5) 

完成
 
最开始，认为 00083 是一个错误的邮编，最后发现这是一个真实存在的邮编！数据中还有 “00000” 的邮编，我们还是需要考虑下这个邮编的，下面我们找出所有这样邮编的数据。

requests[requests['Incident Zip'] == '00000']

这个结果看起来并不好，还是把他们赋值成 nan

zero_zips = requests['Incident Zip'] == '00000'
requests['Incident Zip'][zero_zips] = np.nan

 
见证一下阶段性的成果

# 正常这里是不需要再次进行类型转换，我这里不转换，排序会报错

unique_zips = requests['Incident Zip'].unique()
unique_zips.sort()
unique_zips

array(['00083', '02061', '06901', '07020', '07087', '07093', '07109',
       '07114', '07201', '07208', '07306', '07604', '08807', '10000',
       '10001', '10002', '10003', '10004', '10005', '10006', '10007',
       '10009', '10010', '10011', '10012', '10013', '10014', '10016',
       '10017', '10018', '10019', '10020', '10021', '10022', '10023',
       '10024', '10025', '10026', '10027', '10028', '10029', '10030',
       '10031', '10032', '10033', '10034', '10035', '10036', '10037',
       '10038', '10039', '10040', '10044', '10048', '10065', '10069',
       '10075', '10103', '10107', '10112', '10119', '10128', '10129',
       '10153', '10162', '10280', '10281', '10282', '10301', '10302',
       '10303', '10304', '10305', '10306', '10307', '10308', '10309',
       '10310', '10312', '10314', '10451', '10452', '10453', '10454',
       '10455', '10456', '10457', '10458', '10459', '10460', '10461',
       '10462', '10463', '10464', '10465', '10466', '10467', '10468',
       '10469', '10470', '10471', '10472', '10473', '10474', '10475',
       '10573', '10803', '10954', '11001', '11003', '11004', '11005',
       '11040', '11042', '11101', '11102', '11103', '11104', '11105',
       '11106', '11109', '11111', '11201', '11203', '11204', '11205',
       '11206', '11207', '11208', '11209', '11210', '11211', '11212',
       '11213', '11214', '11215', '11216', '11217', '11218', '11219',
       '11220', '11221', '11222', '11223', '11224', '11225', '11226',
       '11228', '11229', '11230', '11231', '11232', '11233', '11234',
       '11235', '11236', '11237', '11238', '11239', '11249', '11354',
       '11355', '11356', '11357', '11358', '11360', '11361', '11362',
       '11363', '11364', '11365', '11366', '11367', '11368', '11369',
       '11370', '11372', '11373', '11374', '11375', '11377', '11378',
       '11379', '11385', '11411', '11412', '11413', '11414', '11415',
       '11416', '11417', '11418', '11419', '11420', '11421', '11422',
       '11423', '11426', '11427', '11428', '11429', '11430', '11432',
       '11433', '11434', '11435', '11436', '11501', '11518', '11520',
       '11530', '11549', '11559', '11563', '11575', '11577', '11580',
       '11590', '11691', '11692', '11693', '11694', '11697', '11716',
       '11722', '11735', '11747', '11776', '11788', '11797', '13221',
       '14225', '19711', '23502', '23541', '29616', '35209', '41042',
       '55164', '61702', '70711', '77056', '77092', '90010', '92123', 'nan'], dtype=object)

还是不错的，数据已经更加清晰了。
最后整合一下所有代码
下面是我们上面做的清洗邮编的代码，如下：

na_values = ['NO CLUE', 'N/A', '0']
requests = pd.read_csv('../Data/311-service-requests.csv', 
                       na_values=na_values, 
                       dtype={'Incident Zip': str}

 def fix_zip_codes(zips):

    # 将长度大于 5 位数字的邮编，截断为 5 位 
    zips = zips.str.slice(0, 5)
    
    # 将 00000 赋值为 nan
    zero_zips = zips == '00000'
    zips[zero_zips] = np.nan
    
    return zips



requests['Incident Zip'] = fix_zip_codes(requests['Incident Zip'])

requests['Incident Zip'].unique()

 

311-service-requests.csv
链接：https://pan.baidu.com/s/1mh9HxTe 密码：ksq4

知乎地址：https://zhuanlan.zhihu.com/p/32548330
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/BoyceYang/p/8176958.html
====================================================================================================
SpringMVC对包的扫描范围扩大后，导致的事务配置不生效问题
****************************************************************************************************
问题场景
项目使用的框架：Spring 4.1.4 + Hibernate 4.3.8 + MySQL。
web.xml中对Spring的配置：

<!-- 把 Spring 容器集成到 Web 应用里面 -->
  <listener>
    <listener-class>
      org.springframework.web.context.ContextLoaderListener
    </listener-class>
  </listener>

  <!-- spring配置文件 -->
  <context-param>
    <param-name>contextConfigLocation</param-name>
    <param-value>classpath:/applicationContext.xml</param-value>
  </context-param>

  <!--DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，而且负责职责的分派，
  而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。-->
  <!--DispatcherServlet会默认加载[servlet-name]-servlet.xml文件-->
  <servlet>
    <servlet-name>spring</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>spring</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

 
项目使用AOP声明式事务配置

<!--  声明式容器事务管理 ,transaction-manager指定事务管理器为transactionManager -->
    <tx:advice id="transactionAdvice" transaction-manager="transactionManager">
        <tx:attributes>
            <tx:method name="query*" read-only="true"/>
            <tx:method name="get*" read-only="true"/>
            <tx:method name="save*" rollback-for="Exception" propagation="REQUIRED"/>
            <tx:method name="update*" rollback-for="Exception" propagation="REQUIRED"/>
        </tx:attributes>
    </tx:advice>
    <aop:config>
        <!--只对业务逻辑层实施事务 -->
        <aop:pointcut expression="execution(* com.zhimajp.auction.service.impl..*.*(..))" id="busiLogicService"/>
        <aop:advisor advice-ref="transactionAdvice" pointcut-ref="busiLogicService"/>
    </aop:config>

采用annotation方式声明Spring Bean。
遇到的问题是：通过Hibernate执行save方法后，数据未能插入到DB中并且控制台也没有打印出SQL（控制台没有输出）。
解决问题
通过仔细排查，阅读网络文章后，发现问题出现在spring-servlet.xml中：
 <!--扫描注解包 配置这条便可移除 <context:annotation-config/> --> <context:component-scan base-package="com.zhimajp.auction" /> 
上述配置的结果是：SpringMVC对Service和Dao的所有package进行了扫描装载。
问题分析：
1、Spring与SpringMVC属于父子容器关系。框架启动时先启动Spring容器，而后启动SpringMVC容器。子容器可以访问父容器中的Bean，而父容器不能访问子容器中的Bean。
2、由于SpringMVC在扫描时扩大了扫描范围，装载了@Service标识的类的实例，从而导致Controller层在注入Service时，实际注入的时子容器中的Service实例。
3、事务被配置在父容器中，Spring父容器在装载Service时会同时应用事务配置，而SpringMVC只是单纯加载Service的实例。
问题解决：
将SpringMVC的包扫描限定在Controller。
  <context:component-scan base-package="com.zhimajp.auction.controller" /> 
 
进一步
打印容器管理的bean名称
我们使SpringMVC扫描Controller和Service，Spring扫描Service和DAO。
使用以下代码打印父子窗口管理的bean名称：

　　　　　WebApplicationContext webApplicationContext = WebApplicationContextUtils.getWebApplicationContext(request.getSession().getServletContext());
        String[] definationBeanNames = webApplicationContext.getBeanNamesForAnnotation(Service.class);
        List<String> names = new ArrayList<String>(Arrays.asList(definationBeanNames));
        Collections.addAll(names, webApplicationContext.getBeanNamesForAnnotation(Controller.class));
        Collections.addAll(names, webApplicationContext.getBeanNamesForAnnotation(Repository.class));
        System.out.println("Spring 父容器管理的Bean：");
        for(String beanName : names){
            System.out.println(beanName);
        }
        webApplicationContext = RequestContextUtils.getWebApplicationContext(request);
        definationBeanNames = webApplicationContext.getBeanNamesForAnnotation(Service.class);
        names = new ArrayList<String>(Arrays.asList(definationBeanNames));
        Collections.addAll(names, webApplicationContext.getBeanNamesForAnnotation(Controller.class));
        Collections.addAll(names, webApplicationContext.getBeanNamesForAnnotation(Repository.class));

        System.out.println("SpringMVC 子容器管理的Bean：");
        for(String beanName : names){
            System.out.println(beanName);
        }


 我们发现父子容器同时维护了Service层的类的实例，并且应该是两个独立的实例。
只使用子容器，而完全不使用父容器
现在我们测试另外一个场景
将web.xml中，注释掉ContextLoaderListener，修改配置为：

<!--DispatcherServlet是前端控制器设计模式的实现，提供Spring Web MVC的集中访问点，而且负责职责的分派，
  而且与Spring IoC容器无缝集成，从而可以获得Spring的所有好处。-->
  <!--DispatcherServlet会默认加载[servlet-name]-servlet.xml文件-->
  <servlet>
    <servlet-name>spring</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
      <param-name>contextConfigLocation</param-name>
      <param-value>classpath:/applicationContext.xml;/WEB-INF/spring-servlet.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
  </servlet>
  <servlet-mapping>
    <servlet-name>spring</servlet-name>
    <url-pattern>/</url-pattern>
  </servlet-mapping>

移除了父容器，所有配置文件全部交由SpringMVC加载 。
打印结果如下：

子容器管理所有的bean，而父容器为null（代码抛出了空指针）。
项目同样运行正常。
总结
1、当事务交由Spring管理时，Spring负责管理session中事务的开启、关闭、flush等步骤，开发者只需调用例如save、update方法即可。
2、当web项目框架中存在父子容器，且事务由父容器管理时，就应当注意SpringMVC对包的扫描范围并且只需扫描Controller组件。官方推荐：父子容器应当各执其责。
3、如果子容器加载了Service的话，则在该实例上事务并不会生效。也就是Spring不会在service的方法被调用时自动开启事务。
4、基于2中的前提：SpringMVC应只加载web相关配置（视图配置、Controller注解扫描），由Spring加载数据源、事务配置、Service和Dao注解扫描。
 
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/zhaojz/p/8176052.html
====================================================================================================
（神州优车）数据交换平台架构分享
****************************************************************************************************
一、数据交换平台定义（百度百科）
数据交换平台是指将分散建设的若干应用信息系统进行整合，通过计算机网络构建的信息交换平台，它使若干个应用子系统进行信息/数据的传输及共享，提高信息资源的利用率，成为进行信息化建设的基本目标，保证分布异构系统之间互联互通，建立中心数据库，完成数据的抽取、集中、加载、展现，构造统一的数据处理和交换。
二、Why数据交换平台?
1.分布式的需要
PS：(分布式出现的两个驱动要素：1.业务场景越来越复杂，需要进行系统拆分；2.性能的需要)
场景举例一：EDA
通过数据交换平台，把数据库Log事件（如Mysql的binlog）发送到MQ，驱动后续流程（如:刷新缓存，构造搜索引擎，业务流程驱动<如:下单之后发短信>等）

场景举例二：CQRS
【命令、查询分离】的思想本质上就是同一份数据建立两套视图：一套是模型清晰的Domain-Mode，代表业务实体，满足复杂业务逻辑的需要；另一套是查询视图，主要面向查询场景，不关心数据库范式，只关心查询最优最快

2.容灾备份的需要
场景举例一：多机房
多中心、多备份、异地多活等是很多大公司正在实践或者已经实践过的技术难题，这中间的核心便是一整套完整的数据同步方案
场景举例二：数据镜像
通过数据交换平台，可以创建各种类型的DB镜像，满足不同场景下的使用需要
场景举例三：数据归档
通过增量交换，可以实现实时归档
3.异构、重构的需要
场景举例一：DB升级换代
通过数据交换平台解决升级过程中的版本兼容性问题
场景举例二：资产复用
任何一个公司都有大大小小的各种IT资产，通过数据交换平台，可以实现这些核心资产的整合、复用
场景举例三：迁库、拆库
系统进行重构，业务应用要拆分为两个子系统，对应的数据库由一个拆成两个，需要数据交换平台先进行全量Copy，再进行增量同步，然后配合系统完成迁移对接，如下所示

三、(神州优车)数据交换平台总体架构
总体架构图如下所示，整个平台由三个子系统组成

ucar_datalink（增量同步子系统）
ucar_datalink是优车技术团队自研的一套数据同步中间件，主要满足各异构数据源之间的实时增量同步需求，具有高伸缩性、高扩展性和高性能等优点
ucar_dataX（全量同步子系统）
ucar_datax是对Alibaba开源的datax进行了深度定制和改造，满足集团内的全量数据同步需求
Admin（管理监控子系统）
管理子系统对整个增量和全量集群进行运维管理，包括：HA、同步申请自动处理、延迟监控、异常监控、机器监控等等
四、Datalink产品介绍
Datalink借鉴了数个开源产品的设计

借鉴了Kafka-Connect的基础设施：分组、HA、Rebalance协议、Task模型等
借鉴了Otter的诸多功能模型：领域模型抽象、双向同步、数据压缩合并、数据权重算法等
参与了Linkedin的Databus的一些设计思想

1.Datalink的基础设施模型

Manager
整个Datalink集群的大脑，负载均衡协调器、配置管理、集群监控
Group
分组是一个核心逻辑概念，通过分组实现组内自治、组间隔离，便于进行拆分管理
Worker
Worker是Task的运行容器，一个Worker节点运行一系列同步任务，Worker归属于某个分组
Task
数据同步任务实例，由一个reader和至少一个writer组成，归属于某个分组，在一个分组内Task通过一定的负载均衡策略，被分配到不同的Worker上执行
Rebalance
Rebalance单位：分组；
Rebalance时机：Manager主备切换、Worker加入分组、Worker离开分组、新增Task、删除Task
2.Datalink的领域模型

Contract
针对每种类型的数据库，我们会抽象一套契约类型，有了这套契约便可实现Reader和Writer的任意组合
比如我们针对关系型数据库抽象一个契约，契约的核心类名为RdbEventRecord，代表一条数据库log事件变更，围绕这个契约，我们可以开发若干插件
如果是Reader插件，这个插件的一个核心功能就是做数据类型转换，如MysqlReader、SqlserverReader、OracleReader分别会把自己对应数据库的底层log-event转换为RdbEventRecord即可
如果是Writer插件，需要的是针对每一种契约实现一个处理器，如HbaseWriter，其主要目的是往hbase写数据，但是在不同的Task中，它对接的Reader是随机的，所以需要的是对不同类型契约的数据做适配
Business Model
领域模型借鉴了Aalibaba-Otter的一些思想，针对数据同步领域的一些常见功能，我们进行了深度分析和抽象
* MediaSource：
是对数据源的抽象，所有类型的数据源都会保存到这个模型，神州内部已经支持的数据源有 MYSQL, SQLSERVER, ORACLE, HDFS,  HBASE, ELASTICSEARCH, ZOOKEEPER,POSTGRESQL
* Media：
是对数据存储单元的抽象，可以是关系型数据库的表、Hbase的表、ElastaicSearch的索引等等
* MediaMapping：
是对数据交换协议的抽象，所有类型的Media之间的数据同步关系都保存到这个模型
* 支持的功能
依托这套领域模型，可以实现的一些主要功能特性如下所示
    库别名
    表别名
    列别名
    列白名单
    列黑名单
    多表合一
    多表聚合
    主键跳过
    同步拦截器
    按权重同步
3.Datalink的插件模型

Task&Plugin
* Task是Datalink中的一个核心概念，一个运行中的Task就是一个数据同步任务
* Task由一个Reader和若干个Writer组成，即可以实现一对多的数据同步
* Task的数据同步流程：由Reader端取数据，然后放到内存队列，Writer端消费数据，成功的话执行Ack操作，失败的话执行Rollback操作
* Task提供了插件机制，一个Task只有在运行时才知道自己组装的Reader和Writer是什么
* Task的Reader和Writer插件在运行时有自己独立的ClassLoader，以解决同一进程中jar包冲突的问题
* 通过这套插件模型我们可以实现最大程度的基础设施复用：一套框架支持各种数据源之间的增量同步需求，框架稳定之后，后期关注重点只需要放到插件开发上即可，目前我们内部实现的插件有：
    MysqlReader
    FlexibleQReader（FlexibleQ：内部消息中间件）
    RdbmsWriter
    HbaseReader（建设中）
    ElasticSearchWriter
    HdfsWriter
    FlexibleQWriter
    HbaseWriter(建设中)
（神州优车内部）Datalink同步场景举例
1.Mysql同步到RDBMS

简介
* 该场景下的数据同步主要分为两种：一种是线上各个系统间的基础参数表同步，另外一种是线上数据同步到OLAP系统（主要是BI）
* 支持多种同步模式
    全局有序同步：完全按照源端binlog的执行顺序进行重放
    局部有序同步：以表为单位进行聚合，保证单表内同步是有序的
    完全并发：当开启merger功能的时候，在merge合并完之后，能保证同一张表的同一条数据只有一条binlog事件，此时可以完全打乱顺序，保证最终一致即可
2.Mysql同步到ElasticSearch

简介
* 订单库(Mysql)为应对线上的各种交易请求已经足够忙碌，查询操作必须放到二级系统中去做，所以实现了Mysql到ES的同步，所有查询走ES
* 在同步过程中，可以实现多表聚合，即将Mysql中多张有外键关系的表，在同步过程中进行聚合，到ES端，多张表的数据合并成一条
3.Mysql同步到Hadoop

简介
* 作为大数据平台的第一层，datalink负责把线上生产库的binlog变更同步到Hadoop
* 数据处理平台每天凌晨对T-1的数据进行清洗、去重，把同步过去的binlog数据更新到spark-hive
4.Mysql同步到MQ

简介
* 目前我们内部主要是通过监听binlog事件实现【缓存刷新】和【业务通知】功能
5.分布式DB同步

简介
* 类似于电商平台【买家和卖家】的划分，神州专车平台对应的划分为【乘客和司机】，为应对性能压力，我们对DB进行了分库处理，这样就产生了两个维度，主维度是乘客，子维度是司机
  我们需要把主维度产生的数据进行Re-Sharding操作同步到司机维度的分库，以满足司机数据查询的需求
主要列举这些，后续梳理完之后再进行补充

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/ucarinc/p/7831752.html
====================================================================================================
Python函数篇（6）-常用模块及简单的案列
****************************************************************************************************
1.模块
  函数的优点之一，就是可以使用函数将代码块与主程序分离，通过给函数指定一个描述性的名称，并将函数存储在被称为模块的独立文件中，再将模块导入主程序中，通过import语句允许在当前运行的程序文件中使用模块中的代码，一个.py文件就称为一个模块，包含了Python对象定义和Python语句。
  如下就是一个简单的模块cal.py
def cal(x,y):
    return x+y
  导入模块的方法有很多种
import module      #导入整个模块
from module.xx.xx import xx     #导入模块中的特定函数
from module.xx.xx import xx as rename    #使用as给函数指定别名
from module.xx.xx import *    #导入模块中的所有函数（不推荐）
  对于上面一个模块，如果想要在另一文件中调用它，即:

  这种就通过import导入，但是调用的时候需要使用模块名.函数名的方式调用,即
import cal
print(cal.cal(3,5))
  那么函数再导入模块的时候是以哪个路径为基准呢？
import sys
print(sys.path)
  通过sys.path输出的路径，就是寻找该模块的基准路径。
  模块分为三种
  - 自定义模块
  - 第三方模块
  - 内置模块
  - 自定义模块
2.常用模块

time
时间有关的操作，有三种表达方式：
1.时间戳(time.time)
2.结构化时间(time.localtime)
3.格式化的字符串(time.striftime)

import time
print(time.time())    #时间戳，是指从1970年1月1日0点0分到当前时间过了多少秒，常用来计算
运行结果：1513730364.4014938
print(time.localtime())   #结构化时间，通过这种方式，可以截取具体的年月日时分秒等信息
运行结果：time.struct_time(tm_year=2017, tm_mon=12, tm_mday=20, tm_hour=8, tm_min=40, tm_sec=58, tm_wday=2, tm_yday=354, tm_isdst=0)
t=time.localtime()
print(t.tm_year)      #运行结果：2017 可以通过.关键字的方式，截取想要的信息
print(time.strftime("%Y-%m-%d,%X"))    #格式化的字符串，必须写入想输出的时间格式
运行结果：2017-12-20,08:48:01
将元组形式的时间转化为字符串形式，返回时间形式为：Thu Dec 28 09:21:06 2017
print(time.asctime())
返回结果格式同asctime
print(time.ctime())
返回UTC时间结构化时间
print(time.gmtime())
  三种表达方式的互相转化
格式化的字符串转换成结构化时间：
print(time.strptime("2017-12-20","%Y-%m-%d"))
将结构化时间转换成时间戳
print(time.mktime(time.localtime()))
将结构化时间转换成格式化的字符串
print(time.strftime("%Y-%m-%d %X",time.localtime()))


random
随机模块，主要功能如下:

import random
#随机生成一个0-1的浮点数
print(random.random())
#随机生成一个整数
#生成一个指定范围内的随机浮点数
print(random.uniform(10,20))
#随机生成一个整数
print(random.randint(1,9))
#从指定范围内，按指定基数递增的集合中 获取一个随机数
print(random.randrange(10,100,2))    #随机取10-100之间的偶数
#从序列中随机获取一个元素
print(random.choice(["tuple","list","dic"]))
#将一个列表中的元素打乱
p=["tuple","list","dic"]
random.shuffle(p)
print(p)
  随机数小案例 ，生成一个五位的随机数
import random
def random_code():
    res=""
    for i in range(5):            
        num=random.randint(0,9)           
        alf=chr(random.randint(60,100))
        result=str(random.choice([num,alf]))
        res+=result
    return res
print(random_code())


os模块

  提供对操作系统进行调用的接口，该模块的介绍我在linux操作系统下完成
os.getcwd()                 获取当前所在路径
os.chdir("test")            改变当前的工作路径，相当于cd
os.makedirs('test/test1')   创建多级目录
os.removedirs('test1')      递归删除，如目录为空，则删除
os.mkdir('test')            创建单级目录
os.rmdir('dirname')         删除单级空目录，目录不为空无法删除，报错
os.listdir('dirname')       列出指定目录下的所有文件和子目录，包括隐藏文件，并以列表方式打印
os.remove()                 删除一个文件
os.rename("oldname","new")  重命名文件，用“，”分割
os.stat('path/filename')    获取文件/目录信息
os.sep                      操作系统的路径分隔符，win下为"\\",Linux下为"/"
os.linesep                  当前平台使用的行终止符，win下为"\t\n",Linux下为"\n"
os.pathsep                  用于分割文件路径的字符串
os.name                     字符串指示当前使用平台。win->'nt'; Linux->'posix'
os.system("bash command")   运行shell命令，直接显示
os.environ                  获取系统环境变量
os.path.abspath(path)       返回path规范化的绝对路径
os.path.split(path)         将path分割成目录和文件名二元组返回
os.path.dirname(path)       返回path的目录。其实就是os.path.split(path)的第一个元素
os.path.basename(path)      返回path最后的文件名。如何path以／或\结尾，那么就会返回空值。即os.path.split(path)的第二个元素
os.path.join(path1[, path2[, ...]])  将多个路径组合后返回，第一个绝对路径之前的参数将被忽略


sys模块

sys.argv           命令行参数List，第一个元素是程序本身路径
sys.exit(n)        退出程序，正常退出时exit(0)
sys.version        获取Python解释程序的版本信息
sys.maxint         最大的Int值
sys.path           返回模块的搜索路径，初始化时使用PYTHONPATH环境变量的值
sys.platform       返回操作系统平台名称
sys.stdin          输入
sys.stdout         输出
sys.stderror       错误
  进度百分比小案例
import sys
import time
def calc(num, total):
    rate = float(num) / float(total)     #float 浮点数关键字
    rate_num = int(rate * 100)
    r = '\r%d%%' % (rate_num, )          #要加上/r转义符，表示将输出的内容返回到第一个指针，即覆盖前面的内容
    sys.stdout.write(r)
    sys.stdout.flush()

if __name__ == '__main__':              #这条语句，如果用在被调用文件里面，用于被调用文件的一个测试
    for i in range(0, 101):                #  如果放在执行文件里面，就是不想让该文件让齐塔程序调用
        time.sleep(0.1)
        calc(i, 100)
  进度条小案例
import sys
import time
for i in range(100):
    sys.stdout.write("#")
    time.sleep(0.1)
    sys.stdout.flush()
  因为工作原因，最近一周没有更新博客，我会在这周补回来，下一篇文章我会重点写re模块。

----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/Chen-Zhipeng/p/8176917.html
====================================================================================================
JVM类加载机制以及类缓存问题的处理
****************************************************************************************************
 
　　当一个java项目启动的时候，JVM会找到main方法，根据对象之间的调用来对class文件和所引用的jar包中的class文件进行加载（其步骤分为加载、验证、准备、解析、初始化、使用和卸载），方法区中开辟内存来存储类的运行时数据结构（包括静态变量、静态方法、常量池、类结构等），同时在堆中生成相应的Class对象指向方法区中对应的类运行时数据结构。具体的类加载过程可以参考尚学堂高琪老师的视频教程：http://www.bjsxt.com/2014/down_0425/34.html第218集。
　　用最简单的一句话来概括，类加载的过程就是JVM根据所需的class文件的路径，通过IO流的方式来读取class字节码文件，并通过一系列解析初始化等步骤来注入到内存。 java中的类加载器有：BootstrapClassLoader（最上层）、ExtClassLoader、AppClassLoader、以及用户自定义的ClassLoader（最下层）。JVM对于不同种类的jar包（或class文件），会有不同种类的类加载器进行加载。对应关系如下：　　

BootstrapClassLoader  用于加载JVM运行所需要的类：

　　　　JAVA_HOME/jre/lib/resources.jar:

　　　　JAVA_HOME/jre/lib/rt.jar:

　　　　JAVA_HOME/jre/lib/sunrsasign.jar:

　　　　JAVA_HOME/jre/lib/jsse.jar:

　　　　JAVA_HOME/jre/lib/jce.jar:

　　　　JAVA_HOME/jre/lib/charsets.jar:

　　　　JAVA_HOME/jre/lib/jfr.jar:

　　　　JAVA_HOME/jre/classes

　

　　ExtClassLoader 用于加载扩展类：　　

　　　　../Java/Extensions:

　　　　../JAVA_HOME/jre/lib/ext:

　　　　../Library/Java/Extensions:/Network/Library/Java/Extensions:

　　　　../System/Library/Java/Extensions:

　　　　../lib/java

　　

　　AppClassLoader 用于加载我们项目中ClassPath下所创建的类和jar包中引用的类。

　　整个类加载，是通过一种叫做双亲委派的机制来进行加载。
　　举例来说，一个类被最下层的加载器（用户自定义ClassLoader）进行加载，此加载器首先会调用上一层的加载器（AppClassLoader）进行加载，而AppClassLoader会继续转交给上层（ExtClassLoader）的加载器进行加载，直到BootstrapClassLoader。  如果BootstrapClassLoader所加载的类路径找不到此类，那么才会交给下一层的加载器（ExtClassLoader）进行加载，如果找不到此类，继续交给下一层（AppClassLoader）进行加载。以此类推，如果用户自定义的ClassLoader也找不到此类，那么程序就会抛出一个ClassNotFoundError。整个加载过程图示如下：
（图片引用自：https://www.cnblogs.com/xing901022/p/4574961.html）
　　类加载源的源码跟踪如下（在此对源码进行了适当的简化），读者可以点入源码进行查看：

package java.lang.ClassLoader;
import ....

 protected Class<?> loadClass(String name, boolean resolve)
        throws ClassNotFoundException
    {
        synchronized (getClassLoadingLock(name)) {
            // First，在虚拟机内存中查找是否已经加载过此类...类缓存的主要问题所在！！！ 
            Class<?> c = findLoadedClass(name);
            if (c == null) {
                long t0 = System.nanoTime();
                try {
                    if (parent != null) {　　　　　　　　　　　　　　 //先让上一层加载器进行加载
                        c = parent.loadClass(name, false);
                    } else {
                        c = findBootstrapClassOrNull(name);
                    }
                } catch (ClassNotFoundException e) {
                    // ClassNotFoundException thrown if class not found
                    // from the non-null parent class loader
                }

                if (c == null) {
　　　　　　　　　　　　//调用此类加载器所实现的findClass方法进行加载
                    c = findClass(name);
                }
            }
            if (resolve) {
                resolveClass(c);
            }
            return c;
        }
    }

　　在源码中可以完全领略到双亲委派机制的过程，其中最重要的三句代码已经进行了标注：
　　　　findLoadedClass（在虚拟机内存中查找是否已经加载过此类...类缓存的主要问题所在！！！）
　　　　parent.loadClass（先让上一层加载器进行加载）
　　　　findClass（调用此类加载器所实现的findClass方法进行加载）　　如果用户需要自定义加载器，加载自己指定路径的class文件，需要继承ClassLoader，并实现findClass(String name)方法。举例如下：

package com.jiefupay.utils;

import java.io.ByteArrayOutputStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;

public class ServiceClassLoader extends ClassLoader{

    private String classPath;
    
    public ServiceClassLoader(String classPath) {
        this.classPath = classPath;
    }
    
    /**
     * 重写父类的findClass 方法。  父类的loadClass会调用此方法
     */
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
   
        Class<?> c = null;
        
        byte[] classData = getClassData(name);
        
        if (classData!=null) {
            c = defineClass(name, classData, 0, classData.length);
        }else {
            throw new ClassNotFoundException();
        }
        
        return c;
    }
　　　　　　 // 将class文件通过IO流读取，转化为字节数组
    private byte[] getClassData(String name) {
        
        String path = classPath + "/"+ name.replace('.', '/') + ".class";
        
        InputStream iStream = null;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();
        try {
            iStream = new FileInputStream(path);
            
            byte[] buffer = new byte[1024];
            int temp = 0;
            while ((temp = iStream.read(buffer))!=-1) {
                byteArrayOutputStream.write(buffer, 0, temp);
            }
            if (byteArrayOutputStream!=null) {
                return byteArrayOutputStream.toByteArray();
            }
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            try {
                if (iStream!=null) {
                    iStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
            try {
                if (byteArrayOutputStream!=null) {
                    byteArrayOutputStream.close();
                }
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return null;
    }
}

　　对类加载器的使用代码如下：

ServiceClassLoader serviceClassLoader = new ServiceClassLoader("c:\myclass");
Czlass<?> c = ServiceClassLoader.loadClass("com.jiefupay.service.Myclass");

　　如果用同一个ServiceClassLoader对象去加载同一个Class文件多次，每次加载后的Class对象为同一个！ 然而如果new不同的自定义ClassLoader去加载同一个Class文件，则每次会返回不同的Class对象。
　　注意：不能将所要加载的Class文件放到classpath目录及其任何子目录下，否则会被AppClassLoader优先加载（这是由于类加载采用双亲委派机制，同时AppClassLoader可以加载所有在classpath下的class文件），每次都是同一个AppClassLoader进行加载，因此会出现类缓存问题。
　　这样就解决了通常在JVM类加载时，直接使用反射出现的类缓存的问题。
　　
p.p1 { margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Monaco }
p.p1 { margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Monaco; color: #4e9072 }
span.Apple-tab-span { white-space: pre }
p.p1 { margin: 0.0px 0.0px 0.0px 0.0px; font: 11.0px Monaco; color: #4e9072 }
span.Apple-tab-span { white-space: pre }
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/malcolmfeng/p/8177030.html
====================================================================================================
Spark源码剖析（六）：Worker原理与源码剖析
****************************************************************************************************
上篇文章我们剖析了Master的原理和源码，知道了当Master使用资源分配算法将资源分配完成后，就会给对应的Worker发送启动Driver或者Executor的消息，那么Worker收到这些消息后，具体是怎么启动Driver或者Executor的呢？这篇文章就让我们深入剖析一下Worker的原理和源码。一、启动DriverWorker接收到了Master发送过来的启动Driver的信息，LaunchDriver函数首先启动一个DriverRunner线程。worker.actor ! LaunchDriver(driver.id, driver.desc)   val driver = new DriverRunner(……) 接着调用DriverRunner的start方法，首先在DriverRunner线程中首先创建Driver的工作目录，下载相关的jar包，封装启动Driver的命令，然后用java的ProcessBuilder启动Driver进程，并在之后对Driver进程进行管理。driver.start()   launchDriver(builder, driverDir, driverDesc.supervise)   runCommandWithRetry(ProcessBuilderLike(builder), initialize, supervise)   worker ! DriverStateChanged(driverId, state, finalException)   如果还记得Master状态改变处理机制，那么这里就串起来了   这里可以看出Drive失败后并没有重启策略由此可知每一个Driver进程在Worker上都对应了一个DriverRunner线程，该线程负责对Driver的管理 二、启动ExecutorWorker接收到了Master发送过来的启动Executor的信息，LaunchExecutor函数首先启动一个ExecutorRunner线程。worker.actor ! LaunchExecutor(……) 在ExecutorRunner线程中首先创建Executor的工作目录，下载相关的jar包，封装启动Executor的命令，然后用java的ProcessBuilder启动Executor进程，并在之后对Executor进程进行管理。manager.start()   fetchAndRunExecutor()   worker ! ExecutorStateChanged(appId, execId, state, Some(message), Some(exitCode))   master ! ExecutorStateChanged(appId, execId, state, message, exitStatus)   这里可以看出Executor失败后有重启策略，每个Application最大重启次数为10由此可知每一个Executor进程在Worker上都对应了一个ExecutorRunner线程，该线程负责对Executor的管理 三、总结千言万语不如一张图！
----------------------------------------------------------------------------------------------------
https://www.cnblogs.com/LiCheng-/p/8177751.html
====================================================================================================
